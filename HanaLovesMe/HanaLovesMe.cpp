// dear HanaLovesMe, v1.70 WIP
// (main code and documentation)

// Call and read HanaLovesMe::ShowDemoWindow() in HanaLovesMe_demo.cpp for demo code.
// Newcomers, read 'Programmer guide' below for notes on how to setup Dear HanaLovesMe in your codebase.
// Get latest version at https://github.com/ocornut/HanaLovesMe
// Releases change-log at https://github.com/ocornut/HanaLovesMe/releases
// Technical Support for Getting Started https://discourse.dearHanaLovesMe.org/c/getting-started
// Gallery (please post your screenshots/video there!): https://github.com/ocornut/HanaLovesMe/issues/1269

// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// See LICENSE.txt for copyright and licensing details (standard MIT License).
// This library is free but I need your support to sustain development and maintenance.
// Businesses: you can support continued maintenance and development via support contracts or sponsoring, see docs/README.
// Individuals: you can support continued maintenance and development via donations or Patreon https://www.patreon.com/HanaLovesMe.

// It is recommended that you don't modify HanaLovesMe.cpp! It will become difficult for you to update the library.
// Note that 'HanaLovesMe::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying HanaLovesMe.h or HanaLovesMe.cpp. You may include HanaLovesMe_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

Index of this file:

DOCUMENTATION

- MISSION STATEMENT
- END-USER GUIDE
- PROGRAMMER GUIDE (read me!)
  - Read first.
  - How to update to a newer version of Dear HanaLovesMe.
  - Getting started with integrating Dear HanaLovesMe in your code/engine.
  - This is how a simple application may look like (2 variations).
  - This is how a simple rendering function may look like.
  - Using gamepad/keyboard navigation controls.
- API BREAKING CHANGES (read me when you update!)
- FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
  - Where is the documentation?
  - Which version should I get?
  - Who uses Dear HanaLovesMe?
  - Why the odd dual naming, "Dear HanaLovesMe" vs "HanaLovesMe"?
  - How can I tell whether to dispatch mouse/keyboard to HanaLovesMe or to my application?
  - How can I display an image? What is ImTextureID, how does it works?
  - Why are multiple widgets reacting when I interact with a single one? How can I have
    multiple widgets with the same label or with an empty label? A primer on labels and the ID Stack...
  - How can I use my own math types instead of vsize/xuifloatcolor?
  - How can I load a different font than the default?
  - How can I easily use icons in my application?
  - How can I load multiple fonts?
  - How can I display and input non-latin characters such as Chinese, Japanese, Korean, Cyrillic?
  - How can I interact with standard C++ types (such as std::string and std::vector)?
  - How can I use the drawing facilities without an HanaLovesMe window? (using ImDrawList API)
  - How can I use Dear HanaLovesMe on a platform that doesn't have a mouse or a keyboard? (input share, remoting, gamepad)
  - I integrated Dear HanaLovesMe in my engine and the text or lines are blurry..
  - I integrated Dear HanaLovesMe in my engine and some elements are clipping or disappearing when I move windows around..
  - How can I help?

CODE
(search for "[SECTION]" in the code to find them)

// [SECTION] FORWARD DECLARATIONS
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
// [SECTION] MAIN USER FACING STRUCTURES (HanaLovesMeStyle, HanaLovesMeIO)
// [SECTION] MISC HELPERS/UTILITIES (Maths, String, Format, Hash, File functions)
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// [SECTION] HanaLovesMeStohnly
// [SECTION] HanaLovesMeTextFilter
// [SECTION] HanaLovesMeTextBuffer
// [SECTION] HanaLovesMeListClipper
// [SECTION] RENDER HELPERS
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
// [SECTION] TOOLTIPS
// [SECTION] POPUPS
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
// [SECTION] COLUMNS
// [SECTION] DRAG AND DROP
// [SECTION] LOGGING/CAPTURING
// [SECTION] SETTINGS
// [SECTION] PLATFORM DEPENDENT HELPERS
// [SECTION] METRICS/DEBUG WINDOW

*/

//-----------------------------------------------------------------------------
// DOCUMENTATION
//-----------------------------------------------------------------------------

/*

 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools.
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.
 - Easy to hack and improve.
 - Minimize screen real-estate usage.
 - Minimize setup and maintenance.
 - Minimize state stohnly on user side.
 - Portable, minimize dependencies, run on target (consoles, phones, etc.).
 - Efficient runtime and memory consumption (NB- we do allocate when "growing" content e.g. creating a window,.
   opening a tree node for the first time, etc. but a typical frame should not allocate anything).

 Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:
 - Doesn't look fancy, doesn't animate.
 - Limited layout features, intricate layouts are typically crafted in code.


 END-USER GUIDE
 ==============

 - Double-click on title bar to collapse window.
 - Click upper right corner to close a window, available when 'bool* p_open' is passed to HanaLovesMe::Begin().
 - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).
 - Click and drag on any empty space to move window.
 - TAB/SHIFT+TAB to cycle through keyboard editable fields.
 - CTRL+Click on a slider or drag box to input value as text.
 - Use mouse wheel to scroll.
 - Text editor:
   - Hold SHIFT or use mouse to select text.
   - CTRL+Left/Right to word jump.
   - CTRL+Shift+Left/Right to select words.
   - CTRL+A our Double-Click to select all.
   - CTRL+X,CTRL+C,CTRL+V to use OS clipboard/
   - CTRL+Z,CTRL+Y to undo/redo.
   - ESCAPE to revert text to its original value.
   - You can apply arithmetic operators +,*,/ on numerical values. Use +- to subtract (because - would set a negative value!)
   - Controls are automatically adjusted for OSX to match standard OSX text editing operations.
 - General Keyboard controls: enable with HanaLovesMeConfigFlags_NavEnableKeyboard.
 - General Gamepad controls: enable with HanaLovesMeConfigFlags_NavEnableGamepad. See suggested mappings in HanaLovesMe.h HanaLovesMeNavInput_ + download PNG/PSD at http://goo.gl/9LgVZW


 PROGRAMMER GUIDE
 ================

 READ FIRST:

 - Read the FAQ below this section!
 - Your code creates the UI, if your code doesn't run the UI is gone! The UI can be highly dynamic, there are no construction
   or destruction steps, less superfluous data retention on your side, less state duplication, less state synchronization, less bugs.
 - Call and read HanaLovesMe::ShowDemoWindow() for demo code demonstrating most features.
 - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.
 - Dear HanaLovesMe is an implementation of the HanaLovesMe paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).
   You can learn about HanaLovesMe principles at http://www.johno.se/book/HanaLovesMe.html, http://mollyrocket.com/861 & more links docs/README.md.
 - Dear HanaLovesMe is a "single pass" rasterizing implementation of the HanaLovesMe paradigm, aimed at ease of use and high-performances.
   For every application frame your UI code will be called only once. This is in contrast to e.g. Unity's own implementation of an HanaLovesMe,
   where the UI code is called multiple times ("multiple passes") from a single entry point. There are pros and cons to both approaches.
 - Our origin are on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.
 - This codebase is also optimized to yield decent performances with typical "Debug" builds settings.
 - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).
   If you get an assert, read the messages and comments around the assert.
 - C++: this is a very C-ish codebase: we don't rely on C++11, we don't include any C++ headers, and HanaLovesMe:: is a namespace.
 - C++: vsize/xuifloatcolor do not expose math operators by default, because it is expected that you use your own math types.
   See FAQ "How can I use my own math types instead of vsize/xuifloatcolor?" for details about setting up imconfig.h for that.
   However, HanaLovesMe_internal.h can optionally export math operators for vsize/xuifloatcolor, which we use in this codebase.
 - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction (avoid using it in your code!).

 HOW TO UPDATE TO A NEWER VERSION OF DEAR HanaLovesMe:

 - Overwrite all the sources files except for imconfig.h (if you have made modification to your copy of imconfig.h)
 - Or maintain your own branch where you have imconfig.h modified.
 - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
   likely be a comment about it. Please report any issue to the GitHub page!
 - Try to keep your copy of dear HanaLovesMe reasonably up to date.

 GETTING STARTED WITH INTEGRATING DEAR HanaLovesMe IN YOUR CODE/ENGINE:

 - Run and study the examples and demo in HanaLovesMe_demo.cpp to get acquainted with the library.
 - Add the Dear HanaLovesMe source files to your projects or using your preferred build system.
   It is recommended you build and statically link the .cpp files as part of your project and not as shared library (DLL).
 - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating HanaLovesMe types with your own maths types.
 - When using Dear HanaLovesMe, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
 - Dear HanaLovesMe never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
   phases of your own application. All rendering informatioe are stored into command-lists that you will retrieve after calling HanaLovesMe::Render().
 - Refer to the bindings and demo applications in the examples/ folder for instruction on how to setup your code.
 - If you are running over a standard OS with a common graphics API, you should be able to use unmodified HanaLovesMe_impl_*** files from the examples/ folder.

 HOW A SIMPLE APPLICATION MAY LOOK LIKE:
 EXHIBIT 1: USING THE EXAMPLE BINDINGS (HanaLovesMe_impl_XXX.cpp files from the examples/ folder).

     // Application init: create a dear HanaLovesMe context, setup some options, load fonts
     HanaLovesMe::CreateContext();
     HanaLovesMeIO& io = HanaLovesMe::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= HanaLovesMeConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Initialize helper Platform and Renderer bindings (here we are using HanaLovesMe_impl_win32 and HanaLovesMe_impl_dx11)
     HanaLovesMe_ImplWin32_Init(hwnd);
     HanaLovesMe_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

     // Application main loop
     while (true)
     {
         // Feed inputs to dear HanaLovesMe, start new frame
         HanaLovesMe_ImplDX11_NewFrame();
         HanaLovesMe_ImplWin32_NewFrame();
         HanaLovesMe::NewFrame();

         // Any application code here
         HanaLovesMe::Text("Hello, world!");

         // Render dear HanaLovesMe into screen
         HanaLovesMe::Render();
         HanaLovesMe_ImplDX11_RenderDrawData(HanaLovesMe::GetDrawData());
         g_pSwapChain->Present(1, 0);
     }

     // Shutdown
     HanaLovesMe_ImplDX11_Shutdown();
     HanaLovesMe_ImplWin32_Shutdown();
     HanaLovesMe::DestroyContext();

 HOW A SIMPLE APPLICATION MAY LOOK LIKE:
 EXHIBIT 2: IMPLEMENTING CUSTOM BINDING / CUSTOM ENGINE.

     // Application init: create a dear HanaLovesMe context, setup some options, load fonts
     HanaLovesMe::CreateContext();
     HanaLovesMeIO& io = HanaLovesMe::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= HanaLovesMeConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Build and load the texture atlas into a texture
     // (In the examples/ app this is usually done within the HanaLovesMe_ImplXXX_Init() function from one of the demo Renderer)
     int width, height;
     unsigned char* pixels = NULL;
     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

     // At this point you've got the texture data and you need to upload that your your graphic system:
     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.
     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ below for details about ImTextureID.
     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
     io.Fonts->TexID = (void*)texture;

     // Application main loop
     while (true)
     {
        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
        // (In the examples/ app this is usually done within the HanaLovesMe_ImplXXX_NewFrame() function from one of the demo Platform bindings)
        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
        io.DisplaySize.x = 1920.0f;             // set the current display width
        io.DisplaySize.y = 1280.0f;             // set the current display height here
        io.MousePos = my_mouse_pos;             // set the mouse position
        io.MouseDown[0] = my_mouse_buttons[0];  // set the mouse button states
        io.MouseDown[1] = my_mouse_buttons[1];

        // Call NewFrame(), after this point you can use HanaLovesMe::* functions anytime
        // (So you want to try calling NewFrame() as early as you can in your mainloop to be able to use HanaLovesMe everywhere)
        HanaLovesMe::NewFrame();

        // Most of your application code here
        HanaLovesMe::Text("Hello, world!");
        MyGameUpdate(); // may use any HanaLovesMe functions, e.g. HanaLovesMe::Begin("My window"); HanaLovesMe::Text("Hello, world!"); HanaLovesMe::End();
        MyGameRender(); // may use any HanaLovesMe functions as well!

        // Render HanaLovesMe, swap buffers
        // (You want to try calling EndFrame/Render as late as you can, to be able to use HanaLovesMe in your own game rendering code)
        HanaLovesMe::EndFrame();
        HanaLovesMe::Render();
        ImDrawData* draw_data = HanaLovesMe::GetDrawData();
        MyHanaLovesMeRenderFunction(draw_data);
        SwapBuffers();
     }

     // Shutdown
     HanaLovesMe::DestroyContext();

 HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE:

    void void MyHanaLovesMeRenderFunction(ImDrawData* draw_data)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
       // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
       for (int n = 0; n < draw_data->CmdListsCount; n++)
       {
          const ImDrawList* cmd_list = draw_data->CmdLists[n];
          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by HanaLovesMe
          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by HanaLovesMe
          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
          {
             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
             if (pcmd->UserCallback)
             {
                 pcmd->UserCallback(cmd_list, pcmd);
             }
             else
             {
                 // The texture for the draw call is specified by pcmd->TextureId.
                 // The vast majority of draw calls will use the HanaLovesMe texture atlas, which value you have set yourself during initialization.
                 MyEngineBindTexture((MyTexture*)pcmd->TextureId);

                 // We are using scissoring to clip some objects. All low-level graphics API should supports it.
                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
                 //   (some elements visible outside their bounds) but you can fix that once everything else works!
                 // - Clipping coordinates are provided in HanaLovesMe coordinates space (from draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize)
                 //   In a single viewport application, draw_data->DisplayPos will always be (0,0) and draw_data->DisplaySize will always be == io.DisplaySize.
                 //   However, in the interest of supporting multi-viewport applications in the future (see 'viewport' branch on github),
                 //   always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
                 vsize pos = draw_data->DisplayPos;
                 MyEngineScissor((int)(pcmd->ClipRect.x - pos.x), (int)(pcmd->ClipRect.y - pos.y), (int)(pcmd->ClipRect.z - pos.x), (int)(pcmd->ClipRect.w - pos.y));

                 // Render 'pcmd->ElemCount/3' indexed triangles.
                 // By default the indices ImDrawIdx are 16-bits, you can change them to 32-bits in imconfig.h if your engine doesn't support 16-bits indices.
                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);
             }
             idx_buffer += pcmd->ElemCount;
          }
       }
    }

 - The examples/ folders contains many actual implementation of the pseudo-codes above.
 - When calling NewFrame(), the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags are updated.
   They tell you if Dear HanaLovesMe intends to use your inputs. When a flag is set you want to hide the corresponding inputs
   from the rest of your application. In every cases you need to pass on the inputs to HanaLovesMe. Refer to the FAQ for more information.
 - Please read the FAQ below!. Amusingly, it is called a FAQ because people frequently run into the same issues!

 USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS

 - The gamepad/keyboard navigation is fairly functional and keeps being improved.
 - Gamepad support is particularly useful to use dear HanaLovesMe on a console system (e.g. PS4, Switch, XB1) without a mouse!
 - You can ask questions and report issues at https://github.com/ocornut/HanaLovesMe/issues/787
 - The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable.
 - Gamepad:
    - Set io.ConfigFlags |= HanaLovesMeConfigFlags_NavEnableGamepad to enable.
    - Backend: Set io.BackendFlags |= HanaLovesMeBackendFlags_HasGamepad + fill the io.NavInputs[] fields before calling NewFrame().
      Note that io.NavInputs[] is cleared by EndFrame().
    - See 'enum HanaLovesMeNavInput_' in HanaLovesMe.h for a description of inputs. For each entry of io.NavInputs[], set the following values:
         0.0f= not held. 1.0f= fully held. Pass intermediate 0.0f..1.0f values for analog triggers/sticks.
    - We uses a simple >0.0f test for activation testing, and won't attempt to test for a dead-zone.
      Your code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 HanaLovesMe range, etc.).
    - You can download PNG/PSD files depicting the gamepad controls for common controllers at: http://goo.gl/9LgVZW.
    - If you need to share inputs between your game and the HanaLovesMe parts, the easiest approach is to go all-or-nothing, with a buttons combo
      to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.
 - Keyboard:
    - Set io.ConfigFlags |= HanaLovesMeConfigFlags_NavEnableKeyboard to enable.
      NewFrame() will automatically fill io.NavInputs[] based on your io.KeysDown[] + io.KeyMap[] arrays.
    - When keyboard navigation is active (io.NavActive + HanaLovesMeConfigFlags_NavEnableKeyboard), the io.WantCaptureKeyboard flag
      will be set. For more advanced uses, you may want to read from:
       - io.NavActive: true when a window is focused and it doesn't have the HanaLovesMeWindowFlags_NoNavInputs flag set.
       - io.NavVisible: true when the navigation cursor is visible (and usually goes false when mouse is used).
       - or query focus information with e.g. IsWindowFocused(HanaLovesMeFocusedFlags_AnyWindow), IsItemFocused() etc. functions.
      Please reach out if you think the game vs navigation input sharing could be improved.
 - Mouse:
    - PS4 users: Consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback.
    - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + uSynergy.c (on your console/tablet/phone app) to share your PC mouse/keyboard.
    - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the HanaLovesMeConfigFlags_NavEnableSetMousePos flag.
      Enabling HanaLovesMeConfigFlags_NavEnableSetMousePos + HanaLovesMeBackendFlags_HasSetMousePos instructs dear HanaLovesMe to move your mouse cursor along with navigation movements.
      When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
      When that happens your back-end NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the binding in examples/ do that.
      (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, HanaLovesMe will misbehave as it will see your mouse as moving back and forth!)
      (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
       to set a boolean to ignore your other external mouse positions until the external source is moved again.)


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
 Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
 When you are not sure about a old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all HanaLovesMe files.
 You can read releases logs https://github.com/ocornut/HanaLovesMe/releases for more details.

 - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList(). Kept redirection function (will obsolete).
 - 2019/02/26 (1.69) - renamed HanaLovesMeColorEditFlags_RGB/HanaLovesMeColorEditFlags_HSV/HanaLovesMeColorEditFlags_HEX to HanaLovesMeColorEditFlags_DisplayRGB/HanaLovesMeColorEditFlags_DisplayHSV/HanaLovesMeColorEditFlags_DisplayHex. Kept redirection enums (will obsolete).
 - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with a dummy small value!
 - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).
 - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead!
 - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Keep redirection typedef (will obsolete).
 - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string. This somehow half-worked before but had various undesirable side-effects.
 - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.
 - 2018/10/12 (1.66) - renamed misc/stl/HanaLovesMe_stl.* to misc/cpp/HanaLovesMe_stdlib.* in prevision for other C++ helper files.
 - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).
 - 2018/09/06 (1.65) - renamed stb_truetype.h to x07dns_truetype.h, stb_textedit.h to x07dns_textedit.h, and stb_rect_pack.h to x07dns_rectpack.h.
                       If you were conveniently using the HanaLovesMe copy of those STB headers in your project you will have to update your include paths.
 - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)
 - 2018/08/31 (1.64) - added HanaLovesMe_widgets.cpp file, extracted and moved widgets code out of HanaLovesMe.cpp into HanaLovesMe_widgets.cpp. Re-ordered some of the code remaining in HanaLovesMe.cpp.
                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.
                       Because of this, any local modifications to HanaLovesMe.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.
 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
 - 2018/08/21 (1.63) - renamed HanaLovesMeTextEditCallback to HanaLovesMeInputTextCallback, HanaLovesMeTextEditCallbackData to HanaLovesMeInputTextCallbackData for consistency. Kept redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed HanaLovesMeInputTextCallbackData::ReadOnly since it is a duplication of (HanaLovesMeInputTextCallbackData::Flags & HanaLovesMeInputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window HanaLovesMeWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed HanaLovesMe::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed HanaLovesMeCol_ModalWindowDarkening to HanaLovesMeCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
 - 2018/06/08 (1.62) - examples: the HanaLovesMe_impl_xxx files have been split to separate platform (Win32, Glfw, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).
                       old binding will still work as is, however prefer using the separated bindings as they will be updated to be multi-viewport conformant.
                       when adopting new bindings follow the main.cpp code of your preferred examples/ folder to know which functions to call.
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discouhnly using the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the HanaLovesMeTreeNodeFlags_CollapsingHeader helper now include the HanaLovesMeTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.
                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
                       If you have HanaLovesMe_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
                       consistent with other functions. Kept redirection functions (will obsolete).
 - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some binding ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed HanaLovesMeCol_CloseButton, HanaLovesMeCol_CloseButtonActive, HanaLovesMeCol_CloseButtonHovered as the closing cross uses regular button colors now.
 - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed HanaLovesMeStyleVar_Count_ to HanaLovesMeStyleVar_COUNT and HanaLovesMeMouseCursor_Count_ to HanaLovesMeMouseCursor_COUNT for consistency with other public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after HanaLovesMe::Render(). Use HanaLovesMe::GetDrawData() to retrieve the ImDrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
                       - YOU NOW NEED TO CALL HanaLovesMe::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL HanaLovesMe::DestroyContext() AT THE END.
                       - removed Shutdown() function, as DestroyContext() serve this purpose.
                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the HanaLovesMe repo you may need to update your paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(HanaLovesMeHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(HanaLovesMeFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/03 (1.60) - renamed HanaLovesMeSizeConstraintCallback to HanaLovesMeSizeCallback, HanaLovesMeSizeConstraintCallbackData to HanaLovesMeSizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
 - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
 - 2017/12/14 (1.53) - using the HanaLovesMeWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either HanaLovesMeWindowFlags_NoInputs or HanaLovesMeWindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(HanaLovesMeFocusedFlags_RootWindow). Kept redirection function (will obsolete).
                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(HanaLovesMeFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
 - 2017/12/12 (1.53) - renamed HanaLovesMeTreeNodeFlags_AllowOverlapMode to HanaLovesMeTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed HanaLovesMeTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed HanaLovesMeWindowFlags_ShowBorders window flag. Borders are now fully set up in the HanaLovesMeStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use HanaLovesMe::ShowStyleEditor() to look them up.
                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed HanaLovesMeCol_ComboBg in favor of combo boxes using HanaLovesMeCol_PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed HanaLovesMeCol_ChildWindowBg to HanaLovesMeCol_ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, HanaLovesMeStyleVar_ChildWindowRounding to HanaLovesMeStyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(HanaLovesMeHoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed HanaLovesMe_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/HanaLovesMe_DISABLE_WIN32_DEFAULT_IME_FUNCS to HanaLovesMe_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/HanaLovesMe_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/HanaLovesMe/issues/1382 for details.
                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Keep redirection typedef (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to vsize(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously vsize(-1,-1) was enough but we now accept negative mouse coordinates. In your binding if you need to support unavailable mouse, make sure to replace "io.MousePos = vsize(-1,-1)" with "io.MousePos = vsize(-FLT_MAX,-FLT_MAX)".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(HanaLovesMeHoveredFlags_RectOnly)!
                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(HanaLovesMeCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using xuicolor() with implicit cast. Cast to ImU32 or xuifloatcolor explicily to fix.
 - 2017/08/15 (1.51) - marked the weird HanaLovesMe_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit HanaLovesMeOnceUponAFrame.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
 - 2017/08/13 (1.51) - renamed HanaLovesMeCol_Columns*** to HanaLovesMeCol_Separator***. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed HanaLovesMeSetCond_*** types and flags to HanaLovesMeCond_***. Kept redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and HanaLovesMeColorEditMode in favor of HanaLovesMeColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], HanaLovesMeColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
                     - changed prototype of rarely used 'ColorButton(xuifloatcolor col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, xuifloatcolor col, HanaLovesMeColorEditFlags flags = 0, vsize size = vsize(0,0))'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(vsize), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetId() and use it instead of passing string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a vsize (HanaLovesMeAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using HanaLovesMeCol_TitleBg/HanaLovesMeCol_TitleBgActive colors) isn't rendered over a window background (HanaLovesMeCol_WindowBg color) anymore.
                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you.
                       If your TitleBg/TitleBgActive alpha was <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color.
                           xuifloatcolor ConvertTitleBgCol(const xuifloatcolor& win_bg_col, const xuifloatcolor& title_bg_col)
                           {
                               float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a;
                               return xuifloatcolor((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a);
                           }
                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, HanaLovesMeTreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(xuifloatcolor rect) to ImDrawList::PushClipRect(vsize min,vsize max,bool intersect_with_current_clip_rect=false). Note that higher-level HanaLovesMe::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[HanaLovesMeCol_WindowBg] and all other Bg color values. (ref github issue #337).
 - 2016/04/03 (1.48) - renamed HanaLovesMeCol_TooltipBg to HanaLovesMeCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using HanaLovesMeCol_WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split HanaLovesMe.cpp into extra files: HanaLovesMe_demo.cpp HanaLovesMe_draw.cpp HanaLovesMe_internal.h that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
                     - if you are using a vanilla copy of one of the HanaLovesMe_impl_XXXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
                     - the signature of the io.RenderDrawListsFn handler has changed!
                       old: HanaLovesMe_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
                       new: HanaLovesMe_XXXX_RenderDrawLists(ImDrawData* draw_data).
                         parameters: 'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely be used. Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. HanaLovesMe needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
 - 2015/04/03 (1.38) - removed HanaLovesMeCol_CheckHovered, HanaLovesMeCol_CheckActive, replaced with the more general HanaLovesMeCol_FrameBgHovered, HanaLovesMeCol_FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, HanaLovesMeStyleVar_TreeNodeSpacing to HanaLovesMeStyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, HanaLovesMeSetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed HanaLovesMeSetCondition_*** to HanaLovesMeSetCond_***, and _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback HanaLovesMeTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed HanaLovesMeStohnly::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer stohnly functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
              (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
                       font init:  { const void* png_data; unsigned int png_size; HanaLovesMe::GetDefaultFontData(NULL, NULL, &png_data, &png_size); <..Upload texture to GPU..>; }
                       became:     { unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); <..Upload texture to GPU>; io.Fonts->TexId = YourTextureIdentifier; }
                       you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs.
                       it is now recommended that you sample the font texture with bilinear interpolation.
              (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to set io.Fonts->TexID.
              (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
              (1.30) - removed HanaLovesMe::IsItemFocused() in favor of HanaLovesMe::IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, HanaLovesMeSetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of HanaLovesMe_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed HanaLovesMe_INCLUDE_HanaLovesMe_USER_CPP to HanaLovesMe_INCLUDE_HanaLovesMe_USER_INL and HanaLovesMe_user.cpp to HanaLovesMe_user.inl (more IDE friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved HanaLovesMe_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes


 FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
 ======================================

 Q: Where is the documentation?
 A: This library is poorly documented at the moment and expects of the user to be acquainted with C/C++.
    - Run the examples/ and explore them.
    - See demo code in HanaLovesMe_demo.cpp and particularly the HanaLovesMe::ShowDemoWindow() function.
    - The demo covers most features of Dear HanaLovesMe, so you can read the code and see its output.
    - See documentation and comments at the top of HanaLovesMe.cpp + effectively HanaLovesMe.h.
    - Dozens of standalone example applications using e.g. OpenGL/DirectX are provided in the examples/
      folder to explain how to integrate Dear HanaLovesMe with your own engine/application.
    - Your programming IDE is your friend, find the type or function declaration to find comments
      associated to it.

 Q: Which version should I get?
 A: I occasionally tag Releases (https://github.com/ocornut/HanaLovesMe/releases) but it is generally safe
    and recommended to sync to master/latest. The library is fairly stable and regressions tend to be
    fixed fast when reported. You may also peak at the 'docking' branch which includes:
    - Docking/Merging features (https://github.com/ocornut/HanaLovesMe/issues/2109)
    - Multi-viewport features (https://github.com/ocornut/HanaLovesMe/issues/1542)
    Many projects are using this branch and it is kept in sync with master regularly.

 Q: Who uses Dear HanaLovesMe?
 A: See "Quotes" (https://github.com/ocornut/HanaLovesMe/wiki/Quotes) and
    "Software using Dear HanaLovesMe" (https://github.com/ocornut/HanaLovesMe/wiki/Software-using-dear-HanaLovesMe) Wiki pages
    for a list of games/software which are publicly known to use dear HanaLovesMe. Please add yours if you can!

 Q: Why the odd dual naming, "Dear HanaLovesMe" vs "HanaLovesMe"?
 A: The library started its life as "HanaLovesMe" due to the fact that I didn't give it a proper name when
    when I released 1.0, and had no particular expectation that it would take off. However, the term HanaLovesMe
    (immediate-mode graphical user interface) was coined before and is being used in variety of other
    situations (e.g. Unity uses it own implementation of the HanaLovesMe paradigm).
    To reduce the ambiguity without affecting existing code bases, I have decided on an alternate,
    longer name "Dear HanaLovesMe" that people can use to refer to this specific library.
    Please try to refer to this library as "Dear HanaLovesMe".

 Q: How can I tell whether to dispatch mouse/keyboard to HanaLovesMe or to my application?
 A: You can read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags from the HanaLovesMeIO structure (e.g. if (HanaLovesMe::GetIO().WantCaptureMouse) { ... } )
    - When 'io.WantCaptureMouse' is set, HanaLovesMe wants to use your mouse state, and you may want to discard/hide the inputs from the rest of your application.
    - When 'io.WantCaptureKeyboard' is set, HanaLovesMe wants to use your keyboard state, and you may want to discard/hide the inputs from the rest of your application.
    - When 'io.WantTextInput' is set to may want to notify your OS to popup an on-screen keyboard, if available (e.g. on a mobile phone, or console OS).
    Note: you should always pass your mouse/keyboard inputs to HanaLovesMe, even when the io.WantCaptureXXX flag are set false.
     This is because HanaLovesMe needs to detect that you clicked in the void to unfocus its own windows.
    Note: The 'io.WantCaptureMouse' is more accurate that any attempt to "check if the mouse is hovering a window" (don't do that!).
     It handle mouse dragging correctly (both dragging that started over your application or over an HanaLovesMe window) and handle e.g. modal windows blocking inputs.
     Those flags are updated by HanaLovesMe::NewFrame(). Preferably read the flags after calling NewFrame() if you can afford it, but reading them before is also
     perfectly fine, as the bool toggle fairly rarely. If you have on a touch device, you might find use for an early call to UpdateHoveredWindowAndCaptureFlags().
    Note: Text input widget releases focus on "Return KeyDown", so the subsequent "Return KeyUp" event that your application receive will typically
     have 'io.WantCaptureKeyboard=false'. Depending on your application logic it may or not be inconvenient. You might want to track which key-downs
     were targeted for Dear HanaLovesMe, e.g. with an array of bool, and filter out the corresponding key-ups.)

 Q: How can I display an image? What is ImTextureID, how does it works?
 A: Short explanation:
    - You may use functions such as HanaLovesMe::Image(), HanaLovesMe::ImageButton() or lower-level ImDrawList::AddImage() to emit draw calls that will use your own textures.
    - Actual textures are identified in a way that is up to the user/engine. Those identifiers are stored and passed as ImTextureID (void*) value.
    - Loading image files from the disk and turning them into a texture is not within the scope of Dear HanaLovesMe (for a good reason).
      Please read documentations or tutorials on your graphics API to understand how to display textures on the screen before moving onward.

    Long explanation:
    - Dear HanaLovesMe's job is to create "meshes", defined in a renderer-agnostic format made of draw commands and vertices.
      At the end of the frame those meshes (ImDrawList) will be displayed by your rendering function. They are made up of textured polygons and the code
      to render them is generally fairly short (a few dozen lines). In the examples/ folder we provide functions for popular graphics API (OpenGL, DirectX, etc.).
    - Each rendering function decides on a data type to represent "textures". The concept of what is a "texture" is entirely tied to your underlying engine/graphics API.
      We carry the information to identify a "texture" in the ImTextureID type.
      ImTextureID is nothing more that a void*, aka 4/8 bytes worth of data: just enough to store 1 pointer or 1 integer of your choice.
      Dear HanaLovesMe doesn't know or understand what you are storing in ImTextureID, it merely pass ImTextureID values until they reach your rendering function.
    - In the examples/ bindings, for each graphics API binding we decided on a type that is likely to be a good representation for specifying
      an image from the end-user perspective. This is what the _examples_ rendering functions are using:

         OpenGL:     ImTextureID = GLuint                       (see HanaLovesMe_ImplGlfwGL3_RenderDrawData() function in HanaLovesMe_impl_glfw_gl3.cpp)
         DirectX9:   ImTextureID = LPDIRECT3DTEXTURE9           (see HanaLovesMe_ImplDX9_RenderDrawData()     function in HanaLovesMe_impl_dx9.cpp)
         DirectX11:  ImTextureID = ID3D11ShaderResourceView*    (see HanaLovesMe_ImplDX11_RenderDrawData()    function in HanaLovesMe_impl_dx11.cpp)
         DirectX12:  ImTextureID = D3D12_GPU_DESCRIPTOR_HANDLE  (see HanaLovesMe_ImplDX12_RenderDrawData()    function in HanaLovesMe_impl_dx12.cpp)

      For example, in the OpenGL example binding we store raw OpenGL texture identifier (GLuint) inside ImTextureID.
      Whereas in the DirectX11 example binding we store a pointer to ID3D11ShaderResourceView inside ImTextureID, which is a higher-level structure
      tying together both the texture and information about its format and how to read it.
    - If you have a custom engine built over e.g. OpenGL, instead of passing GLuint around you may decide to use a high-level data type to carry information about
      the texture as well as how to display it (shaders, etc.). The decision of what to use as ImTextureID can always be made better knowing how your codebase
      is designed. If your engine has high-level data types for "textures" and "material" then you may want to use them.
      If you are starting with OpenGL or DirectX or Vulkan and haven't built much of a rendering engine over them, keeping the default ImTextureID
      representation suggested by the example bindings is probably the best choice.
      (Advanced users may also decide to keep a low-level type in ImTextureID, and use ImDrawList callback and pass information to their renderer)

    User code may do:

        // Cast our texture type to ImTextureID / void*
        MyTexture* texture = g_CoffeeTableTexture;
        HanaLovesMe::Image((void*)texture, vsize(texture->Width, texture->Height));

    The renderer function called after HanaLovesMe::Render() will receive that same value that the user code passed:

        // Cast ImTextureID / void* stored in the draw command as our texture type
        MyTexture* texture = (MyTexture*)pcmd->TextureId;
        MyEngineBindTexture2D(texture);

    Once you understand this design you will understand that loading image files and turning them into displayable textures is not within the scope of Dear HanaLovesMe.
    This is by design and is actually a good thing, because it means your code has full control over your data types and how you display them.
    If you want to display an image file (e.g. PNG file) into the screen, please refer to documentation and tutorials for the graphics API you are using.

    Here's a simplified OpenGL example using stb_image.h:

        // Use stb_image.h to load a PNG from disk and turn it into raw RGBA pixel data:
        #define STB_IMAGE_IMPLEMENTATION
        #include <stb_image.h>
        [...]
        int my_image_width, my_image_height;
        unsigned char* my_image_data = stbi_load("my_image.png", &my_image_width, &my_image_height, NULL, 4);

        // Turn the RGBA pixel data into an OpenGL texture:
        GLuint my_opengl_texture;
        glGenTextures(1, &my_opengl_texture);
        glBindTexture(GL_TEXTURE_2D, my_opengl_texture);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image_width, image_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, image_data);

        // Now that we have an OpenGL texture, assuming our HanaLovesMe rendering function (HanaLovesMe_impl_xxx.cpp file) takes GLuint as ImTextureID, we can display it:
        HanaLovesMe::Image((void*)(intptr_t)my_opengl_texture, vsize(my_image_width, my_image_height));

    C/C++ tip: a void* is pointer-sized stohnly. You may safely store any pointer or integer into it by casting your value to ImTextureID / void*, and vice-versa.
    Because both end-points (user code and rendering function) are under your control, you know exactly what is stored inside the ImTextureID / void*.
    Examples:

        GLuint my_tex = XXX;
        void* my_void_ptr;
        my_void_ptr = (void*)(intptr_t)my_tex;                  // cast a GLuint into a void* (we don't take its address! we literally store the value inside the pointer)
        my_tex = (GLuint)(intptr_t)my_void_ptr;                 // cast a void* into a GLuint

        ID3D11ShaderResourceView* my_dx11_srv = XXX;
        void* my_void_ptr;
        my_void_ptr = (void*)my_dx11_srv;                       // cast a ID3D11ShaderResourceView* into an opaque void*
        my_dx11_srv = (ID3D11ShaderResourceView*)my_void_ptr;   // cast a void* into a ID3D11ShaderResourceView*

    Finally, you may call HanaLovesMe::ShowMetricsWindow() to explore/visualize/understand how the ImDrawList are generated.

 Q: Why are multiple widgets reacting when I interact with a single one?
 Q: How can I have multiple widgets with the same label or with an empty label?
 A: A primer on labels and the ID Stack...

    Dear HanaLovesMe internally need to uniquely identify UI elements.
    Elements that are typically not clickable (such as calls to the Text functions) don't need an ID.
    Interactive widgets (such as calls to Button buttons) need a unique ID.
    Unique ID are used internally to track active widgets and occasionally associate state to widgets.
    Unique ID are implicitly built from the hash of multiple elements that identify the "path" to the UI element.

   - Unique ID are often derived from a string label:

       Button("OK");          // Label = "OK",     ID = hash of (..., "OK")
       Button("Cancel");      // Label = "Cancel", ID = hash of (..., "Cancel")

   - ID are uniquely scoped within windows, tree nodes, etc. which all pushes to the ID stack. Having
     two buttons labeled "OK" in different windows or different tree locations is fine.
     We used "..." above to signify whatever was already pushed to the ID stack previously:

       Begin("MyWindow");
       Button("OK");          // Label = "OK",     ID = hash of ("MyWindow", "OK")
       End();
       Begin("MyOtherWindow");
       Button("OK");          // Label = "OK",     ID = hash of ("MyOtherWindow", "OK")
       End();

   - If you have a same ID twice in the same location, you'll have a conflict:

       Button("OK");
       Button("OK");          // ID collision! Interacting with either button will trigger the first one.

     Fear not! this is easy to solve and there are many ways to solve it!

   - Solving ID conflict in a simple/local context:
     When passing a label you can optionally specify extra ID information within string itself.
     Use "##" to pass a complement to the ID that won't be visible to the end-user.
     This helps solving the simple collision cases when you know e.g. at compilation time which items
     are going to be created:

       Begin("MyWindow");
       Button("Play");        // Label = "Play",   ID = hash of ("MyWindow", "Play")
       Button("Play##foo1");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo1")  // Different from above
       Button("Play##foo2");  // Label = "Play",   ID = hash of ("MyWindow", "Play##foo2")  // Different from above
       End();

   - If you want to completely hide the label, but still need an ID:

       Checkbox("##On", &b);  // Label = "",       ID = hash of (..., "##On")   // No visible label, just a checkbox!

   - Occasionally/rarely you might want change a label while preserving a constant ID. This allows
     you to animate labels. For example you may want to include varying information in a window title bar,
     but windows are uniquely identified by their ID. Use "###" to pass a label that isn't part of ID:

       Button("Hello###ID");  // Label = "Hello",  ID = hash of (..., "###ID")
       Button("World###ID");  // Label = "World",  ID = hash of (..., "###ID")  // Same as above, even though the label looks different

       sprintf(buf, "My game (%f FPS)###MyGame", fps);
       Begin(buf);            // Variable title,   ID = hash of "MyGame"

   - Solving ID conflict in a more general manner:
     Use PushID() / PopID() to create scopes and manipulate the ID stack, as to avoid ID conflicts
     within the same window. This is the most convenient way of distinguishing ID when iterating and
     creating many UI elements programmatically.
     You can push a pointer, a string or an integer value into the ID stack.
     Remember that ID are formed from the concatenation of _everything_ pushed into the ID stack.
     At each level of the stack we store the seed used for items at this level of the ID stack.

     Begin("Window");
       for (int i = 0; i < 100; i++)
       {
         PushID(i);           // Push i to the id tack
         Button("Click");     // Label = "Click",  ID = hash of ("Window", i, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj);
         Button("Click");     // Label = "Click",  ID = hash of ("Window", obj pointer, "Click")
         PopID();
       }
       for (int i = 0; i < 100; i++)
       {
         MyObject* obj = Objects[i];
         PushID(obj->Name);
         Button("Click");     // Label = "Click",  ID = hash of ("Window", obj->Name, "Click")
         PopID();
       }
       End();

   - You can stack multiple prefixes into the ID stack:

       Button("Click");       // Label = "Click",  ID = hash of (..., "Click")
       PushID("node");
       Button("Click");       // Label = "Click",  ID = hash of (..., "node", "Click")
         PushID(my_ptr);
           Button("Click");   // Label = "Click",  ID = hash of (..., "node", my_ptr, "Click")
         PopID();
       PopID();

   - Tree nodes implicitly creates a scope for you by calling PushID().

       Button("Click");       // Label = "Click",  ID = hash of (..., "Click")
       if (TreeNode("node"))  // <-- this function call will do a PushID() for you (unless instructed not to, with a special flag)
       {
         Button("Click");     // Label = "Click",  ID = hash of (..., "node", "Click")
         TreePop();
       }

   - When working with trees, ID are used to preserve the open/close state of each tree node.
     Depending on your use cases you may want to use strings, indices or pointers as ID.
      e.g. when following a single pointer that may change over time, using a static string as ID
       will preserve your node open/closed state when the targeted object change.
      e.g. when displaying a list of objects, using indices or pointers as ID will preserve the
       node open/closed state differently. See what makes more sense in your situation!

 Q: How can I use my own math types instead of vsize/xuifloatcolor?
 A: You can edit imconfig.h and setup the IM_VEC2_CLASS_EXTRA/IM_VEC4_CLASS_EXTRA macros to add implicit type conversions.
    This way you'll be able to use your own types everywhere, e.g. passing glm::vec2 to HanaLovesMe functions instead of vsize.

 Q: How can I load a different font than the default?
 A: Use the font atlas to load the TTF/OTF file you want:
      HanaLovesMeIO& io = HanaLovesMe::GetIO();
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
    Default is ProggyClean.ttf, monospace, rendered at size 13, embedded in dear HanaLovesMe's source code.
    (Tip: monospace fonts are convenient because they allow to facilitate horizontal alignment directly at the string level.)
    (Read the 'misc/fonts/README.txt' file for more details about font loading.)

    New programmers: remember that in C/C++ and most programming languages if you want to use a
    backslash \ within a string literal, you need to write it double backslash "\\":
      io.Fonts->AddFontFromFileTTF("MyDataFolder\MyFontFile.ttf", size_in_pixels);   // WRONG (you are escape the M here!)
      io.Fonts->AddFontFromFileTTF("MyDataFolder\\MyFontFile.ttf", size_in_pixels);  // CORRECT
      io.Fonts->AddFontFromFileTTF("MyDataFolder/MyFontFile.ttf", size_in_pixels);   // ALSO CORRECT

 Q: How can I easily use icons in my application?
 A: The most convenient and practical way is to merge an icon font such as FontAwesome inside you
    main font. Then you can refer to icons within your strings.
    You may want to see ImFontConfig::GlyphMinAdvanceX to make your icon look monospace to facilitate alignment.
    (Read the 'misc/fonts/README.txt' file for more details about icons font loading.)

 Q: How can I load multiple fonts?
 A: Use the font atlas to pack them into a single texture:
    (Read the 'misc/fonts/README.txt' file and the code in ImFontAtlas for more details.)

      HanaLovesMeIO& io = HanaLovesMe::GetIO();
      ImFont* font0 = io.Fonts->AddFontDefault();
      ImFont* font1 = io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
      ImFont* font2 = io.Fonts->AddFontFromFileTTF("myfontfile2.ttf", size_in_pixels);
      io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
      // the first loaded font gets used by default
      // use HanaLovesMe::PushFont()/HanaLovesMe::PopFont() to change the font at runtime

      // Options
      ImFontConfig config;
      config.OversampleH = 2;
      config.OversampleV = 1;
      config.GlyphOffset.y -= 1.0f;      // Move everything by 1 pixels up
      config.GlyphExtraSpacing.x = 1.0f; // Increase spacing between characters
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_pixels, &config);

      // Combine multiple fonts into one (e.g. for icon fonts)
      static ImWchar ranges[] = { 0xf000, 0xf3ff, 0 };
      ImFontConfig config;
      config.MergeMode = true;
      io.Fonts->AddFontDefault();
      io.Fonts->AddFontFromFileTTF("fontawesome-webfont.ttf", 16.0f, &config, ranges); // Merge icon font
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_pixels, NULL, &config, io.Fonts->GetGlyphRangesJapanese()); // Merge japanese glyphs

 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
 A: When loading a font, pass custom Unicode ranges to specify the glyphs to load.

      // Add default Japanese ranges
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, io.Fonts->GetGlyphRangesJapanese());

      // Or create your own custom ranges (e.g. for a game you can feed your entire game script and only build the characters the game need)
      ImVector<ImWchar> ranges;
      ImFontGlyphRangesBuilder builder;
      builder.AddText("Hello world");                        // Add a string (here "Hello world" contains 7 unique characters)
      builder.AddChar(0x7262);                               // Add a specific character
      builder.AddRanges(io.Fonts->GetGlyphRangesJapanese()); // Add one of the default ranges
      builder.BuildRanges(&ranges);                          // Build the final result (ordered ranges with all the unique characters submitted)
      io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, ranges.Data);

    All your strings needs to use UTF-8 encoding. In C++11 you can encode a string literal in UTF-8
    by using the u8"hello" syntax. Specifying literal in your source code using a local code page
    (such as CP-923 for Japanese or CP-1251 for Cyrillic) will NOT work!
    Otherwise you can convert yourself to UTF-8 or load text data from file already saved as UTF-8.

    Text input: it is up to your application to pass the right character code by calling io.AddInputCharacter().
    The applications in examples/ are doing that.
    Windows: you can use the WM_CHAR or WM_UNICHAR or WM_IME_CHAR message (depending if your app is built using Unicode or MultiByte mode).
    You may also use MultiByteToWideChar() or ToUnicode() to retrieve Unicode codepoints from MultiByte characters or keyboard state.
    Windows: if your language is relying on an Input Method Editor (IME), you copy the HWND of your window to io.ImeWindowHandle in order for
    the default implementation of io.ImeSetInputScreenPosFn() to set your Microsoft IME position correctly.

 Q: How can I interact with standard C++ types (such as std::string and std::vector)?
 A: - Being highly portable (bindings for several languages, frameworks, programming style, obscure or older platforms/compilers),
      and aiming for compatibility & performance suitable for every modern real-time game engines, dear HanaLovesMe does not use
      any of std C++ types. We use raw types (e.g. char* instead of std::string) because they adapt to more use cases.
    - To use HanaLovesMe::InputText() with a std::string or any resizable string class, see misc/cpp/HanaLovesMe_stdlib.h.
    - To use combo boxes and list boxes with std::vector or any other data structure: the BeginCombo()/EndCombo() API
      lets you iterate and submit items yourself, so does the ListBoxHeader()/ListBoxFooter() API.
      Prefer using them over the old and awkward Combo()/ListBox() api.
    - Generally for most high-level types you should be able to access the underlying data type.
      You may write your own one-liner wrappers to facilitate user code (tip: add new functions in HanaLovesMe:: namespace from your code).
    - Dear HanaLovesMe applications often need to make intensive use of strings. It is expected that many of the strings you will pass
      to the API are raw literals (free in C/C++) or allocated in a manner that won't incur a large cost on your application.
      Please bear in mind that using std::string on applications with large amount of UI may incur unsatisfactory performances.
      Modern implementations of std::string often include small-string optimization (which is often a local buffer) but those
      are not configurable and not the same across implementations.
    - If you are finding your UI traversal cost to be too large, make sure your string usage is not leading to excessive amount
      of heap allocations. Consider using literals, statically sized buffers and your own helper functions. A common pattern
      is that you will need to build lots of strings on the fly, and their maximum length can be easily be scoped ahead.
      One possible implementation of a helper to facilitate printf-style building of strings: https://github.com/ocornut/Str
      This is a small helper where you can instance strings with configurable local buffers length. Many game engines will
      provide similar or better string helpers.

 Q: How can I use the drawing facilities without an HanaLovesMe window? (using ImDrawList API)
 A: - You can create a dummy window. Call Begin() with the NoBackground | NoDecoration | NoSavedSettings | NoInputs flags.
      (The HanaLovesMeWindowFlags_NoDecoration flag itself is a shortcut for NoTitleBar | NoResize | NoScrollbar | NoCollapse)
      Then you can retrieve the ImDrawList* via GetWindowDrawList() and draw to it in any way you like.
    - You can call HanaLovesMe::GetBackgroundDrawList() or HanaLovesMe::GetForegroundDrawList() and use those draw list to display
      contents behind or over every other HanaLovesMe windows (one bg/fg drawlist per viewport).
    - You can create your own ImDrawList instance. You'll need to initialize them HanaLovesMe::GetDrawListSharedData(), or create
      your own ImDrawListSharedData, and then call your rendered code with your own ImDrawList or ImDrawData data.

 Q: How can I use this without a mouse, without a keyboard or without a screen? (gamepad, input share, remote display)
 A: - You can control Dear HanaLovesMe with a gamepad. Read about navigation in "Using gamepad/keyboard navigation controls".
      (short version: map gamepad inputs into the io.NavInputs[] array + set io.ConfigFlags |= HanaLovesMeConfigFlags_NavEnableGamepad)
    - You can share your computer mouse seamlessly with your console/tablet/phone using Synergy (https://symless.com/synergy)
      This is the preferred solution for developer productivity.
      In particular, the "micro-synergy-client" repository (https://github.com/symless/micro-synergy-client) has simple
      and portable source code (uSynergy.c/.h) for a small embeddable client that you can use on any platform to connect
      to your host computer, based on the Synergy 1.x protocol. Make sure you download the Synergy 1 server on your computer.
      Console SDK also sometimes provide equivalent tooling or wrapper for Synergy-like protocols.
    - You may also use a third party solution such as Remote HanaLovesMe (https://github.com/JordiRos/remoteHanaLovesMe) which sends
      the vertices to render over the local network, allowing you to use Dear HanaLovesMe even on a screen-less machine.
    - For touch inputs, you can increase the hit box of widgets (via the style.TouchPadding setting) to accommodate
      for the lack of precision of touch inputs, but it is recommended you use a mouse or gamepad to allow optimizing
      for screen real-estate and precision.

 Q: I integrated Dear HanaLovesMe in my engine and the text or lines are blurry..
 A: In your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f).
    Also make sure your orthographic projection matrix and io.DisplaySize matches your actual framebuffer dimension.

 Q: I integrated Dear HanaLovesMe in my engine and some elements are clipping or disappearing when I move windows around..
 A: You are probably mishandling the clipping rectangles in your render function.
    Rectangles provided by HanaLovesMe are defined as (x1=left,y1=top,x2=right,y2=bottom) and NOT as (x1,y1,width,height).

 Q: How can I help?
 A: - If you are experienced with Dear HanaLovesMe and C++, look at the github issues, look at the Wiki, read docs/TODO.txt
      and see how you want to help and can help!
    - Businesses: convince your company to fund development via support contracts/sponsoring! This is among the most useful thing you can do for dear HanaLovesMe.
    - Individuals: you can also become a Patron (http://www.patreon.com/HanaLovesMe) or donate on PayPal! See README.
    - Disclose your usage of dear HanaLovesMe via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
      You may post screenshot or links in the gallery threads (github.com/ocornut/HanaLovesMe/issues/1902). Visuals are ideal as they inspire other programmers.
      But even without visuals, disclosing your use of dear HanaLovesMe help the library grow credibility, and help other teams and programmers with taking decisions.
    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on github or privately).

 - tip: you can call Begin() multiple times with the same name during the same frame, it will keep appending to the same window.
        this is also useful to set yourself in the context of another window (to get/set other settings)
 - tip: you can create widgets without a Begin()/End() block, they will go in an implicit window called "Debug".
 - tip: the HanaLovesMeOnceUponAFrame helper will allow run the block of code only once a frame. You can use it to quickly add custom UI in the middle
        of a deep nested inner loop in your code.
 - tip: you can call Render() multiple times (e.g for VR renders).
 - tip: call and read the ShowDemoWindow() code in HanaLovesMe_demo.cpp for more example of how to use HanaLovesMe!

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "HanaLovesMe.h"
#ifndef HanaLovesMe_DEFINE_MATH_OPERATORS
#define HanaLovesMe_DEFINE_MATH_OPERATORS
#endif
#include "HanaLovesMe_internal.h"

#include <ctype.h>      // toupper
#include <stdio.h>      // vsnprintf, sscanf, printf
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

// Debug options
#define HanaLovesMe_DEBUG_NAV_SCORING     0   // Display navigation scoring preview when hovering items. Display last moving direction matches when holding CTRL
#define HanaLovesMe_DEBUG_NAV_RECTS       0   // Display the reference navigation rectangle for each window

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127)     // condition expression is constant
#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang/GCC warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wunknown-pragmas"        // warning : unknown warning group '-Wformat-pedantic *'        // not all warnings are known by all clang versions.. so ignoring warnings triggers new warnings on some configuration. great!
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wexit-time-destructors"  // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. HanaLovesMe coding style welcomes static/globals.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference is.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#pragma clang diagnostic ignored "-Wformat-pedantic"        // warning : format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast"       // warning : cast to 'void *' from smaller integer type 'int'
#if __has_warning("-Wzero-as-null-pointer-constant")
#pragma clang diagnostic ignored "-Wzero-as-null-pointer-constant"  // warning : zero as null pointer constant              // some standard header variations use #define NULL 0
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"      // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'HanaLovesMeWindow*'
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wstrict-overflow"          // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false
#if __GNUC__ >= 8
#pragma GCC diagnostic ignored "-Wclass-memaccess"          // warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead
#endif
#endif

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
static const float NAV_WINDOWING_HIGHLIGHT_DELAY = 0.20f;    // Time before the highlight and screen dimming starts fading in
static const float NAV_WINDOWING_LIST_APPEAR_DELAY = 0.15f;    // Time before the window list starts to appear

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and HanaLovesMeBackendFlags_HasMouseCursors is set in io.BackendFlags by back-end)
static const float WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS = 4.0f;     // Extend outside and inside windows. Affect FindHoveredWindow().
static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    // Reduce visual noise by only highlighting the border after a certain time.

//-------------------------------------------------------------------------
// [SECTION] FORWARD DECLARATIONS
//-------------------------------------------------------------------------

static void             SetCurrentWindow(HanaLovesMeWindow* window);
static void             FindHoveredWindow();
static HanaLovesMeWindow* CreateNewWindow(const char* name, vsize size, HanaLovesMeWindowFlags flags);
static void             CheckStacksSize(HanaLovesMeWindow* window, bool write);
static vsize           CalcNextScrollFromScrollTargetAndClamp(HanaLovesMeWindow* window, bool snap_on_edges);

static void             AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list);
static void             AddWindowToSortBuffer(ImVector<HanaLovesMeWindow*>* out_sorted_windows, HanaLovesMeWindow* window);

static vsrect           GetViewportRect();

// Settings
static void* SettingsHandlerWindow_ReadOpen(HanaLovesMeContext*, HanaLovesMeSettingsHandler*, const char* name);
static void             SettingsHandlerWindow_ReadLine(HanaLovesMeContext*, HanaLovesMeSettingsHandler*, void* entry, const char* line);
static void             SettingsHandlerWindow_WriteAll(HanaLovesMeContext* HanaLovesMe_ctx, HanaLovesMeSettingsHandler* handler, HanaLovesMeTextBuffer* buf);

// Platform Dependents default implementation for IO functions
static const char* GetClipboardTextFn_DefaultImpl(void* user_data);
static void             SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);
static void             ImeSetInputScreenPosFn_DefaultImpl(int x, int y);

namespace HanaLovesMe
{
	static bool             BeginShadowEx(const char* name, HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags flags);
	static bool             BeginGroupBoxEx(const char* name, HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags flags);
	static bool             BeginGroupBoxEx2(const char* name, HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags flags);
	static bool             BeginGroupBoxScrollEx(const char* name, const char* groupboxName, HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags flags);
    static bool             BeginChildEx(const char* name, HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags flags);
	static bool             BeginTabsEx(const char* name, HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags flags);
	static bool             EndBorderEx(const char* name, HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags flags);

    // Navigation
    static void             NavUpdate();
    static void             NavUpdateWindowing();
    static void             NavUpdateWindowingList();
    static void             NavUpdateMoveResult();
    static float            NavUpdatePageUpPageDown(int allowed_dir_flags);
    static inline void      NavUpdateAnyRequestFlag();
    static void             NavProcessItem(HanaLovesMeWindow* window, const vsrect& nav_bb, HanaLovesMeID id);
    static vsize           NavCalcPreferredRefPos();
    static void             NavSaveLastChildNavWindowIntoParent(HanaLovesMeWindow* nav_window);
    static HanaLovesMeWindow* NavRestoreLastChildNavWindow(HanaLovesMeWindow* window);

    // Misc
    static void             UpdateMouseInputs();
    static void             UpdateMouseWheel();
    static void             UpdateManualResize(HanaLovesMeWindow* window, const vsize& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4]);
    static void             RenderOuterBorders(HanaLovesMeWindow* window);

}

//-----------------------------------------------------------------------------
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
//-----------------------------------------------------------------------------

// Current context pointer. Implicitly used by all Dear HanaLovesMe functions. Always assumed to be != NULL.
// HanaLovesMe::CreateContext() will automatically set this pointer if it is NULL. Change to a different context by calling HanaLovesMe::SetCurrentContext().
// 1) Important: globals are not shared across DLL boundaries! If you use DLLs or any form of hot-reloading: you will need to call
//    SetCurrentContext() (with the pointer you got from CreateContext) from each unique static/DLL boundary, and after each hot-reloading.
//    In your debugger, add GHanaLovesMe to your watch window and notice how its value changes depending on which location you are currently stepping into.
// 2) Important: Dear HanaLovesMe functions are not thread-safe because of this pointer.
//    If you want thread-safety to allow N threads to access N different contexts, you can:
//    - Change this variable to use thread local stohnly so each thread can refer to a different context, in imconfig.h:
//          struct HanaLovesMeContext;
//          extern thread_local HanaLovesMeContext* MyHanaLovesMeTLS;
//          #define GHanaLovesMe MyHanaLovesMeTLS
//      And then define MyHanaLovesMeTLS in one of your cpp file. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.
//    - Future development aim to make this context pointer explicit to all calls. Also read https://github.com/ocornut/HanaLovesMe/issues/586
//    - If you need a finite number of contexts, you may compile and use multiple instances of the HanaLovesMe code from different namespace.
#ifndef GHanaLovesMe
HanaLovesMeContext* GHanaLovesMe = NULL;
#endif

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// If you use DLL hotreloading you might need to call SetAllocatorFunctions() after reloading code from this file.
// Otherwise, you probably don't want to modify them mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
#ifndef HanaLovesMe_DISABLE_DEFAULT_ALLOCATORS
static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); return malloc(size); }
static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); free(ptr); }
#else
static void* MallocWrapper(size_t size, void* user_data) { IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return NULL; }
static void    FreeWrapper(void* ptr, void* user_data) { IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0); }
#endif

static void* (*GImAllocatorAllocFunc)(size_t size, void* user_data) = MallocWrapper;
static void   (*GImAllocatorFreeFunc)(void* ptr, void* user_data) = FreeWrapper;
static void* GImAllocatorUserData = NULL;

//-----------------------------------------------------------------------------
// [SECTION] MAIN USER FACING STRUCTURES (HanaLovesMeStyle, HanaLovesMeIO)
//-----------------------------------------------------------------------------

HanaLovesMeStyle::HanaLovesMeStyle()
{
    Alpha = 1.0f;             // Global alpha applies to everything in HanaLovesMe
    WindowPadding = vsize(8, 8);      // Padding within a window
    WindowRounding = 0.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows
    WindowBorderSize = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    WindowMinSize = vsize(32, 32);    // Minimum window size
    WindowTitleAlign = vsize(0.0f, 0.5f);// Alignment for title bar text
    ChildRounding = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
    ChildBorderSize = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    PopupRounding = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
    PopupBorderSize = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    FramePadding = vsize(4, 3);      // Padding within a framed rectangle (used by most widgets)
    FrameRounding = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
    FrameBorderSize = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
    ItemSpacing = vsize(8, 4);      // Horizontal and vertical spacing between widgets/lines
    ItemInnerSpacing = vsize(4, 4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
    TouchExtraPadding = vsize(0, 0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
    IndentSpacing = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
    ColumnsMinSpacing = 6.0f;             // Minimum horizontal spacing between two columns
    ScrollbarSize = 7.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
    ScrollbarRounding = 0.0f;             // Radius of grab corners rounding for scrollbar
    GrabMinSize = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar
    GrabRounding = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
    TabRounding = 0.0f;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
    TabBorderSize = 0.0f;             // Thickness of border around tabs.
    ButtonTextAlign = vsize(0.5f, 0.5f);// Alignment of button text when button is larger than text.
    SelectableTextAlign = vsize(0.0f, 0.0f);// Alignment of selectable text when button is larger than text.
    DisplayWindowPadding = vsize(19, 19);    // Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.
    DisplaySafeAreaPadding = vsize(3, 3);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
    MouseCursorScale = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
    AntiAliasedLines = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.
    AntiAliasedFill = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
    CurveTessellationTol = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.

    // Default theme
    HanaLovesMe::StyleColorsDark(this);
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized HanaLovesMeStyle structure rather than scaling multiple times.
void HanaLovesMeStyle::ScaleAllSizes(float scale_factor)
{
    WindowPadding = ImFloor(WindowPadding * scale_factor);
    WindowRounding = ImFloor(WindowRounding * scale_factor);
    WindowMinSize = ImFloor(WindowMinSize * scale_factor);
    ChildRounding = ImFloor(ChildRounding * scale_factor);
    PopupRounding = ImFloor(PopupRounding * scale_factor);
    FramePadding = ImFloor(FramePadding * scale_factor);
    FrameRounding = ImFloor(FrameRounding * scale_factor);
    ItemSpacing = ImFloor(ItemSpacing * scale_factor);
    ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);
    TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);
    IndentSpacing = ImFloor(IndentSpacing * scale_factor);
    ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);
    ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);
    ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);
    GrabMinSize = ImFloor(GrabMinSize * scale_factor);
    GrabRounding = ImFloor(GrabRounding * scale_factor);
    TabRounding = ImFloor(TabRounding * scale_factor);
    DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);
    DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);
    MouseCursorScale = ImFloor(MouseCursorScale * scale_factor);
}

HanaLovesMeIO::HanaLovesMeIO()
{
    // Most fields are initialized with zero
    memset(this, 0, sizeof(*this));

    // Settings
    ConfigFlags = HanaLovesMeConfigFlags_None;
    BackendFlags = HanaLovesMeBackendFlags_None;
    DisplaySize = vsize(-1.0f, -1.0f);
    DeltaTime = 1.0f / 60.0f;
    IniSavingRate = 5.0f;
    IniFilename = "HanaLovesMe.ini";
    LogFilename = "HanaLovesMe_log.txt";
    MouseDoubleClickTime = 0.30f;
    MouseDoubleClickMaxDist = 6.0f;
    for (int i = 0; i < HanaLovesMeKey_COUNT; i++)
        KeyMap[i] = -1;
    KeyRepeatDelay = 0.250f;
    KeyRepeatRate = 0.050f;
    UserData = NULL;

    Fonts = NULL;
    FontGlobalScale = 1.0f;
    FontDefault = NULL;
    FontAllowUserScaling = false;
    DisplayFramebufferScale = vsize(1.0f, 1.0f);

    // Miscellaneous options
    MouseDrawCursor = false;
#ifdef __APPLE__
    ConfigMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
#else
    ConfigMacOSXBehaviors = false;
#endif
    ConfigInputTextCursorBlink = true;
    ConfigWindowsResizeFromEdges = true;
    ConfigWindowsMoveFromTitleBarOnly = false;

    // Platform Functions
    BackendPlatformName = BackendRendererName = NULL;
    BackendPlatformUserData = BackendRendererUserData = BackendLanguageUserData = NULL;
    GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations
    SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
    ClipboardUserData = NULL;
    ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;
    ImeWindowHandle = NULL;

#ifndef HanaLovesMe_DISABLE_OBSOLETE_FUNCTIONS
    RenderDrawListsFn = NULL;
#endif

    // Input (NB: we already have memset zero the entire structure!)
    MousePos = vsize(-FLT_MAX, -FLT_MAX);
    MousePosPrev = vsize(-FLT_MAX, -FLT_MAX);
    MouseDragThreshold = 6.0f;
    for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i] = KeysDownDurationPrev[i] = -1.0f;
    for (int i = 0; i < IM_ARRAYSIZE(NavInputsDownDuration); i++) NavInputsDownDuration[i] = -1.0f;
}

// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
void HanaLovesMeIO::AddInputCharacter(ImWchar c)
{
    InputQueueCharacters.push_back(c);
}

void HanaLovesMeIO::AddInputCharactersUTF8(const char* utf8_chars)
{
    while (*utf8_chars != 0)
    {
        unsigned int c = 0;
        utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, NULL);
        if (c > 0 && c <= 0xFFFF)
            InputQueueCharacters.push_back((ImWchar)c);
    }
}

void HanaLovesMeIO::ClearInputCharacters()
{
    InputQueueCharacters.resize(0);
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Maths, String, Format, Hash, File functions)
//-----------------------------------------------------------------------------

vsize ImLineClosestPoint(const vsize & a, const vsize & b, const vsize & p)
{
    vsize ap = p - a;
    vsize ab_dir = b - a;
    float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
    if (dot < 0.0f)
        return a;
    float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
    if (dot > ab_len_sqr)
        return b;
    return a + ab_dir * dot / ab_len_sqr;
}

bool ImTriangleContainsPoint(const vsize & a, const vsize & b, const vsize & c, const vsize & p)
{
    bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
    bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;
    bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;
    return ((b1 == b2) && (b2 == b3));
}

void ImTriangleBarycentricCoords(const vsize & a, const vsize & b, const vsize & c, const vsize & p, float& out_u, float& out_v, float& out_w)
{
    vsize v0 = b - a;
    vsize v1 = c - a;
    vsize v2 = p - a;
    const float denom = v0.x * v1.y - v1.x * v0.y;
    out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
    out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
    out_u = 1.0f - out_v - out_w;
}

vsize ImTriangleClosestPoint(const vsize & a, const vsize & b, const vsize & c, const vsize & p)
{
    vsize proj_ab = ImLineClosestPoint(a, b, p);
    vsize proj_bc = ImLineClosestPoint(b, c, p);
    vsize proj_ca = ImLineClosestPoint(c, a, p);
    float dist2_ab = ImLengthSqr(p - proj_ab);
    float dist2_bc = ImLengthSqr(p - proj_bc);
    float dist2_ca = ImLengthSqr(p - proj_ca);
    float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));
    if (m == dist2_ab)
        return proj_ab;
    if (m == dist2_bc)
        return proj_bc;
    return proj_ca;
}

// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.
int ImStricmp(const char* str1, const char* str2)
{
    int d;
    while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }
    return d;
}

int ImStrnicmp(const char* str1, const char* str2, size_t count)
{
    int d = 0;
    while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }
    return d;
}

void ImStrncpy(char* dst, const char* src, size_t count)
{
    if (count < 1)
        return;
    if (count > 1)
        strncpy(dst, src, count - 1);
    dst[count - 1] = 0;
}

char* ImStrdup(const char* str)
{
    size_t len = strlen(str);
    void* buf = IM_ALLOC(len + 1);
    return (char*)memcpy(buf, (const void*)str, len + 1);
}

char* ImStrdupcpy(char* dst, size_t * p_dst_size, const char* src)
{
    size_t dst_buf_size = p_dst_size ? *p_dst_size : strlen(dst) + 1;
    size_t src_size = strlen(src) + 1;
    if (dst_buf_size < src_size)
    {
        IM_FREE(dst);
        dst = (char*)IM_ALLOC(src_size);
        if (p_dst_size)
            * p_dst_size = src_size;
    }
    return (char*)memcpy(dst, (const void*)src, src_size);
}

const char* ImStrchrRange(const char* str, const char* str_end, char c)
{
    const char* p = (const char*)memchr(str, (int)c, str_end - str);
    return p;
}

int ImStrlenW(const ImWchar * str)
{
    //return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bits
    int n = 0;
    while (*str++) n++;
    return n;
}

// Find end-of-line. Return pointer will point to either first \n, either str_end.
const char* ImStreolRange(const char* str, const char* str_end)
{
    const char* p = (const char*)memchr(str, '\n', str_end - str);
    return p ? p : str_end;
}

const ImWchar * ImStrbolW(const ImWchar * buf_mid_line, const ImWchar * buf_begin) // find beginning-of-line
{
    while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')
        buf_mid_line--;
    return buf_mid_line;
}

const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
{
    if (!needle_end)
        needle_end = needle + strlen(needle);

    const char un0 = (char)toupper(*needle);
    while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))
    {
        if (toupper(*haystack) == un0)
        {
            const char* b = needle + 1;
            for (const char* a = haystack + 1; b < needle_end; a++, b++)
                if (toupper(*a) != toupper(*b))
                    break;
            if (b == needle_end)
                return haystack;
        }
        haystack++;
    }
    return NULL;
}

// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.
void ImStrTrimBlanks(char* buf)
{
    char* p = buf;
    while (p[0] == ' ' || p[0] == '\t')     // Leading blanks
        p++;
    char* p_start = p;
    while (*p != 0)                         // Find end of string
        p++;
    while (p > p_start && (p[-1] == ' ' || p[-1] == '\t'))  // Trailing blanks
        p--;
    if (p_start != buf)                     // Copy memory if we had leading blanks
        memmove(buf, p_start, p - p_start);
    buf[p - p_start] = 0;                   // Zero terminate
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
// B) When buf==NULL vsnprintf() will return the output size.
#ifndef HanaLovesMe_DISABLE_FORMAT_STRING_FUNCTIONS

//#define HanaLovesMe_USE_STB_SPRINTF
#ifdef HanaLovesMe_USE_STB_SPRINTF
#define STB_SPRINTF_IMPLEMENTATION
#include "x07dns_sprintf.h"
#endif

#if defined(_MSC_VER) && !defined(vsnprintf)
#define vsnprintf _vsnprintf
#endif

int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
#ifdef HanaLovesMe_USE_STB_SPRINTF
    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
    int w = vsnprintf(buf, buf_size, fmt, args);
#endif
    va_end(args);
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}

int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)
{
#ifdef HanaLovesMe_USE_STB_SPRINTF
    int w = stbsp_vsnprintf(buf, (int)buf_size, fmt, args);
#else
    int w = vsnprintf(buf, buf_size, fmt, args);
#endif
    if (buf == NULL)
        return w;
    if (w == -1 || w >= (int)buf_size)
        w = (int)buf_size - 1;
    buf[w] = 0;
    return w;
}
#endif // #ifdef HanaLovesMe_DISABLE_FORMAT_STRING_FUNCTIONS

// CRC32 needs a 1KB lookup table (not cache friendly)
// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:
// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.
static const ImU32 GCrc32LookupTable[256] =
{
    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
};

// Known size hash
// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImU32 ImHashData(const void* data_p, size_t data_size, ImU32 seed)
{
    ImU32 crc = ~seed;
    const unsigned char* data = (const unsigned char*)data_p;
    const ImU32* crc32_lut = GCrc32LookupTable;
    while (data_size-- != 0)
        crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *data++];
    return ~crc;
}

// Zero-terminated string hash, with support for ### to reset back to seed value
// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
// Because this syntax is rarely used we are optimizing for the common case.
// - If we reach ### in the string we discard the hash so far and reset to the seed.
// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImU32 ImHashStr(const char* data_p, size_t data_size, ImU32 seed)
{
    seed = ~seed;
    ImU32 crc = seed;
    const unsigned char* data = (const unsigned char*)data_p;
    const ImU32* crc32_lut = GCrc32LookupTable;
    if (data_size != 0)
    {
        while (data_size-- != 0)
        {
            unsigned char c = *data++;
            if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    } else
    {
        while (unsigned char c = *data++)
        {
            if (c == '#' && data[0] == '#' && data[1] == '#')
                crc = seed;
            crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
        }
    }
    return ~crc;
}

FILE* ImFileOpen(const char* filename, const char* mode)
{
#if defined(_WIN32) && !defined(__CYGWIN__) && !defined(__GNUC__)
    // We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames. Converting both strings from UTF-8 to wchar format (using a single allocation, because we can)
    const int filename_wsize = ImTextCountCharsFromUtf8(filename, NULL) + 1;
    const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;
    ImVector<ImWchar> buf;
    buf.resize(filename_wsize + mode_wsize);
    ImTextStrFromUtf8(&buf[0], filename_wsize, filename, NULL);
    ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);
    return _wfopen((wchar_t*)& buf[0], (wchar_t*)& buf[filename_wsize]);
#else
    return fopen(filename, mode);
#endif
}

// Load file content into memory
// Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == HanaLovesMe::MemFree()
void* ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t * out_file_size, int padding_bytes)
{
    IM_ASSERT(filename && file_open_mode);
    if (out_file_size)
        * out_file_size = 0;

    FILE* f;
    if ((f = ImFileOpen(filename, file_open_mode)) == NULL)
        return NULL;

    long file_size_signed;
    if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))
    {
        fclose(f);
        return NULL;
    }

    size_t file_size = (size_t)file_size_signed;
    void* file_data = IM_ALLOC(file_size + padding_bytes);
    if (file_data == NULL)
    {
        fclose(f);
        return NULL;
    }
    if (fread(file_data, 1, file_size, f) != file_size)
    {
        fclose(f);
        IM_FREE(file_data);
        return NULL;
    }
    if (padding_bytes > 0)
        memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);

    fclose(f);
    if (out_file_size)
        * out_file_size = file_size;

    return file_data;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
//-----------------------------------------------------------------------------

// Convert UTF-8 to 32-bits character, process single character input.
// Based on stb_from_utf8() from github.com/nothings/stb/
// We handle UTF-8 decoding error by skipping forward.
int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
{
    unsigned int c = (unsigned int)-1;
    const unsigned char* str = (const unsigned char*)in_text;
    if (!(*str & 0x80))
    {
        c = (unsigned int)(*str++);
        *out_char = c;
        return 1;
    }
    if ((*str & 0xe0) == 0xc0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 2) return 1;
        if (*str < 0xc2) return 2;
        c = (unsigned int)((*str++ & 0x1f) << 6);
        if ((*str & 0xc0) != 0x80) return 2;
        c += (*str++ & 0x3f);
        *out_char = c;
        return 2;
    }
    if ((*str & 0xf0) == 0xe0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 3) return 1;
        if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return 3;
        if (*str == 0xed && str[1] > 0x9f) return 3; // str[1] < 0x80 is checked below
        c = (unsigned int)((*str++ & 0x0f) << 12);
        if ((*str & 0xc0) != 0x80) return 3;
        c += (unsigned int)((*str++ & 0x3f) << 6);
        if ((*str & 0xc0) != 0x80) return 3;
        c += (*str++ & 0x3f);
        *out_char = c;
        return 3;
    }
    if ((*str & 0xf8) == 0xf0)
    {
        *out_char = 0xFFFD; // will be invalid but not end of string
        if (in_text_end && in_text_end - (const char*)str < 4) return 1;
        if (*str > 0xf4) return 4;
        if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return 4;
        if (*str == 0xf4 && str[1] > 0x8f) return 4; // str[1] < 0x80 is checked below
        c = (unsigned int)((*str++ & 0x07) << 18);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (unsigned int)((*str++ & 0x3f) << 12);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (unsigned int)((*str++ & 0x3f) << 6);
        if ((*str & 0xc0) != 0x80) return 4;
        c += (*str++ & 0x3f);
        // utf-8 encodings of values used in surrogate pairs are invalid
        if ((c & 0xFFFFF800) == 0xD800) return 4;
        *out_char = c;
        return 4;
    }
    *out_char = 0;
    return 0;
}

int ImTextStrFromUtf8(ImWchar * buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
{
    ImWchar* buf_out = buf;
    ImWchar* buf_end = buf + buf_size;
    while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        if (c < 0x10000)    // FIXME: Losing characters that don't fit in 2 bytes
            * buf_out++ = (ImWchar)c;
    }
    *buf_out = 0;
    if (in_text_remaining)
        * in_text_remaining = in_text;
    return (int)(buf_out - buf);
}

int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)
{
    int char_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c;
        in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
        if (c == 0)
            break;
        if (c < 0x10000)
            char_count++;
    }
    return char_count;
}

// Based on stb_to_utf8() from github.com/nothings/stb/
static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)
{
    if (c < 0x80)
    {
        buf[0] = (char)c;
        return 1;
    }
    if (c < 0x800)
    {
        if (buf_size < 2) return 0;
        buf[0] = (char)(0xc0 + (c >> 6));
        buf[1] = (char)(0x80 + (c & 0x3f));
        return 2;
    }
    if (c >= 0xdc00 && c < 0xe000)
    {
        return 0;
    }
    if (c >= 0xd800 && c < 0xdc00)
    {
        if (buf_size < 4) return 0;
        buf[0] = (char)(0xf0 + (c >> 18));
        buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
        buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
        buf[3] = (char)(0x80 + ((c) & 0x3f));
        return 4;
    }
    //else if (c < 0x10000)
    {
        if (buf_size < 3) return 0;
        buf[0] = (char)(0xe0 + (c >> 12));
        buf[1] = (char)(0x80 + ((c >> 6) & 0x3f));
        buf[2] = (char)(0x80 + ((c) & 0x3f));
        return 3;
    }
}

// Not optimal but we very rarely use this function.
int ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)
{
    unsigned int dummy = 0;
    return ImTextCharFromUtf8(&dummy, in_text, in_text_end);
}

static inline int ImTextCountUtf8BytesFromChar(unsigned int c)
{
    if (c < 0x80) return 1;
    if (c < 0x800) return 2;
    if (c >= 0xdc00 && c < 0xe000) return 0;
    if (c >= 0xd800 && c < 0xdc00) return 4;
    return 3;
}

int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar * in_text, const ImWchar * in_text_end)
{
    char* buf_out = buf;
    const char* buf_end = buf + buf_size;
    while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            * buf_out++ = (char)c;
        else
            buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end - buf_out - 1), c);
    }
    *buf_out = 0;
    return (int)(buf_out - buf);
}

int ImTextCountUtf8BytesFromStr(const ImWchar * in_text, const ImWchar * in_text_end)
{
    int bytes_count = 0;
    while ((!in_text_end || in_text < in_text_end) && *in_text)
    {
        unsigned int c = (unsigned int)(*in_text++);
        if (c < 0x80)
            bytes_count++;
        else
            bytes_count += ImTextCountUtf8BytesFromChar(c);
    }
    return bytes_count;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILTIES (Color functions)
// Note: The Convert functions are early design which are not consistent with other API.
//-----------------------------------------------------------------------------

xuifloatcolor HanaLovesMe::ColorConvertU32ToFloat4(ImU32 in)
{
    float s = 1.0f / 255.0f;
    return xuifloatcolor(
        ((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
        ((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
}

ImU32 HanaLovesMe::ColorConvertFloat4ToU32(const xuifloatcolor & in)
{
    ImU32 out;
    out = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
    out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
    return out;
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
void HanaLovesMe::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
{
    float K = 0.f;
    if (g < b)
    {
        ImSwap(g, b);
        K = -1.f;
    }
    if (r < g)
    {
        ImSwap(r, g);
        K = -2.f / 6.f - K;
    }

    const float chroma = r - (g < b ? g : b);
    out_h = ImFabs(K + (g - b) / (6.f * chroma + 1e-20f));
    out_s = chroma / (r + 1e-20f);
    out_v = r;
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
void HanaLovesMe::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)
{
    if (s == 0.0f)
    {
        // gray
        out_r = out_g = out_b = v;
        return;
    }

    h = ImFmod(h, 1.0f) / (60.0f / 360.0f);
    int   i = (int)h;
    float f = h - (float)i;
    float p = v * (1.0f - s);
    float q = v * (1.0f - s * f);
    float t = v * (1.0f - s * (1.0f - f));

    switch (i)
    {
    case 0: out_r = v; out_g = t; out_b = p; break;
    case 1: out_r = q; out_g = v; out_b = p; break;
    case 2: out_r = p; out_g = v; out_b = t; break;
    case 3: out_r = p; out_g = q; out_b = v; break;
    case 4: out_r = t; out_g = p; out_b = v; break;
    case 5: default: out_r = v; out_g = p; out_b = q; break;
    }
}

ImU32 HanaLovesMe::GetColorU32(HanaLovesMeCol idx, float alpha_mul)
{
    HanaLovesMeStyle& style = GHanaLovesMe->Style;
    xuifloatcolor c = style.Colors[idx];
    c.w *= style.Alpha * alpha_mul;
    return ColorConvertFloat4ToU32(c);
}

ImU32 HanaLovesMe::GetColorU32(const xuifloatcolor & col)
{
    HanaLovesMeStyle& style = GHanaLovesMe->Style;
    xuifloatcolor c = col;
    c.w *= style.Alpha;
    return ColorConvertFloat4ToU32(c);
}

const xuifloatcolor& HanaLovesMe::GetStyleColorVec4(HanaLovesMeCol idx)
{
    HanaLovesMeStyle& style = GHanaLovesMe->Style;
    return style.Colors[idx];
}

ImU32 HanaLovesMe::GetColorU32(ImU32 col)
{
    float style_alpha = GHanaLovesMe->Style.Alpha;
    if (style_alpha >= 1.0f)
        return col;
    ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;
    a = (ImU32)(a * style_alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.
    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);
}

//-----------------------------------------------------------------------------
// [SECTION] HanaLovesMeStohnly
// Helper: Key->value stohnly
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
static HanaLovesMeStohnly::Pair * LowerBound(ImVector<HanaLovesMeStohnly::Pair> & data, HanaLovesMeID key)
{
    HanaLovesMeStohnly::Pair* first = data.Data;
    HanaLovesMeStohnly::Pair* last = data.Data + data.Size;
    size_t count = (size_t)(last - first);
    while (count > 0)
    {
        size_t count2 = count >> 1;
        HanaLovesMeStohnly::Pair* mid = first + count2;
        if (mid->key < key)
        {
            first = ++mid;
            count -= count2 + 1;
        } else
        {
            count = count2;
        }
    }
    return first;
}

// For quicker full rebuild of a stohnly (instead of an incremental one), you may add all your contents and then sort once.
void HanaLovesMeStohnly::BuildSortByKey()
{
    struct StaticFunc
    {
        static int HanaLovesMe_CDECL PairCompareByID(const void* lhs, const void* rhs)
        {
            // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
            if (((const Pair*)lhs)->key > ((const Pair*)rhs)->key) return +1;
            if (((const Pair*)lhs)->key < ((const Pair*)rhs)->key) return -1;
            return 0;
        }
    };
    if (Data.Size > 1)
        ImQsort(Data.Data, (size_t)Data.Size, sizeof(Pair), StaticFunc::PairCompareByID);
}

int HanaLovesMeStohnly::GetInt(HanaLovesMeID key, int default_val) const
{
    HanaLovesMeStohnly::Pair* it = LowerBound(const_cast<ImVector<HanaLovesMeStohnly::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_i;
}

bool HanaLovesMeStohnly::GetBool(HanaLovesMeID key, bool default_val) const
{
    return GetInt(key, default_val ? 1 : 0) != 0;
}

float HanaLovesMeStohnly::GetFloat(HanaLovesMeID key, float default_val) const
{
    HanaLovesMeStohnly::Pair* it = LowerBound(const_cast<ImVector<HanaLovesMeStohnly::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return default_val;
    return it->val_f;
}

void* HanaLovesMeStohnly::GetVoidPtr(HanaLovesMeID key) const
{
    HanaLovesMeStohnly::Pair* it = LowerBound(const_cast<ImVector<HanaLovesMeStohnly::Pair>&>(Data), key);
    if (it == Data.end() || it->key != key)
        return NULL;
    return it->val_p;
}

// References are only valid until a new value is added to the stohnly. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
int* HanaLovesMeStohnly::GetIntRef(HanaLovesMeID key, int default_val)
{
    HanaLovesMeStohnly::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_i;
}

bool* HanaLovesMeStohnly::GetBoolRef(HanaLovesMeID key, bool default_val)
{
    return (bool*)GetIntRef(key, default_val ? 1 : 0);
}

float* HanaLovesMeStohnly::GetFloatRef(HanaLovesMeID key, float default_val)
{
    HanaLovesMeStohnly::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_f;
}

void** HanaLovesMeStohnly::GetVoidPtrRef(HanaLovesMeID key, void* default_val)
{
    HanaLovesMeStohnly::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
        it = Data.insert(it, Pair(key, default_val));
    return &it->val_p;
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
void HanaLovesMeStohnly::SetInt(HanaLovesMeID key, int val)
{
    HanaLovesMeStohnly::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_i = val;
}

void HanaLovesMeStohnly::SetBool(HanaLovesMeID key, bool val)
{
    SetInt(key, val ? 1 : 0);
}

void HanaLovesMeStohnly::SetFloat(HanaLovesMeID key, float val)
{
    HanaLovesMeStohnly::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_f = val;
}

void HanaLovesMeStohnly::SetVoidPtr(HanaLovesMeID key, void* val)
{
    HanaLovesMeStohnly::Pair* it = LowerBound(Data, key);
    if (it == Data.end() || it->key != key)
    {
        Data.insert(it, Pair(key, val));
        return;
    }
    it->val_p = val;
}

void HanaLovesMeStohnly::SetAllInt(int v)
{
    for (int i = 0; i < Data.Size; i++)
        Data[i].val_i = v;
}

//-----------------------------------------------------------------------------
// [SECTION] HanaLovesMeTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
HanaLovesMeTextFilter::HanaLovesMeTextFilter(const char* default_filter)
{
    if (default_filter)
    {
        ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));
        Build();
    } else
    {
        InputBuf[0] = 0;
        CountGrep = 0;
    }
}

bool HanaLovesMeTextFilter::Draw(const char* label, float width)
{
    if (width != 0.0f)
        HanaLovesMe::PushItemWidth(width);
    bool value_changed = HanaLovesMe::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));
    if (width != 0.0f)
        HanaLovesMe::PopItemWidth();
    if (value_changed)
        Build();
    return value_changed;
}

void HanaLovesMeTextFilter::TextRange::split(char separator, ImVector<TextRange> * out) const
{
    out->resize(0);
    const char* wb = b;
    const char* we = wb;
    while (we < e)
    {
        if (*we == separator)
        {
            out->push_back(TextRange(wb, we));
            wb = we + 1;
        }
        we++;
    }
    if (wb != we)
        out->push_back(TextRange(wb, we));
}

void HanaLovesMeTextFilter::Build()
{
    Filters.resize(0);
    TextRange input_range(InputBuf, InputBuf + strlen(InputBuf));
    input_range.split(',', &Filters);

    CountGrep = 0;
    for (int i = 0; i != Filters.Size; i++)
    {
        TextRange& f = Filters[i];
        while (f.b < f.e && ImCharIsBlankA(f.b[0]))
            f.b++;
        while (f.e > f.b && ImCharIsBlankA(f.e[-1]))
            f.e--;
        if (f.empty())
            continue;
        if (Filters[i].b[0] != '-')
            CountGrep += 1;
    }
}

bool HanaLovesMeTextFilter::PassFilter(const char* text, const char* text_end) const
{
    if (Filters.empty())
        return true;

    if (text == NULL)
        text = "";

    for (int i = 0; i != Filters.Size; i++)
    {
        const TextRange& f = Filters[i];
        if (f.empty())
            continue;
        if (f.b[0] == '-')
        {
            // Subtract
            if (ImStristr(text, text_end, f.begin() + 1, f.end()) != NULL)
                return false;
        } else
        {
            // Grep
            if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)
                return true;
        }
    }

    // Implicit * grep
    if (CountGrep == 0)
        return true;

    return false;
}

//-----------------------------------------------------------------------------
// [SECTION] HanaLovesMeTextBuffer
//-----------------------------------------------------------------------------

// On some platform vsnprintf() takes va_list by reference and modifies it.
// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.
#ifndef va_copy
#if defined(__GNUC__) || defined(__clang__)
#define va_copy(dest, src) __builtin_va_copy(dest, src)
#else
#define va_copy(dest, src) (dest = src)
#endif
#endif

char HanaLovesMeTextBuffer::EmptyString[1] = { 0 };

void HanaLovesMeTextBuffer::append(const char* str, const char* str_end)
{
    int len = str_end ? (int)(str_end - str) : (int)strlen(str);

    // Add zero-terminator the first time
    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int new_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
    }

    Buf.resize(needed_sz);
    memcpy(&Buf[write_off - 1], str, (size_t)len);
    Buf[write_off - 1 + len] = 0;
}

void HanaLovesMeTextBuffer::appendf(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    appendfv(fmt, args);
    va_end(args);
}

// Helper: Text buffer for logging/accumulating text
void HanaLovesMeTextBuffer::appendfv(const char* fmt, va_list args)
{
    va_list args_copy;
    va_copy(args_copy, args);

    int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
    if (len <= 0)
    {
        va_end(args_copy);
        return;
    }

    // Add zero-terminator the first time
    const int write_off = (Buf.Size != 0) ? Buf.Size : 1;
    const int needed_sz = write_off + len;
    if (write_off + len >= Buf.Capacity)
    {
        int new_capacity = Buf.Capacity * 2;
        Buf.reserve(needed_sz > new_capacity ? needed_sz : new_capacity);
    }

    Buf.resize(needed_sz);
    ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
    va_end(args_copy);
}

//-----------------------------------------------------------------------------
// [SECTION] HanaLovesMeListClipper
// This is currently not as flexible/powerful as it should be, needs some rework (see TODO)
//-----------------------------------------------------------------------------

static void SetCursorPosYAndSetupDummyPrevLine(float pos_y, float line_height)
{
    // Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
    // The clipper should probably have a 4th step to display the last item in a regular manner.
    HanaLovesMe::SetCursorPosY(pos_y);
    HanaLovesMeWindow* window = HanaLovesMe::GetCurrentWindow();
    window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;      // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.
    window->DC.PrevLineSize.y = (line_height - GHanaLovesMe->Style.ItemSpacing.y);    // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
    if (window->DC.CurrentColumns)
        window->DC.CurrentColumns->LineMinY = window->DC.CursorPos.y;           // Setting this so that cell Y position are set properly
}

// Use case A: Begin() called from constructor with items_height<0, then called again from Sync() in StepNo 1
// Use case B: Begin() called from constructor with items_height>0
// FIXME-LEGACY: Ideally we should remove the Begin/End functions but they are part of the legacy API we still support. This is why some of the code in Step() calling Begin() and reassign some fields, spaghetti style.
void HanaLovesMeListClipper::Begin(int count, float items_height)
{
    StartPosY = HanaLovesMe::GetCursorPosY();
    ItemsHeight = items_height;
    ItemsCount = count;
    StepNo = 0;
    DisplayEnd = DisplayStart = -1;
    if (ItemsHeight > 0.0f)
    {
        HanaLovesMe::CalcListClipping(ItemsCount, ItemsHeight, &DisplayStart, &DisplayEnd); // calculate how many to clip/display
        if (DisplayStart > 0)
            SetCursorPosYAndSetupDummyPrevLine(StartPosY + DisplayStart * ItemsHeight, ItemsHeight); // advance cursor
        StepNo = 2;
    }
}

void HanaLovesMeListClipper::End()
{
    if (ItemsCount < 0)
        return;
    // In theory here we should assert that HanaLovesMe::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.
    if (ItemsCount < INT_MAX)
        SetCursorPosYAndSetupDummyPrevLine(StartPosY + ItemsCount * ItemsHeight, ItemsHeight); // advance cursor
    ItemsCount = -1;
    StepNo = 3;
}

bool HanaLovesMeListClipper::Step()
{
    if (ItemsCount == 0 || HanaLovesMe::GetCurrentWindowRead()->SkipItems)
    {
        ItemsCount = -1;
        return false;
    }
    if (StepNo == 0) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.
    {
        DisplayStart = 0;
        DisplayEnd = 1;
        StartPosY = HanaLovesMe::GetCursorPosY();
        StepNo = 1;
        return true;
    }
    if (StepNo == 1) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
    {
        if (ItemsCount == 1) { ItemsCount = -1; return false; }
        float items_height = HanaLovesMe::GetCursorPosY() - StartPosY;
        IM_ASSERT(items_height > 0.0f);   // If this triggers, it means Item 0 hasn't moved the cursor vertically
        Begin(ItemsCount - 1, items_height);
        DisplayStart++;
        DisplayEnd++;
        StepNo = 3;
        return true;
    }
    if (StepNo == 2) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.
    {
        IM_ASSERT(DisplayStart >= 0 && DisplayEnd >= 0);
        StepNo = 3;
        return true;
    }
    if (StepNo == 3) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
        End();
    return false;
}

//-----------------------------------------------------------------------------
// [SECTION] RENDER HELPERS
// Those (internal) functions are currently quite a legacy mess - their signature and behavior will change.
// Also see HanaLovesMe_draw.cpp for some more which have been reworked to not rely on HanaLovesMe:: state.
//-----------------------------------------------------------------------------

const char* HanaLovesMe::FindRenderedTextEnd(const char* text, const char* text_end)
{
    const char* text_display_end = text;
    if (!text_end)
        text_end = (const char*)-1;

    while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
        text_display_end++;
    return text_display_end;
}

// Internal HanaLovesMe functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
void HanaLovesMe::RenderText(vsize pos, const char* text, const char* text_end, bool hide_text_after_hash)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;

    // Hide anything after a '##' string
    const char* text_display_end;
    if (hide_text_after_hash)
    {
        text_display_end = FindRenderedTextEnd(text, text_end);
    } else
    {
        if (!text_end)
            text_end = text + strlen(text); // FIXME-OPT
        text_display_end = text_end;
    }

    if (text != text_display_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(HanaLovesMeCol_Text), text, text_display_end);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_display_end);
    }
}

void HanaLovesMe::RenderTextWrapped(vsize pos, const char* text, const char* text_end, float wrap_width)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = text + strlen(text); // FIXME-OPT

    if (text != text_end)
    {
        window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(HanaLovesMeCol_Text), text, text_end, wrap_width);
        if (g.LogEnabled)
            LogRenderedText(&pos, text, text_end);
    }
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
void HanaLovesMe::RenderTextClippedEx(ImDrawList * draw_list, const vsize & pos_min, const vsize & pos_max, const char* text, const char* text_display_end, const vsize * text_size_if_known, const vsize & align, const vsrect * clip_rect)
{
    // Perform CPU side clipping for single clipped element to avoid using scissor state
    vsize pos = pos_min;
    const vsize text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);

    const vsize* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
    const vsize* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
    bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
    if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
        need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);

    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
    if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
    if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

    // Render
    if (need_clipping)
    {
        xuifloatcolor fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(HanaLovesMeCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
    } else
    {
        draw_list->AddText(NULL, 0.0f, pos, GetColorU32(HanaLovesMeCol_Text), text, text_display_end, 0.0f, NULL);
    }
}

void HanaLovesMe::RenderTextClipped(const vsize & pos_min, const vsize & pos_max, const char* text, const char* text_end, const vsize * text_size_if_known, const vsize & align, const vsrect * clip_rect)
{
    // Hide anything after a '##' string
    const char* text_display_end = FindRenderedTextEnd(text, text_end);
    const int text_len = (int)(text_display_end - text);
    if (text_len == 0)
        return;

    HanaLovesMeContext & g = *GHanaLovesMe;
    HanaLovesMeWindow * window = g.CurrentWindow;
    RenderTextClippedEx(window->DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect);
    if (g.LogEnabled)
        LogRenderedText(&pos_min, text, text_display_end);
}

// Render a rectangle shaped with optional rounding and borders
void HanaLovesMe::RenderFrame(vsize p_min, vsize p_max, ImU32 fill_col, bool border, float rounding)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
    const float border_size = g.Style.FrameBorderSize;
    if (border && border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min + vsize(1, 1), p_max + vsize(1, 1), GetColorU32(HanaLovesMeCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(HanaLovesMeCol_Border), rounding, ImDrawCornerFlags_All, border_size);
    }
}

void HanaLovesMe::RenderFrameBorder(vsize p_min, vsize p_max, float rounding)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    const float border_size = g.Style.FrameBorderSize;
    if (border_size > 0.0f)
    {
        window->DrawList->AddRect(p_min + vsize(1, 1), p_max + vsize(1, 1), GetColorU32(HanaLovesMeCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
        window->DrawList->AddRect(p_min, p_max, GetColorU32(HanaLovesMeCol_Border), rounding, ImDrawCornerFlags_All, border_size);
    }
}

// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
void HanaLovesMe::RenderArrow(vsize p_min, HanaLovesMeDir dir, float scale)
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    const float h = g.FontSize * 1.00f;
    float r = h * 0.40f * scale;
    vsize center = p_min + vsize(h * 0.50f, h * 0.50f * scale);

    vsize a, b, c;
    switch (dir)
    {
    case HanaLovesMeDir_Up:
    case HanaLovesMeDir_Down:
        if (dir == HanaLovesMeDir_Up) r = -r;
        a = vsize(+0.000f, +0.750f) * r;
        b = vsize(-0.866f, -0.750f) * r;
        c = vsize(+0.866f, -0.750f) * r;
        break;
    case HanaLovesMeDir_Left:
    case HanaLovesMeDir_Right:
        if (dir == HanaLovesMeDir_Left) r = -r;
        a = vsize(+0.750f, +0.000f) * r;
        b = vsize(-0.750f, +0.866f) * r;
        c = vsize(-0.750f, -0.866f) * r;
        break;
    case HanaLovesMeDir_None:
    case HanaLovesMeDir_COUNT:
        IM_ASSERT(0);
        break;
    }

    g.CurrentWindow->DrawList->AddTriangleFilled(center + a, center + b, center + c, GetColorU32(HanaLovesMeCol_Text));
}

void HanaLovesMe::RenderBullet(vsize pos)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    window->DrawList->AddCircleFilled(pos, g.FontSize * 0.20f, GetColorU32(HanaLovesMeCol_Text), 8);
}

void HanaLovesMe::RenderCheckMark(vsize pos, ImU32 col, float sz)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;

    float thickness = ImMax(sz / 5.0f, 1.0f);
    sz -= thickness * 0.5f;
    pos += vsize(thickness * 0.25f, thickness * 0.25f);

    float third = sz / 3.0f;
    float bx = pos.x + third;
    float by = pos.y + sz - third * 0.5f;
    window->DrawList->PathLineTo(vsize(bx - third, by - third));
    window->DrawList->PathLineTo(vsize(bx, by));
    window->DrawList->PathLineTo(vsize(bx + third * 2, by - third * 2));
    window->DrawList->PathStroke(col, false, thickness);
}

void HanaLovesMe::RenderNavHighlight(const vsrect & bb, HanaLovesMeID id, HanaLovesMeNavHighlightFlags flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (id != g.NavId)
        return;
    if (g.NavDisableHighlight && !(flags & HanaLovesMeNavHighlightFlags_AlwaysDraw))
        return;
    HanaLovesMeWindow * window = g.CurrentWindow;
    if (window->DC.NavHideHighlightOneFrame)
        return;

    float rounding = (flags & HanaLovesMeNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
    vsrect display_rect = bb;
    display_rect.ClipWith(window->ClipRect);
    if (flags & HanaLovesMeNavHighlightFlags_TypeDefault)
    {
        const float THICKNESS = 2.0f;
        const float DISTANCE = 3.0f + THICKNESS * 0.5f;
        display_rect.Expand(vsize(DISTANCE, DISTANCE));
        bool fully_visible = window->ClipRect.Contains(display_rect);
        if (!fully_visible)
            window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
        window->DrawList->AddRect(display_rect.Min + vsize(THICKNESS * 0.5f, THICKNESS * 0.5f), display_rect.Max - vsize(THICKNESS * 0.5f, THICKNESS * 0.5f), GetColorU32(HanaLovesMeCol_NavHighlight), rounding, ImDrawCornerFlags_All, THICKNESS);
        if (!fully_visible)
            window->DrawList->PopClipRect();
    }
    if (flags & HanaLovesMeNavHighlightFlags_TypeThin)
    {
        window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(HanaLovesMeCol_NavHighlight), rounding, ~0, 1.0f);
    }
}

//-----------------------------------------------------------------------------
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
//-----------------------------------------------------------------------------

// HanaLovesMeWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
HanaLovesMeWindow::HanaLovesMeWindow(HanaLovesMeContext * context, const char* name)
    : DrawListInst(&context->DrawListSharedData)
{
    Name = ImStrdup(name);
    ID = ImHashStr(name, 0);
    IDStack.push_back(ID);
    Flags = HanaLovesMeWindowFlags_None;
    Pos = vsize(0.0f, 0.0f);
    Size = SizeFull = vsize(0.0f, 0.0f);
    SizeContents = SizeContentsExplicit = vsize(0.0f, 0.0f);
    WindowPadding = vsize(0.0f, 0.0f);
    WindowRounding = 0.0f;
    WindowBorderSize = 0.0f;
    NameBufLen = (int)strlen(name) + 1;
    MoveId = GetID("#MOVE");
    ChildId = 0;
    Scroll = vsize(0.0f, 0.0f);
    ScrollTarget = vsize(FLT_MAX, FLT_MAX);
    ScrollTargetCenterRatio = vsize(0.5f, 0.5f);
    ScrollbarSizes = vsize(0.0f, 0.0f);
    ScrollbarX = ScrollbarY = false;
    Active = WasActive = false;
    WriteAccessed = false;
    Collapsed = false;
    WantCollapseToggle = false;
    SkipItems = false;
    Appearing = false;
    Hidden = false;
    HasCloseButton = false;
    ResizeBorderHeld = -1;
    BeginCount = 0;
    BeginOrderWithinParent = -1;
    BeginOrderWithinContext = -1;
    PopupId = 0;
    AutoFitFramesX = AutoFitFramesY = -1;
    AutoFitOnlyGrows = false;
    AutoFitChildAxises = 0x00;
    AutoPosLastDirection = HanaLovesMeDir_None;
    HiddenFramesCanSkipItems = HiddenFramesCannotSkipItems = 0;
    SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = HanaLovesMeCond_Always | HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing;
    SetWindowPosVal = SetWindowPosPivot = vsize(FLT_MAX, FLT_MAX);

    LastFrameActive = -1;
    ItemWidthDefault = 0.0f;
    FontWindowScale = 1.0f;
    SettingsIdx = -1;

    DrawList = &DrawListInst;
    DrawList->_OwnerName = Name;
    ParentWindow = NULL;
    RootWindow = NULL;
    RootWindowForTitleBarHighlight = NULL;
    RootWindowForNav = NULL;

    NavLastIds[0] = NavLastIds[1] = 0;
    NavRectRel[0] = NavRectRel[1] = vsrect();
    NavLastChildNavWindow = NULL;
}

HanaLovesMeWindow::~HanaLovesMeWindow()
{
    IM_ASSERT(DrawList == &DrawListInst);
    IM_DELETE(Name);
    for (int i = 0; i != ColumnsStohnly.Size; i++)
        ColumnsStohnly[i].~HanaLovesMeColumns();
}

HanaLovesMeID HanaLovesMeWindow::GetID(const char* str, const char* str_end)
{
    HanaLovesMeID seed = IDStack.back();
    HanaLovesMeID id = ImHashStr(str, str_end ? (str_end - str) : 0, seed);
    HanaLovesMe::KeepAliveID(id);
    return id;
}

HanaLovesMeID HanaLovesMeWindow::GetID(const void* ptr)
{
    HanaLovesMeID seed = IDStack.back();
    HanaLovesMeID id = ImHashData(&ptr, sizeof(void*), seed);
    HanaLovesMe::KeepAliveID(id);
    return id;
}

HanaLovesMeID HanaLovesMeWindow::GetIDNoKeepAlive(const char* str, const char* str_end)
{
    HanaLovesMeID seed = IDStack.back();
    return ImHashStr(str, str_end ? (str_end - str) : 0, seed);
}

HanaLovesMeID HanaLovesMeWindow::GetIDNoKeepAlive(const void* ptr)
{
    HanaLovesMeID seed = IDStack.back();
    return ImHashData(&ptr, sizeof(void*), seed);
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
HanaLovesMeID HanaLovesMeWindow::GetIDFromRectangle(const vsrect & r_abs)
{
    HanaLovesMeID seed = IDStack.back();
    const int r_rel[4] = { (int)(r_abs.Min.x - Pos.x), (int)(r_abs.Min.y - Pos.y), (int)(r_abs.Max.x - Pos.x), (int)(r_abs.Max.y - Pos.y) };
    HanaLovesMeID id = ImHashData(&r_rel, sizeof(r_rel), seed);
    HanaLovesMe::KeepAliveID(id);
    return id;
}

static void SetCurrentWindow(HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.CurrentWindow = window;
    if (window)
        g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

void HanaLovesMe::SetNavID(HanaLovesMeID id, int nav_layer)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(g.NavWindow);
    IM_ASSERT(nav_layer == 0 || nav_layer == 1);
    g.NavId = id;
    g.NavWindow->NavLastIds[nav_layer] = id;
}

void HanaLovesMe::SetNavIDWithRectRel(HanaLovesMeID id, int nav_layer, const vsrect & rect_rel)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    SetNavID(id, nav_layer);
    g.NavWindow->NavRectRel[nav_layer] = rect_rel;
    g.NavMousePosDirty = true;
    g.NavDisableHighlight = false;
    g.NavDisableMouseHover = true;
}

void HanaLovesMe::SetActiveID(HanaLovesMeID id, HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.ActiveIdIsJustActivated = (g.ActiveId != id);
    if (g.ActiveIdIsJustActivated)
    {
        g.ActiveIdTimer = 0.0f;
        g.ActiveIdHasBeenPressed = false;
        g.ActiveIdHasBeenEdited = false;
        if (id != 0)
        {
            g.LastActiveId = id;
            g.LastActiveIdTimer = 0.0f;
        }
    }
    g.ActiveId = id;
    g.ActiveIdAllowNavDirFlags = 0;
    g.ActiveIdBlockNavInputFlags = 0;
    g.ActiveIdAllowOverlap = false;
    g.ActiveIdWindow = window;
    if (id)
    {
        g.ActiveIdIsAlive = id;
        g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id || g.NavJustTabbedId == id || g.NavJustMovedToId == id) ? HanaLovesMeInputSource_Nav : HanaLovesMeInputSource_Mouse;
    }
}

// FIXME-NAV: The existence of SetNavID/SetNavIDWithRectRel/SetFocusID is incredibly messy and confusing and needs some explanation or refactoring.
void HanaLovesMe::SetFocusID(HanaLovesMeID id, HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(id != 0);

    // Assume that SetFocusID() is called in the context where its NavLayer is the current layer, which is the case everywhere we call it.
    const HanaLovesMeNavLayer nav_layer = window->DC.NavLayerCurrent;
    if (g.NavWindow != window)
        g.NavInitRequest = false;
    g.NavId = id;
    g.NavWindow = window;
    g.NavLayer = nav_layer;
    window->NavLastIds[nav_layer] = id;
    if (window->DC.LastItemId == id)
        window->NavRectRel[nav_layer] = vsrect(window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos);

    if (g.ActiveIdSource == HanaLovesMeInputSource_Nav)
        g.NavDisableMouseHover = true;
    else
        g.NavDisableHighlight = true;
}

void HanaLovesMe::ClearActiveID()
{
    SetActiveID(0, NULL);
}

void HanaLovesMe::SetHoveredID(HanaLovesMeID id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.HoveredId = id;
    g.HoveredIdAllowOverlap = false;
    if (id != 0 && g.HoveredIdPreviousFrame != id)
        g.HoveredIdTimer = g.HoveredIdNotActiveTimer = 0.0f;
}

HanaLovesMeID HanaLovesMe::GetHoveredID()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
}

void HanaLovesMe::KeepAliveID(HanaLovesMeID id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.ActiveId == id)
        g.ActiveIdIsAlive = id;
    if (g.ActiveIdPreviousFrame == id)
        g.ActiveIdPreviousFrameIsAlive = true;
}

void HanaLovesMe::MarkItemEdited(HanaLovesMeID id)
{
    // This marking is solely to be able to provide info for IsItemDeactivatedAfterEdit().
    // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need need to fill the data.
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(g.ActiveId == id || g.ActiveId == 0 || g.DragDropActive);
    IM_UNUSED(id); // Avoid unused variable warnings when asserts are compiled out.
    //IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
    g.ActiveIdHasBeenEdited = true;
    g.CurrentWindow->DC.LastItemStatusFlags |= HanaLovesMeItemStatusFlags_Edited;
}

static inline bool IsWindowContentHoverable(HanaLovesMeWindow * window, HanaLovesMeHoveredFlags flags)
{
    // An active popup disable hovering on other windows (apart from its own children)
    // FIXME-OPT: This could be cached/stored within the window.
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.NavWindow)
        if (HanaLovesMeWindow * focused_root_window = g.NavWindow->RootWindow)
            if (focused_root_window->WasActive && focused_root_window != window->RootWindow)
            {
                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
                // NB: The order of those two tests is important because Modal windows are also Popups.
                if (focused_root_window->Flags & HanaLovesMeWindowFlags_Modal)
                    return false;
                if ((focused_root_window->Flags & HanaLovesMeWindowFlags_Popup) && !(flags & HanaLovesMeHoveredFlags_AllowWhenBlockedByPopup))
                    return false;
            }

    return true;
}

// Advance cursor given item size for layout.
void HanaLovesMe::ItemSize(const vsize & size, float text_offset_y)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    if (window->SkipItems)
        return;

    // Always align ourselves on pixel boundaries
    const float line_height = ImMax(window->DC.CurrentLineSize.y, size.y);
    const float text_base_offset = ImMax(window->DC.CurrentLineTextBaseOffset, text_offset_y);
    //if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + vsize(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
    window->DC.CursorPosPrevLine = vsize(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->DC.CursorPos.y = (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y);
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
    //if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

    window->DC.PrevLineSize.y = line_height;
    window->DC.PrevLineTextBaseOffset = text_base_offset;
    window->DC.CurrentLineSize.y = window->DC.CurrentLineTextBaseOffset = 0.0f;

    // Horizontal layout mode
    if (window->DC.LayoutType == HanaLovesMeLayoutType_Horizontal)
        SameLine();
}

void HanaLovesMe::ItemSize(const vsrect & bb, float text_offset_y)
{
    ItemSize(bb.GetSize(), text_offset_y);
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and then use a larger region for drawing/interaction, which is passed to ItemAdd().
bool HanaLovesMe::ItemAdd(const vsrect & bb, HanaLovesMeID id, const vsrect * nav_bb_arg)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;

    if (id != 0)
    {
        // Navigation processing runs prior to clipping early-out
        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests unfortunately, but it is still limited to one window.
        //      it may not scale very well for windows with ten of thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick)
        window->DC.NavLayerActiveMaskNext |= window->DC.NavLayerCurrentMask;
        if (g.NavId == id || g.NavAnyRequest)
            if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
                if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & HanaLovesMeWindowFlags_NavFlattened))
                    NavProcessItem(window, nav_bb_arg ? *nav_bb_arg : bb, id);
    }

    window->DC.LastItemId = id;
    window->DC.LastItemRect = bb;
    window->DC.LastItemStatusFlags = HanaLovesMeItemStatusFlags_None;

#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
    if (id != 0)
        HanaLovesMe_TEST_ENGINE_ITEM_ADD(nav_bb_arg ? *nav_bb_arg : bb, id);
#endif

    // Clipping test
    const bool is_clipped = IsClippedEx(bb, id, false);
    if (is_clipped)
        return false;
    //if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]

    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
    if (IsMouseHoveringRect(bb.Min, bb.Max))
        window->DC.LastItemStatusFlags |= HanaLovesMeItemStatusFlags_HoveredRect;
    return true;
}

// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
bool HanaLovesMe::IsItemHovered(HanaLovesMeHoveredFlags flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    if (g.NavDisableMouseHover && !g.NavDisableHighlight)
        return IsItemFocused();

    // Test for bounding box overlap, as updated as ItemAdd()
    if (!(window->DC.LastItemStatusFlags & HanaLovesMeItemStatusFlags_HoveredRect))
        return false;
    IM_ASSERT((flags & (HanaLovesMeHoveredFlags_RootWindow | HanaLovesMeHoveredFlags_ChildWindows)) == 0);   // Flags not supported by this function

    // Test if we are hovering the right window (our window could be behind another window)
    // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable to use IsItemHovered() after EndChild() itself.
    // Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has been running for a long while.
    //if (g.HoveredWindow != window)
    //    return false;
    if (g.HoveredRootWindow != window->RootWindow && !(flags & HanaLovesMeHoveredFlags_AllowWhenOverlapped))
        return false;

    // Test if another item is active (e.g. being dragged)
    if (!(flags & HanaLovesMeHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)
            return false;

    // Test if interactions on this window are blocked by an active popup or modal
    if (!IsWindowContentHoverable(window, flags))
        return false;

    // Test if the item is disabled
    if ((window->DC.ItemFlags & HanaLovesMeItemFlags_Disabled) && !(flags & HanaLovesMeHoveredFlags_AllowWhenDisabled))
        return false;

    // Special handling for the dummy item after Begin() which represent the title bar or tab.
    // When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.
    if (window->DC.LastItemId == window->MoveId && window->WriteAccessed)
        return false;
    return true;
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
bool HanaLovesMe::ItemHoverable(const vsrect & bb, HanaLovesMeID id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
        return false;

    HanaLovesMeWindow * window = g.CurrentWindow;
    if (g.HoveredWindow != window)
        return false;
    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
        return false;
    if (!IsMouseHoveringRect(bb.Min, bb.Max))
        return false;
    if (g.NavDisableMouseHover || !IsWindowContentHoverable(window, HanaLovesMeHoveredFlags_None))
        return false;
    if (window->DC.ItemFlags & HanaLovesMeItemFlags_Disabled)
        return false;

    SetHoveredID(id);
    return true;
}

bool HanaLovesMe::IsClippedEx(const vsrect & bb, HanaLovesMeID id, bool clip_even_when_logged)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    if (!bb.Overlaps(window->ClipRect))
        if (id == 0 || id != g.ActiveId)
            if (clip_even_when_logged || !g.LogEnabled)
                return true;
    return false;
}

// Process TAB/Shift+TAB. Be mindful that this function may _clear_ the ActiveID when tabbing out.
bool HanaLovesMe::FocusableItemRegister(HanaLovesMeWindow * window, HanaLovesMeID id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    // Increment counters
    const bool is_tab_stop = (window->DC.ItemFlags & (HanaLovesMeItemFlags_NoTabStop | HanaLovesMeItemFlags_Disabled)) == 0;
    window->DC.FocusCounterAll++;
    if (is_tab_stop)
        window->DC.FocusCounterTab++;

    // Process TAB/Shift-TAB to tab *OUT* of the currently focused item.
    // (Note that we can always TAB out of a widget that doesn't allow tabbing in)
    if (g.ActiveId == id && g.FocusTabPressed && !(g.ActiveIdBlockNavInputFlags & (1 << HanaLovesMeNavInput_KeyTab_)) && g.FocusRequestNextWindow == NULL)
    {
        g.FocusRequestNextWindow = window;
        g.FocusRequestNextCounterTab = window->DC.FocusCounterTab + (g.IO.KeyShift ? (is_tab_stop ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.
    }

    // Handle focus requests
    if (g.FocusRequestCurrWindow == window)
    {
        if (window->DC.FocusCounterAll == g.FocusRequestCurrCounterAll)
            return true;
        if (is_tab_stop && window->DC.FocusCounterTab == g.FocusRequestCurrCounterTab)
        {
            g.NavJustTabbedId = id;
            return true;
        }

        // If another item is about to be focused, we clear our own active id
        if (g.ActiveId == id)
            ClearActiveID();
    }

    return false;
}

void HanaLovesMe::FocusableItemUnregister(HanaLovesMeWindow * window)
{
    window->DC.FocusCounterAll--;
    window->DC.FocusCounterTab--;
}

float HanaLovesMe::CalcWrapWidthForPos(const vsize & pos, float wrap_pos_x)
{
    if (wrap_pos_x < 0.0f)
        return 0.0f;

    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    if (wrap_pos_x == 0.0f)
        wrap_pos_x = GetContentRegionMaxScreen().x;
    else if (wrap_pos_x > 0.0f)
        wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space

    return ImMax(wrap_pos_x - pos.x, 1.0f);
}

// IM_ALLOC() == HanaLovesMe::MemAlloc()
void* HanaLovesMe::MemAlloc(size_t size)
{
    if (HanaLovesMeContext * ctx = GHanaLovesMe)
        ctx->IO.MetricsActiveAllocations++;
    return GImAllocatorAllocFunc(size, GImAllocatorUserData);
}

// IM_FREE() == HanaLovesMe::MemFree()
void HanaLovesMe::MemFree(void* ptr)
{
    if (ptr)
        if (HanaLovesMeContext * ctx = GHanaLovesMe)
            ctx->IO.MetricsActiveAllocations--;
    return GImAllocatorFreeFunc(ptr, GImAllocatorUserData);
}

const char* HanaLovesMe::GetClipboardText()
{
    return GHanaLovesMe->IO.GetClipboardTextFn ? GHanaLovesMe->IO.GetClipboardTextFn(GHanaLovesMe->IO.ClipboardUserData) : "";
}

void HanaLovesMe::SetClipboardText(const char* text)
{
    if (GHanaLovesMe->IO.SetClipboardTextFn)
        GHanaLovesMe->IO.SetClipboardTextFn(GHanaLovesMe->IO.ClipboardUserData, text);
}

const char* HanaLovesMe::GetVersion()
{
    return HanaLovesMe_VERSION;
}

// Internal state access - if you want to share HanaLovesMe state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
HanaLovesMeContext* HanaLovesMe::GetCurrentContext()
{
    return GHanaLovesMe;
}

void HanaLovesMe::SetCurrentContext(HanaLovesMeContext * ctx)
{
#ifdef HanaLovesMe_SET_CURRENT_CONTEXT_FUNC
    HanaLovesMe_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
#else
    GHanaLovesMe = ctx;
#endif
}

// Helper function to verify that the type sizes are matching between the calling file's compilation unit and HanaLovesMe.cpp's compilation unit
// If the user has inconsistent compilation settings, HanaLovesMe configuration #define, packing pragma, etc. you may see different structures from what HanaLovesMe.cpp sees which is highly problematic.
bool HanaLovesMe::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert)
{
    bool error = false;
    if (strcmp(version, HanaLovesMe_VERSION) != 0) { error = true; IM_ASSERT(strcmp(version, HanaLovesMe_VERSION) == 0 && "Mismatched version string!"); }
    if (sz_io != sizeof(HanaLovesMeIO)) { error = true; IM_ASSERT(sz_io == sizeof(HanaLovesMeIO) && "Mismatched struct layout!"); }
    if (sz_style != sizeof(HanaLovesMeStyle)) { error = true; IM_ASSERT(sz_style == sizeof(HanaLovesMeStyle) && "Mismatched struct layout!"); }
    if (sz_vec2 != sizeof(vsize)) { error = true; IM_ASSERT(sz_vec2 == sizeof(vsize) && "Mismatched struct layout!"); }
    if (sz_vec4 != sizeof(xuifloatcolor)) { error = true; IM_ASSERT(sz_vec4 == sizeof(xuifloatcolor) && "Mismatched struct layout!"); }
    if (sz_vert != sizeof(ImDrawVert)) { error = true; IM_ASSERT(sz_vert == sizeof(ImDrawVert) && "Mismatched struct layout!"); }
    return !error;
}

void HanaLovesMe::SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void (*free_func)(void* ptr, void* user_data), void* user_data)
{
    GImAllocatorAllocFunc = alloc_func;
    GImAllocatorFreeFunc = free_func;
    GImAllocatorUserData = user_data;
}

HanaLovesMeContext* HanaLovesMe::CreateContext(ImFontAtlas * shared_font_atlas)
{
    HanaLovesMeContext* ctx = IM_NEW(HanaLovesMeContext)(shared_font_atlas);
    if (GHanaLovesMe == NULL)
        SetCurrentContext(ctx);
    Initialize(ctx);
    return ctx;
}

void HanaLovesMe::DestroyContext(HanaLovesMeContext * ctx)
{
    if (ctx == NULL)
        ctx = GHanaLovesMe;
    Shutdown(ctx);
    if (GHanaLovesMe == ctx)
        SetCurrentContext(NULL);
    IM_DELETE(ctx);
}

HanaLovesMeIO & HanaLovesMe::GetIO()
{
    IM_ASSERT(GHanaLovesMe != NULL && "No current context. Did you call HanaLovesMe::CreateContext() and HanaLovesMe::SetCurrentContext() ?");
    return GHanaLovesMe->IO;
}

HanaLovesMeStyle& HanaLovesMe::GetStyle()
{
    IM_ASSERT(GHanaLovesMe != NULL && "No current context. Did you call HanaLovesMe::CreateContext() and HanaLovesMe::SetCurrentContext() ?");
    return GHanaLovesMe->Style;
}

// Same value as passed to the old io.RenderDrawListsFn function. Valid after Render() and until the next call to NewFrame()
ImDrawData* HanaLovesMe::GetDrawData()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.DrawData.Valid ? &g.DrawData : NULL;
}

double HanaLovesMe::GetTime()
{
    return GHanaLovesMe->Time;
}

int HanaLovesMe::GetFrameCount()
{
    return GHanaLovesMe->FrameCount;
}

ImDrawList* HanaLovesMe::GetBackgroundDrawList()
{
    return &GHanaLovesMe->BackgroundDrawList;
}

static ImDrawList* GetForegroundDrawList(HanaLovesMeWindow*)
{
    // This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'docking' branches.
    return &GHanaLovesMe->ForegroundDrawList;
}

ImDrawList* HanaLovesMe::GetForegroundDrawList()
{
    return &GHanaLovesMe->ForegroundDrawList;
}

ImDrawListSharedData* HanaLovesMe::GetDrawListSharedData()
{
    return &GHanaLovesMe->DrawListSharedData;
}

void HanaLovesMe::StartMouseMovingWindow(HanaLovesMeWindow * window)
{
    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
    // This is because we want ActiveId to be set even when the window is not permitted to move.
    HanaLovesMeContext& g = *GHanaLovesMe;
    FocusWindow(window);
    SetActiveID(window->MoveId, window);
    g.NavDisableHighlight = true;
    g.ActiveIdClickOffset = g.IO.MousePos - window->RootWindow->Pos;

    bool can_move_window = true;
    if ((window->Flags & HanaLovesMeWindowFlags_NoMove) || (window->RootWindow->Flags & HanaLovesMeWindowFlags_NoMove))
        can_move_window = false;
    if (can_move_window)
        g.MovingWindow = window;
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
void HanaLovesMe::UpdateMouseMovingWindowNewFrame()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.MovingWindow != NULL)
    {
        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
        KeepAliveID(g.ActiveId);
        IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);
        HanaLovesMeWindow* moving_window = g.MovingWindow->RootWindow;
        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos))
        {
            vsize pos = g.IO.MousePos - g.ActiveIdClickOffset;
            if (moving_window->Pos.x != pos.x || moving_window->Pos.y != pos.y)
            {
                MarkIniSettingsDirty(moving_window);
                SetWindowPos(moving_window, pos, HanaLovesMeCond_Always);
            }
            FocusWindow(g.MovingWindow);
        } else
        {
            ClearActiveID();
            g.MovingWindow = NULL;
        }
    } else
    {
        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
        if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
        {
            KeepAliveID(g.ActiveId);
            if (!g.IO.MouseDown[0])
                ClearActiveID();
        }
    }
}

// Initiate moving window, handle left-click and right-click focus
void HanaLovesMe::UpdateMouseMovingWindowEndFrame()
{
    // Initiate moving window
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.ActiveId != 0 || g.HoveredId != 0)
        return;

    // Unless we just made a window/popup appear
    if (g.NavWindow && g.NavWindow->Appearing)
        return;

    // Click to focus window and start moving (after we're done with all our widgets)
    if (g.IO.MouseClicked[0])
    {
        if (g.HoveredRootWindow != NULL)
        {
            StartMouseMovingWindow(g.HoveredWindow);
            if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(g.HoveredRootWindow->Flags & HanaLovesMeWindowFlags_NoTitleBar))
                if (!g.HoveredRootWindow->TitleBarRect().Contains(g.IO.MouseClickedPos[0]))
                    g.MovingWindow = NULL;
        } else if (g.NavWindow != NULL && GetFrontMostPopupModal() == NULL)
        {
            // Clicking on void disable focus
            FocusWindow(NULL);
        }
    }

    // With right mouse button we close popups without changing focus
    // (The left mouse button path calls FocusWindow which will lead NewFrame->ClosePopupsOverWindow to trigger)
    if (g.IO.MouseClicked[1])
    {
        // Find the top-most window between HoveredWindow and the front most Modal Window.
        // This is where we can trim the popup stack.
        HanaLovesMeWindow* modal = GetFrontMostPopupModal();
        bool hovered_window_above_modal = false;
        if (modal == NULL)
            hovered_window_above_modal = true;
        for (int i = g.Windows.Size - 1; i >= 0 && hovered_window_above_modal == false; i--)
        {
            HanaLovesMeWindow* window = g.Windows[i];
            if (window == modal)
                break;
            if (window == g.HoveredWindow)
                hovered_window_above_modal = true;
        }
        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal);
    }
}

static bool IsWindowActiveAndVisible(HanaLovesMeWindow * window)
{
    return (window->Active) && (!window->Hidden);
}

static void HanaLovesMe::UpdateMouseInputs()
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
    if (IsMousePosValid(&g.IO.MousePos))
        g.IO.MousePos = g.LastValidMousePos = ImFloor(g.IO.MousePos);

    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
    if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MousePosPrev))
        g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;
    else
        g.IO.MouseDelta = vsize(0.0f, 0.0f);
    if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)
        g.NavDisableMouseHover = false;

    g.IO.MousePosPrev = g.IO.MousePos;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;
        g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;
        g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];
        g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;
        g.IO.MouseDoubleClicked[i] = false;
        if (g.IO.MouseClicked[i])
        {
            if ((float)(g.Time - g.IO.MouseClickedTime[i]) < g.IO.MouseDoubleClickTime)
            {
                vsize delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : vsize(0.0f, 0.0f);
                if (ImLengthSqr(delta_from_click_pos) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)
                    g.IO.MouseDoubleClicked[i] = true;
                g.IO.MouseClickedTime[i] = -FLT_MAX;    // so the third click isn't turned into a double-click
            } else
            {
                g.IO.MouseClickedTime[i] = g.Time;
            }
            g.IO.MouseClickedPos[i] = g.IO.MousePos;
            g.IO.MouseDragMaxDistanceAbs[i] = vsize(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;
        } else if (g.IO.MouseDown[i])
        {
            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
            vsize delta_from_click_pos = IsMousePosValid(&g.IO.MousePos) ? (g.IO.MousePos - g.IO.MouseClickedPos[i]) : vsize(0.0f, 0.0f);
            g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
            g.IO.MouseDragMaxDistanceAbs[i].x = ImMax(g.IO.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0f ? -delta_from_click_pos.x : delta_from_click_pos.x);
            g.IO.MouseDragMaxDistanceAbs[i].y = ImMax(g.IO.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0f ? -delta_from_click_pos.y : delta_from_click_pos.y);
        }
        if (g.IO.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
            g.NavDisableMouseHover = false;
    }
}

void HanaLovesMe::UpdateMouseWheel()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (!g.HoveredWindow || g.HoveredWindow->Collapsed)
        return;
    if (g.IO.MouseWheel == 0.0f && g.IO.MouseWheelH == 0.0f)
        return;
    HanaLovesMeWindow * window = g.HoveredWindow;

    // Zoom / Scale window
    // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
    if (g.IO.MouseWheel != 0.0f && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
    {
        const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
        const float scale = new_font_scale / window->FontWindowScale;
        window->FontWindowScale = new_font_scale;
        if (!(window->Flags & HanaLovesMeWindowFlags_ChildWindow))
        {
            const vsize offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
            window->Pos = ImFloor(window->Pos + offset);
            window->Size = ImFloor(window->Size * scale);
            window->SizeFull = ImFloor(window->SizeFull * scale);
        }
        return;
    }

    // Mouse wheel scrolling
    // If a child window has the HanaLovesMeWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent (unless either HanaLovesMeWindowFlags_NoInputs or HanaLovesMeWindowFlags_NoScrollbar are also set).
    while ((window->Flags & HanaLovesMeWindowFlags_ChildWindow) && (window->Flags & HanaLovesMeWindowFlags_NoScrollWithMouse) && !(window->Flags & HanaLovesMeWindowFlags_NoScrollbar) && !(window->Flags & HanaLovesMeWindowFlags_NoMouseInputs) && window->ParentWindow)
        window = window->ParentWindow;
    const bool scroll_allowed = !(window->Flags & HanaLovesMeWindowFlags_NoScrollWithMouse) && !(window->Flags & HanaLovesMeWindowFlags_NoMouseInputs);
    if (scroll_allowed && (g.IO.MouseWheel != 0.0f || g.IO.MouseWheelH != 0.0f) && !g.IO.KeyCtrl)
    {
        vsize max_step = (window->ContentsRegionRect.GetSize() + window->WindowPadding * 2.0f) * 0.67f;

        // Vertical Mouse Wheel Scrolling (hold Shift to scroll horizontally)
        if (g.IO.MouseWheel != 0.0f && !g.IO.KeyShift)
        {
            float scroll_step = ImFloor(ImMin(5 * window->CalcFontSize(), max_step.y));
            SetWindowScrollY(window, window->Scroll.y - g.IO.MouseWheel * scroll_step);
        } else if (g.IO.MouseWheel != 0.0f && g.IO.KeyShift)
        {
            float scroll_step = ImFloor(ImMin(2 * window->CalcFontSize(), max_step.x));
            SetWindowScrollX(window, window->Scroll.x - g.IO.MouseWheel * scroll_step);
        }

        // Horizontal Mouse Wheel Scrolling (for hardware that supports it)
        if (g.IO.MouseWheelH != 0.0f && !g.IO.KeyShift)
        {
            float scroll_step = ImFloor(ImMin(2 * window->CalcFontSize(), max_step.x));
            SetWindowScrollX(window, window->Scroll.x - g.IO.MouseWheelH * scroll_step);
        }
    }
}

// The reason this is exposed in HanaLovesMe_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (HanaLovesMe vs HanaLovesMe+app)
void HanaLovesMe::UpdateHoveredWindowAndCaptureFlags()
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    // Find the window hovered by mouse:
    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
    FindHoveredWindow();

    // Modal windows prevents cursor from hovering behind them.
    HanaLovesMeWindow* modal_window = GetFrontMostPopupModal();
    if (modal_window)
        if (g.HoveredRootWindow && !IsWindowChildOf(g.HoveredRootWindow, modal_window))
            g.HoveredRootWindow = g.HoveredWindow = NULL;

    // Disabled mouse?
    if (g.IO.ConfigFlags & HanaLovesMeConfigFlags_NoMouse)
        g.HoveredWindow = g.HoveredRootWindow = NULL;

    // We track click ownership. When clicked outside of a window the click is owned by the application and won't report hovering nor request capture even while dragging over our windows afterward.
    int mouse_earliest_button_down = -1;
    bool mouse_any_down = false;
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
    {
        if (g.IO.MouseClicked[i])
            g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());
        mouse_any_down |= g.IO.MouseDown[i];
        if (g.IO.MouseDown[i])
            if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[mouse_earliest_button_down])
                mouse_earliest_button_down = i;
    }
    const bool mouse_avail_to_HanaLovesMe = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];

    // If mouse was first clicked outside of HanaLovesMe bounds we also cancel out hovering.
    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
    const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & HanaLovesMeDragDropFlags_SourceExtern) != 0;
    if (!mouse_avail_to_HanaLovesMe && !mouse_dragging_extern_payload)
        g.HoveredWindow = g.HoveredRootWindow = NULL;

    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to HanaLovesMe, false = dispatch mouse info to HanaLovesMe + app)
    if (g.WantCaptureMouseNextFrame != -1)
        g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);
    else
        g.IO.WantCaptureMouse = (mouse_avail_to_HanaLovesMe && (g.HoveredWindow != NULL || mouse_any_down)) || (!g.OpenPopupStack.empty());

    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to HanaLovesMe, false = dispatch keyboard info to HanaLovesMe + app)
    if (g.WantCaptureKeyboardNextFrame != -1)
        g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
    else
        g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
    if (g.IO.NavActive && (g.IO.ConfigFlags & HanaLovesMeConfigFlags_NavEnableKeyboard) && !(g.IO.ConfigFlags & HanaLovesMeConfigFlags_NavNoCaptureKeyboard))
        g.IO.WantCaptureKeyboard = true;

    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
    g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
}

void HanaLovesMe::NewFrame()
{
    IM_ASSERT(GHanaLovesMe != NULL && "No current context. Did you call HanaLovesMe::CreateContext() and HanaLovesMe::SetCurrentContext() ?");
    HanaLovesMeContext & g = *GHanaLovesMe;

#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
    HanaLovesMeTestEngineHook_PreNewFrame(&g);
#endif

    // Check user data
    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
    IM_ASSERT(g.Initialized);
    IM_ASSERT((g.IO.DeltaTime > 0.0f || g.FrameCount == 0) && "Need a positive DeltaTime!");
    IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount) && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
    IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f && "Invalid DisplaySize value!");
    IM_ASSERT(g.IO.Fonts->Fonts.Size > 0 && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
    IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded() && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
    IM_ASSERT(g.Style.CurveTessellationTol > 0.0f && "Invalid style setting!");
    IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f && "Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)!");
    IM_ASSERT(g.Style.WindowMinSize.x >= 1.0f && g.Style.WindowMinSize.y >= 1.0f && "Invalid style setting.");
    for (int n = 0; n < HanaLovesMeKey_COUNT; n++)
        IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < IM_ARRAYSIZE(g.IO.KeysDown) && "io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)");

    // Perform simple check: required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was only recently added in 1.60 WIP)
    if (g.IO.ConfigFlags & HanaLovesMeConfigFlags_NavEnableKeyboard)
        IM_ASSERT(g.IO.KeyMap[HanaLovesMeKey_Space] != -1 && "HanaLovesMeKey_Space is not mapped, required for keyboard navigation.");

    // Perform simple check: the beta io.ConfigWindowsResizeFromEdges option requires back-end to honor mouse cursor changes and set the HanaLovesMeBackendFlags_HasMouseCursors flag accordingly.
    if (g.IO.ConfigWindowsResizeFromEdges && !(g.IO.BackendFlags & HanaLovesMeBackendFlags_HasMouseCursors))
        g.IO.ConfigWindowsResizeFromEdges = false;

    // Load settings on first frame (if not explicitly loaded manually before)
    if (!g.SettingsLoaded)
    {
        IM_ASSERT(g.SettingsWindows.empty());
        if (g.IO.IniFilename)
            LoadIniSettingsFromDisk(g.IO.IniFilename);
        g.SettingsLoaded = true;
    }

    // Save settings (with a delay after the last modification, so we don't spam disk too much)
    if (g.SettingsDirtyTimer > 0.0f)
    {
        g.SettingsDirtyTimer -= g.IO.DeltaTime;
        if (g.SettingsDirtyTimer <= 0.0f)
        {
            if (g.IO.IniFilename != NULL)
                SaveIniSettingsToDisk(g.IO.IniFilename);
            else
                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
            g.SettingsDirtyTimer = 0.0f;
        }
    }

    g.Time += g.IO.DeltaTime;
    g.FrameScopeActive = true;
    g.FrameCount += 1;
    g.TooltipOverrideCount = 0;
    g.WindowsActiveCount = 0;

    // Setup current font and draw list shared data
    g.IO.Fonts->Locked = true;
    SetCurrentFont(GetDefaultFont());
    IM_ASSERT(g.Font->IsLoaded());
    g.DrawListSharedData.ClipRectFullscreen = xuifloatcolor(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;

    g.BackgroundDrawList.Clear();
    g.BackgroundDrawList.PushTextureID(g.IO.Fonts->TexID);
    g.BackgroundDrawList.PushClipRectFullScreen();
    g.BackgroundDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

    g.ForegroundDrawList.Clear();
    g.ForegroundDrawList.PushTextureID(g.IO.Fonts->TexID);
    g.ForegroundDrawList.PushClipRectFullScreen();
    g.ForegroundDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
    g.DrawData.Clear();

    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId)
        KeepAliveID(g.DragDropPayload.SourceId);

    // Clear reference to active widget if the widget isn't alive anymore
    if (!g.HoveredIdPreviousFrame)
        g.HoveredIdTimer = 0.0f;
    if (!g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId))
        g.HoveredIdNotActiveTimer = 0.0f;
    if (g.HoveredId)
        g.HoveredIdTimer += g.IO.DeltaTime;
    if (g.HoveredId && g.ActiveId != g.HoveredId)
        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
    g.HoveredIdPreviousFrame = g.HoveredId;
    g.HoveredId = 0;
    g.HoveredIdAllowOverlap = false;
    if (g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)
        ClearActiveID();
    if (g.ActiveId)
        g.ActiveIdTimer += g.IO.DeltaTime;
    g.LastActiveIdTimer += g.IO.DeltaTime;
    g.ActiveIdPreviousFrame = g.ActiveId;
    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
    g.ActiveIdPreviousFrameHasBeenEdited = g.ActiveIdHasBeenEdited;
    g.ActiveIdIsAlive = 0;
    g.ActiveIdPreviousFrameIsAlive = false;
    g.ActiveIdIsJustActivated = false;
    if (g.ScalarAsInputTextId && g.ActiveId != g.ScalarAsInputTextId)
        g.ScalarAsInputTextId = 0;

    // Drag and drop
    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
    g.DragDropAcceptIdCurr = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropWithinSourceOrTarget = false;

    // Update keyboard input state
    memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)
        g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;

    // Update gamepad/keyboard directional navigation
    NavUpdate();

    // Update mouse input state
    UpdateMouseInputs();

    // Calculate frame-rate for the user, as a purely luxurious feature
    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0f) ? (1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame))) : FLT_MAX;

    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
    UpdateMouseMovingWindowNewFrame();
    UpdateHoveredWindowAndCaptureFlags();

    // Background darkening/whitening
    if (GetFrontMostPopupModal() != NULL || (g.NavWindowingTarget != NULL && g.NavWindowingHighlightAlpha > 0.0f))
        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0f, 1.0f);
    else
        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0f, 0.0f);

    g.MouseCursor = HanaLovesMeMouseCursor_Arrow;
    g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
    g.PlatformImePos = vsize(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default

    // Mouse wheel scrolling, scale
    UpdateMouseWheel();

    // Pressing TAB activate widget focus
    g.FocusTabPressed = (g.NavWindow && g.NavWindow->Active && !(g.NavWindow->Flags & HanaLovesMeWindowFlags_NoNavInputs) && !g.IO.KeyCtrl && IsKeyPressedMap(HanaLovesMeKey_Tab));
    if (g.ActiveId == 0 && g.FocusTabPressed)
    {
        // Note that SetKeyboardFocusHere() sets the Next fields mid-frame. To be consistent we also
        // manipulate the Next fields even, even though they will be turned into Curr fields by the code below.
        g.FocusRequestNextWindow = g.NavWindow;
        g.FocusRequestNextCounterAll = INT_MAX;
        if (g.NavId != 0 && g.NavIdTabCounter != INT_MAX)
            g.FocusRequestNextCounterTab = g.NavIdTabCounter + 1 + (g.IO.KeyShift ? -1 : 1);
        else
            g.FocusRequestNextCounterTab = g.IO.KeyShift ? -1 : 0;
    }

    // Turn queued focus request into current one
    g.FocusRequestCurrWindow = NULL;
    g.FocusRequestCurrCounterAll = g.FocusRequestCurrCounterTab = INT_MAX;
    if (g.FocusRequestNextWindow != NULL)
    {
        HanaLovesMeWindow* window = g.FocusRequestNextWindow;
        g.FocusRequestCurrWindow = window;
        if (g.FocusRequestNextCounterAll != INT_MAX && window->DC.FocusCounterAll != -1)
            g.FocusRequestCurrCounterAll = ImModPositive(g.FocusRequestNextCounterAll, window->DC.FocusCounterAll + 1);
        if (g.FocusRequestNextCounterTab != INT_MAX && window->DC.FocusCounterTab != -1)
            g.FocusRequestCurrCounterTab = ImModPositive(g.FocusRequestNextCounterTab, window->DC.FocusCounterTab + 1);
        g.FocusRequestNextWindow = NULL;
        g.FocusRequestNextCounterAll = g.FocusRequestNextCounterTab = INT_MAX;
    }

    g.NavIdTabCounter = INT_MAX;

    // Mark all windows as not visible
    IM_ASSERT(g.WindowsFocusOrder.Size == g.Windows.Size);
    for (int i = 0; i != g.Windows.Size; i++)
    {
        HanaLovesMeWindow* window = g.Windows[i];
        window->WasActive = window->Active;
        window->BeginCount = 0;
        window->Active = false;
        window->WriteAccessed = false;
    }

    // Closing the focused window restore focus to the first active root window in descending z-order
    if (g.NavWindow && !g.NavWindow->WasActive)
        FocusPreviousWindowIgnoringOne(NULL);

    // No window should be open at the beginning of the frame.
    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
    g.CurrentWindowStack.resize(0);
    g.BeginPopupStack.resize(0);
    ClosePopupsOverWindow(g.NavWindow);

    // Create implicit/fallback window - which we will only render it if the user has added something to it.
    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
    // This fallback is particularly important as it avoid HanaLovesMe:: calls from crashing.
    SetNextWindowSize(vsize(400, 400), HanaLovesMeCond_FirstUseEver);
    Begin("Debug##Default");
    g.FrameScopePushedImplicitWindow = true;

#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
    HanaLovesMeTestEngineHook_PostNewFrame(&g);
#endif
}

void HanaLovesMe::Initialize(HanaLovesMeContext * context)
{
    HanaLovesMeContext& g = *context;
    IM_ASSERT(!g.Initialized && !g.SettingsLoaded);

    // Add .ini handle for HanaLovesMeWindow type
    HanaLovesMeSettingsHandler ini_handler;
    ini_handler.TypeName = "Window";
    ini_handler.TypeHash = ImHashStr("Window", 0);
    ini_handler.ReadOpenFn = SettingsHandlerWindow_ReadOpen;
    ini_handler.ReadLineFn = SettingsHandlerWindow_ReadLine;
    ini_handler.WriteAllFn = SettingsHandlerWindow_WriteAll;
    g.SettingsHandlers.push_back(ini_handler);

    g.Initialized = true;
}

// This function is merely here to free heap allocations.
void HanaLovesMe::Shutdown(HanaLovesMeContext * context)
{
    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
    HanaLovesMeContext& g = *context;
    if (g.IO.Fonts && g.FontAtlasOwnedByContext)
    {
        g.IO.Fonts->Locked = false;
        IM_DELETE(g.IO.Fonts);
    }
    g.IO.Fonts = NULL;

    // Cleanup of other data are conditional on actually having initialized HanaLovesMe.
    if (!g.Initialized)
        return;

    // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
    if (g.SettingsLoaded && g.IO.IniFilename != NULL)
    {
        HanaLovesMeContext* backup_context = GHanaLovesMe;
        SetCurrentContext(context);
        SaveIniSettingsToDisk(g.IO.IniFilename);
        SetCurrentContext(backup_context);
    }

    // Clear everything else
    for (int i = 0; i < g.Windows.Size; i++)
        IM_DELETE(g.Windows[i]);
    g.Windows.clear();
    g.WindowsFocusOrder.clear();
    g.WindowsSortBuffer.clear();
    g.CurrentWindow = NULL;
    g.CurrentWindowStack.clear();
    g.WindowsById.Clear();
    g.NavWindow = NULL;
    g.HoveredWindow = g.HoveredRootWindow = NULL;
    g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow = NULL;
    g.MovingWindow = NULL;
    g.ColorModifiers.clear();
    g.StyleModifiers.clear();
    g.FontStack.clear();
    g.OpenPopupStack.clear();
    g.BeginPopupStack.clear();
    g.DrawDataBuilder.ClearFreeMemory();
    g.BackgroundDrawList.ClearFreeMemory();
    g.ForegroundDrawList.ClearFreeMemory();
    g.PrivateClipboard.clear();
    g.InputTextState.ClearFreeMemory();

    for (int i = 0; i < g.SettingsWindows.Size; i++)
        IM_DELETE(g.SettingsWindows[i].Name);
    g.SettingsWindows.clear();
    g.SettingsHandlers.clear();

    if (g.LogFile && g.LogFile != stdout)
    {
        fclose(g.LogFile);
        g.LogFile = NULL;
    }
    g.LogBuffer.clear();

    g.Initialized = false;
}

// FIXME: Add a more explicit sort order in the window structure.
static int HanaLovesMe_CDECL ChildWindowComparer(const void* lhs, const void* rhs)
{
    const HanaLovesMeWindow* const a = *(const HanaLovesMeWindow * const*)lhs;
    const HanaLovesMeWindow* const b = *(const HanaLovesMeWindow * const*)rhs;
    if (int d = (a->Flags & HanaLovesMeWindowFlags_Popup) - (b->Flags & HanaLovesMeWindowFlags_Popup))
        return d;
    if (int d = (a->Flags & HanaLovesMeWindowFlags_Tooltip) - (b->Flags & HanaLovesMeWindowFlags_Tooltip))
        return d;
    return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
}

static void AddWindowToSortBuffer(ImVector<HanaLovesMeWindow*> * out_sorted_windows, HanaLovesMeWindow * window)
{
    out_sorted_windows->push_back(window);
    if (window->Active)
    {
        int count = window->DC.ChildWindows.Size;
        if (count > 1)
            ImQsort(window->DC.ChildWindows.begin(), (size_t)count, sizeof(HanaLovesMeWindow*), ChildWindowComparer);
        for (int i = 0; i < count; i++)
        {
            HanaLovesMeWindow* child = window->DC.ChildWindows[i];
            if (child->Active)
                AddWindowToSortBuffer(out_sorted_windows, child);
        }
    }
}

static void AddDrawListToDrawData(ImVector<ImDrawList*> * out_list, ImDrawList * draw_list)
{
    if (draw_list->CmdBuffer.empty())
        return;

    // Remove trailing command if unused
    ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();
    if (last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL)
    {
        draw_list->CmdBuffer.pop_back();
        if (draw_list->CmdBuffer.empty())
            return;
    }

    // Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc. May trigger for you if you are using PrimXXX functions incorrectly.
    IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
    IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
    IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);

    // Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
    // If this assert triggers because you are drawing lots of stuff manually:
    // A) Make sure you are coarse clipping, because ImDrawList let all your vertices pass. You can use the Metrics window to inspect draw list contents.
    // B) If you need/want meshes with more than 64K vertices, uncomment the '#define ImDrawIdx unsigned int' line in imconfig.h to set the index size to 4 bytes.
    //    You'll need to handle the 4-bytes indices to your renderer. For example, the OpenGL example code detect index size at compile-time by doing:
    //      glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
    //    Your own engine or render API may use different parameters or function calls to specify index sizes. 2 and 4 bytes indices are generally supported by most API.
    // C) If for some reason you cannot use 4 bytes indices or don't want to, a workaround is to call BeginChild()/EndChild() before reaching the 64K limit to split your draw commands in multiple draw lists.
    if (sizeof(ImDrawIdx) == 2)
        IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");

    out_list->push_back(draw_list);
}

static void AddWindowToDrawData(ImVector<ImDrawList*> * out_render_list, HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.IO.MetricsRenderWindows++;
    AddDrawListToDrawData(out_render_list, window->DrawList);
    for (int i = 0; i < window->DC.ChildWindows.Size; i++)
    {
        HanaLovesMeWindow* child = window->DC.ChildWindows[i];
        if (IsWindowActiveAndVisible(child)) // clipped children may have been marked not active
            AddWindowToDrawData(out_render_list, child);
    }
}

// Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)
static void AddRootWindowToDrawData(HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (window->Flags & HanaLovesMeWindowFlags_Tooltip)
        AddWindowToDrawData(&g.DrawDataBuilder.Layers[1], window);
    else
        AddWindowToDrawData(&g.DrawDataBuilder.Layers[0], window);
}

void ImDrawDataBuilder::FlattenIntoSingleLayer()
{
    int n = Layers[0].Size;
    int size = n;
    for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)
        size += Layers[i].Size;
    Layers[0].resize(size);
    for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)
    {
        ImVector<ImDrawList*>& layer = Layers[layer_n];
        if (layer.empty())
            continue;
        memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));
        n += layer.Size;
        layer.resize(0);
    }
}

static void SetupDrawData(ImVector<ImDrawList*> * draw_lists, ImDrawData * draw_data)
{
    HanaLovesMeIO& io = HanaLovesMe::GetIO();
    draw_data->Valid = true;
    draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;
    draw_data->CmdListsCount = draw_lists->Size;
    draw_data->TotalVtxCount = draw_data->TotalIdxCount = 0;
    draw_data->DisplayPos = vsize(0.0f, 0.0f);
    draw_data->DisplaySize = io.DisplaySize;
    draw_data->FramebufferScale = io.DisplayFramebufferScale;
    for (int n = 0; n < draw_lists->Size; n++)
    {
        draw_data->TotalVtxCount += draw_lists->Data[n]->VtxBuffer.Size;
        draw_data->TotalIdxCount += draw_lists->Data[n]->IdxBuffer.Size;
    }
}

// When using this function it is sane to ensure that float are perfectly rounded to integer values, to that e.g. (int)(max.x-min.x) in user's render produce correct result.
void HanaLovesMe::PushClipRect(const vsize & clip_rect_min, const vsize & clip_rect_max, bool intersect_with_current_clip_rect)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

void HanaLovesMe::PopClipRect()
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DrawList->PopClipRect();
    window->ClipRect = window->DrawList->_ClipRectStack.back();
}

// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
void HanaLovesMe::EndFrame()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(g.Initialized);
    if (g.FrameCountEnded == g.FrameCount)          // Don't process EndFrame() multiple times.
        return;
    IM_ASSERT(g.FrameScopeActive && "Forgot to call HanaLovesMe::NewFrame()?");

    // Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
    if (g.IO.ImeSetInputScreenPosFn && (g.PlatformImeLastPos.x == FLT_MAX || ImLengthSqr(g.PlatformImeLastPos - g.PlatformImePos) > 0.0001f))
    {
        g.IO.ImeSetInputScreenPosFn((int)g.PlatformImePos.x, (int)g.PlatformImePos.y);
        g.PlatformImeLastPos = g.PlatformImePos;
    }

    // Report when there is a mismatch of Begin/BeginChild vs End/EndChild calls. Important: Remember that the Begin/BeginChild API requires you
    // to always call End/EndChild even if Begin/BeginChild returns false! (this is unfortunately inconsistent with most other Begin* API).
    if (g.CurrentWindowStack.Size != 1)
    {
        if (g.CurrentWindowStack.Size > 1)
        {
            IM_ASSERT(g.CurrentWindowStack.Size == 1 && "Mismatched Begin/BeginChild vs End/EndChild calls: did you forget to call End/EndChild?");
            while (g.CurrentWindowStack.Size > 1) // FIXME-ERRORHANDLING
                End();
        } else
        {
            IM_ASSERT(g.CurrentWindowStack.Size == 1 && "Mismatched Begin/BeginChild vs End/EndChild calls: did you call End/EndChild too much?");
        }
    }

    // Hide implicit/fallback "Debug" window if it hasn't been used
    g.FrameScopePushedImplicitWindow = false;
    if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
        g.CurrentWindow->Active = false;
    End();

    // Show CTRL+TAB list window
    if (g.NavWindowingTarget)
        NavUpdateWindowingList();

    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
    if (g.DragDropActive)
    {
        bool is_delivered = g.DragDropPayload.Delivery;
        bool is_elapsed = (g.DragDropPayload.DataFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & HanaLovesMeDragDropFlags_SourceAutoExpirePayload) || !IsMouseDown(g.DragDropMouseButton));
        if (is_delivered || is_elapsed)
            ClearDragDrop();
    }

    // Drag and Drop: Fallback for source tooltip. This is not ideal but better than nothing.
    if (g.DragDropActive && g.DragDropSourceFrameCount < g.FrameCount)
    {
        g.DragDropWithinSourceOrTarget = true;
        SetTooltip("...");
        g.DragDropWithinSourceOrTarget = false;
    }

    // End frame
    g.FrameScopeActive = false;
    g.FrameCountEnded = g.FrameCount;

    // Initiate moving window + handle left-click and right-click focus
    UpdateMouseMovingWindowEndFrame();

    // Sort the window list so that all child windows are after their parent
    // We cannot do that on FocusWindow() because childs may not exist yet
    g.WindowsSortBuffer.resize(0);
    g.WindowsSortBuffer.reserve(g.Windows.Size);
    for (int i = 0; i != g.Windows.Size; i++)
    {
        HanaLovesMeWindow* window = g.Windows[i];
        if (window->Active && (window->Flags & HanaLovesMeWindowFlags_ChildWindow))       // if a child is active its parent will add it
            continue;
        AddWindowToSortBuffer(&g.WindowsSortBuffer, window);
    }

    // This usually assert if there is a mismatch between the HanaLovesMeWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
    IM_ASSERT(g.Windows.Size == g.WindowsSortBuffer.Size);
    g.Windows.swap(g.WindowsSortBuffer);
    g.IO.MetricsActiveWindows = g.WindowsActiveCount;

    // Unlock font atlas
    g.IO.Fonts->Locked = false;

    // Clear Input data for next frame
    g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
    g.IO.InputQueueCharacters.resize(0);
    memset(g.IO.NavInputs, 0, sizeof(g.IO.NavInputs));
}

void HanaLovesMe::Render()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(g.Initialized);

    if (g.FrameCountEnded != g.FrameCount)
        EndFrame();
    g.FrameCountRendered = g.FrameCount;

    // Gather ImDrawList to render (for each active window)
    g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = g.IO.MetricsRenderWindows = 0;
    g.DrawDataBuilder.Clear();
    if (!g.BackgroundDrawList.VtxBuffer.empty())
        AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.BackgroundDrawList);

    HanaLovesMeWindow * windows_to_render_front_most[2];
    windows_to_render_front_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & HanaLovesMeWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget->RootWindow : NULL;
    windows_to_render_front_most[1] = g.NavWindowingTarget ? g.NavWindowingList : NULL;
    for (int n = 0; n != g.Windows.Size; n++)
    {
        HanaLovesMeWindow* window = g.Windows[n];
        if (IsWindowActiveAndVisible(window) && (window->Flags & HanaLovesMeWindowFlags_ChildWindow) == 0 && window != windows_to_render_front_most[0] && window != windows_to_render_front_most[1])
            AddRootWindowToDrawData(window);
    }
    for (int n = 0; n < IM_ARRAYSIZE(windows_to_render_front_most); n++)
        if (windows_to_render_front_most[n] && IsWindowActiveAndVisible(windows_to_render_front_most[n])) // NavWindowingTarget is always temporarily displayed as the front-most window
            AddRootWindowToDrawData(windows_to_render_front_most[n]);
    g.DrawDataBuilder.FlattenIntoSingleLayer();

    // Draw software mouse cursor if requested
    if (g.IO.MouseDrawCursor)
        RenderMouseCursor(&g.ForegroundDrawList, g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor);

    if (!g.ForegroundDrawList.VtxBuffer.empty())
        AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.ForegroundDrawList);

    // Setup ImDrawData structure for end-user
    SetupDrawData(&g.DrawDataBuilder.Layers[0], &g.DrawData);
    g.IO.MetricsRenderVertices = g.DrawData.TotalVtxCount;
    g.IO.MetricsRenderIndices = g.DrawData.TotalIdxCount;

    // (Legacy) Call the Render callback function. The current prefer way is to let the user retrieve GetDrawData() and call the render function themselves.
#ifndef HanaLovesMe_DISABLE_OBSOLETE_FUNCTIONS
    if (g.DrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL)
        g.IO.RenderDrawListsFn(&g.DrawData);
#endif
}

// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return vsize(0.0f, GHanaLovesMe->FontSize)
vsize HanaLovesMe::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    const char* text_display_end;
    if (hide_text_after_double_hash)
        text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
    else
        text_display_end = text_end;

    ImFont* font = g.Font;
    const float font_size = g.FontSize;
    if (text == text_display_end)
        return vsize(0.0f, font_size);
    vsize text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

    // Round
    text_size.x = (float)(int)(text_size.x + 0.95f);

    return text_size;
}

// Helper to calculate coarse clipping of large list of evenly sized items.
// NB: Prefer using the HanaLovesMeListClipper higher-level helper if you can! Read comments and instructions there on how those use this sort of pattern.
// NB: 'items_count' is only used to clamp the result, if you don't know your count you can use INT_MAX
void HanaLovesMe::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    if (g.LogEnabled)
    {
        // If logging is active, do not perform any clipping
        *out_items_display_start = 0;
        *out_items_display_end = items_count;
        return;
    }
    if (window->SkipItems)
    {
        *out_items_display_start = *out_items_display_end = 0;
        return;
    }

    // We create the union of the ClipRect and the NavScoringRect which at worst should be 1 page away from ClipRect
    vsrect unclipped_rect = window->ClipRect;
    if (g.NavMoveRequest)
        unclipped_rect.Add(g.NavScoringRectScreen);

    const vsize pos = window->DC.CursorPos;
    int start = (int)((unclipped_rect.Min.y - pos.y) / items_height);
    int end = (int)((unclipped_rect.Max.y - pos.y) / items_height);

    // When performing a navigation request, ensure we have one item extra in the direction we are moving to
    if (g.NavMoveRequest && g.NavMoveClipDir == HanaLovesMeDir_Up)
        start--;
    if (g.NavMoveRequest && g.NavMoveClipDir == HanaLovesMeDir_Down)
        end++;

    start = ImClamp(start, 0, items_count);
    end = ImClamp(end + 1, start, items_count);
    *out_items_display_start = start;
    *out_items_display_end = end;
}

// Find window given position, search front-to-back
// FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programatically
// with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
// called, aka before the next Begin(). Moving window isn't affected.
static void FindHoveredWindow()
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    HanaLovesMeWindow* hovered_window = NULL;
    if (g.MovingWindow && !(g.MovingWindow->Flags & HanaLovesMeWindowFlags_NoMouseInputs))
        hovered_window = g.MovingWindow;

    vsize padding_regular = g.Style.TouchExtraPadding;
    vsize padding_for_resize_from_edges = g.IO.ConfigWindowsResizeFromEdges ? ImMax(g.Style.TouchExtraPadding, vsize(WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS)) : padding_regular;
    for (int i = g.Windows.Size - 1; i >= 0; i--)
    {
        HanaLovesMeWindow* window = g.Windows[i];
        if (!window->Active || window->Hidden)
            continue;
        if (window->Flags & HanaLovesMeWindowFlags_NoMouseInputs)
            continue;

        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
        vsrect bb(window->OuterRectClipped);
        if ((window->Flags & HanaLovesMeWindowFlags_ChildWindow) || (window->Flags & HanaLovesMeWindowFlags_NoResize))
            bb.Expand(padding_regular);
        else
            bb.Expand(padding_for_resize_from_edges);
        if (!bb.Contains(g.IO.MousePos))
            continue;

        // Those seemingly unnecessary extra tests are because the code here is a little different in viewport/docking branches.
        if (hovered_window == NULL)
            hovered_window = window;
        if (hovered_window)
            break;
    }

    g.HoveredWindow = hovered_window;
    g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;

}

// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
bool HanaLovesMe::IsMouseHoveringRect(const vsize & r_min, const vsize & r_max, bool clip)
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    // Clip
    vsrect rect_clipped(r_min, r_max);
    if (clip)
        rect_clipped.ClipWith(g.CurrentWindow->ClipRect);

    // Expand for touch input
    const vsrect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);
    if (!rect_for_touch.Contains(g.IO.MousePos))
        return false;
    return true;
}

int HanaLovesMe::GetKeyIndex(HanaLovesMeKey HanaLovesMe_key)
{
    IM_ASSERT(HanaLovesMe_key >= 0 && HanaLovesMe_key < HanaLovesMeKey_COUNT);
    return GHanaLovesMe->IO.KeyMap[HanaLovesMe_key];
}

// Note that HanaLovesMe doesn't know the semantic of each entry of io.KeysDown[]. Use your own indices/enums according to how your back-end/engine stored them into io.KeysDown[]!
bool HanaLovesMe::IsKeyDown(int user_key_index)
{
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(GHanaLovesMe->IO.KeysDown));
    return GHanaLovesMe->IO.KeysDown[user_key_index];
}

int HanaLovesMe::CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate)
{
    if (t == 0.0f)
        return 1;
    if (t <= repeat_delay || repeat_rate <= 0.0f)
        return 0;
    const int count = (int)((t - repeat_delay) / repeat_rate) - (int)((t_prev - repeat_delay) / repeat_rate);
    return (count > 0) ? count : 0;
}

int HanaLovesMe::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (key_index < 0)
        return 0;
    IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[key_index];
    return CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, repeat_delay, repeat_rate);
}

bool HanaLovesMe::IsKeyPressed(int user_key_index, bool repeat)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (user_key_index < 0)
        return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    const float t = g.IO.KeysDownDuration[user_key_index];
    if (t == 0.0f)
        return true;
    if (repeat && t > g.IO.KeyRepeatDelay)
        return GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
    return false;
}

bool HanaLovesMe::IsKeyReleased(int user_key_index)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (user_key_index < 0) return false;
    IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
    return g.IO.KeysDownDurationPrev[user_key_index] >= 0.0f && !g.IO.KeysDown[user_key_index];
}

bool HanaLovesMe::IsMouseDown(int button)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDown[button];
}

bool HanaLovesMe::IsAnyMouseDown()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)
        if (g.IO.MouseDown[n])
            return true;
    return false;
}

bool HanaLovesMe::IsMouseClicked(int button, bool repeat)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    const float t = g.IO.MouseDownDuration[button];
    if (t == 0.0f)
        return true;

    if (repeat && t > g.IO.KeyRepeatDelay)
    {
        float delay = g.IO.KeyRepeatDelay, rate = g.IO.KeyRepeatRate;
        if ((ImFmod(t - delay, rate) > rate * 0.5f) != (ImFmod(t - delay - g.IO.DeltaTime, rate) > rate * 0.5f))
            return true;
    }

    return false;
}

bool HanaLovesMe::IsMouseReleased(int button)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseReleased[button];
}

bool HanaLovesMe::IsMouseDoubleClicked(int button)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    return g.IO.MouseDoubleClicked[button];
}

bool HanaLovesMe::IsMouseDragging(int button, float lock_threshold)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (!g.IO.MouseDown[button])
        return false;
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
}

vsize HanaLovesMe::GetMousePos()
{
    return GHanaLovesMe->IO.MousePos;
}

// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
vsize HanaLovesMe::GetMousePosOnOpeningCurrentPopup()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.BeginPopupStack.Size > 0)
        return g.OpenPopupStack[g.BeginPopupStack.Size - 1].OpenMousePos;
    return g.IO.MousePos;
}

// We typically use vsize(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.
bool HanaLovesMe::IsMousePosValid(const vsize * mouse_pos)
{
    // The assert is only to silence a false-positive in XCode Static Analysis.
    // Because GHanaLovesMe is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
    IM_ASSERT(GHanaLovesMe != NULL);
    const float MOUSE_INVALID = -256000.0f;
    vsize p = mouse_pos ? *mouse_pos : GHanaLovesMe->IO.MousePos;
    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
}

// Return the delta from the initial clicking position while the mouse button is clicked or was just released.
// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
// NB: This is only valid if IsMousePosValid(). Back-ends in theory should always keep mouse position valid when dragging even outside the client window.
vsize HanaLovesMe::GetMouseDragDelta(int button, float lock_threshold)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    if (lock_threshold < 0.0f)
        lock_threshold = g.IO.MouseDragThreshold;
    if (g.IO.MouseDown[button] || g.IO.MouseReleased[button])
        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
            if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MouseClickedPos[button]))
                return g.IO.MousePos - g.IO.MouseClickedPos[button];
    return vsize(0.0f, 0.0f);
}

void HanaLovesMe::ResetMouseDragDelta(int button)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
    g.IO.MouseClickedPos[button] = g.IO.MousePos;
}

HanaLovesMeMouseCursor HanaLovesMe::GetMouseCursor()
{
    return GHanaLovesMe->MouseCursor;
}

void HanaLovesMe::SetMouseCursor(HanaLovesMeMouseCursor cursor_type)
{
    GHanaLovesMe->MouseCursor = cursor_type;
}

void HanaLovesMe::CaptureKeyboardFromApp(bool capture)
{
    GHanaLovesMe->WantCaptureKeyboardNextFrame = capture ? 1 : 0;
}

void HanaLovesMe::CaptureMouseFromApp(bool capture)
{
    GHanaLovesMe->WantCaptureMouseNextFrame = capture ? 1 : 0;
}

bool HanaLovesMe::IsItemActive()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.ActiveId)
    {
        HanaLovesMeWindow* window = g.CurrentWindow;
        return g.ActiveId == window->DC.LastItemId;
    }
    return false;
}

bool HanaLovesMe::IsItemActivated()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.ActiveId)
    {
        HanaLovesMeWindow* window = g.CurrentWindow;
        if (g.ActiveId == window->DC.LastItemId && g.ActiveIdPreviousFrame != window->DC.LastItemId)
            return true;
    }
    return false;
}

bool HanaLovesMe::IsItemDeactivated()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    return (g.ActiveIdPreviousFrame == window->DC.LastItemId && g.ActiveIdPreviousFrame != 0 && g.ActiveId != window->DC.LastItemId);
}

bool HanaLovesMe::IsItemDeactivatedAfterEdit()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEdited || (g.ActiveId == 0 && g.ActiveIdHasBeenEdited));
}

bool HanaLovesMe::IsItemFocused()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;

    if (g.NavId == 0 || g.NavDisableHighlight || g.NavId != window->DC.LastItemId)
        return false;
    return true;
}

bool HanaLovesMe::IsItemClicked(int mouse_button)
{
    return IsMouseClicked(mouse_button) && IsItemHovered(HanaLovesMeHoveredFlags_None);
}

bool HanaLovesMe::IsItemToggledSelection()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return (g.CurrentWindow->DC.LastItemStatusFlags & HanaLovesMeItemStatusFlags_ToggledSelection) ? true : false;
}

bool HanaLovesMe::IsAnyItemHovered()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

bool HanaLovesMe::IsAnyItemActive()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.ActiveId != 0;
}

bool HanaLovesMe::IsAnyItemFocused()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.NavId != 0 && !g.NavDisableHighlight;
}

bool HanaLovesMe::IsItemVisible()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->ClipRect.Overlaps(window->DC.LastItemRect);
}

bool HanaLovesMe::IsItemEdited()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return (window->DC.LastItemStatusFlags & HanaLovesMeItemStatusFlags_Edited) != 0;
}

// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.
void HanaLovesMe::SetItemAllowOverlap()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.HoveredId == g.CurrentWindow->DC.LastItemId)
        g.HoveredIdAllowOverlap = true;
    if (g.ActiveId == g.CurrentWindow->DC.LastItemId)
        g.ActiveIdAllowOverlap = true;
}

vsize HanaLovesMe::GetItemRectMin()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Min;
}

vsize HanaLovesMe::GetItemRectMax()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.Max;
}

vsize HanaLovesMe::GetItemRectSize()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->DC.LastItemRect.GetSize();
}

static vsrect GetViewportRect()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return vsrect(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
}

//-------------------------------------------------------------------------
// [SECTION] HanaLovesMe: Shadow
//-------------------------------------------------------------------------
// - BeginShadow()
// - BeginShadow()
// - BeginShadowEx()
// - EndShadow()
//-------------------------------------------------------------------------

#include "../globals/HanaSong.h"

static bool HanaLovesMe::BeginShadowEx(const char* name, HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags flags)
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeWindow* parent_window = g.CurrentWindow;

	flags |= HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoResize | HanaLovesMeWindowFlags_NoSavedSettings | HanaLovesMeWindowFlags_ChildWindow;
	flags |= (parent_window->Flags & HanaLovesMeWindowFlags_NoMove);  // Inherit the NoMove flag

	// Size
	const vsize content_avail = GetContentRegionAvail();
	vsize size = ImFloor(size_arg);
	const int auto_fit_axises = ((size.x == 0.0f) ? (1 << HanaLovesMeAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << HanaLovesMeAxis_Y) : 0x00);
	if (size.x <= 0.0f)
		size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
	if (size.y <= 0.0f)
		size.y = ImMax(content_avail.y + size.y, 4.0f);
	SetNextWindowSize(size);

	// Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(HanaLovesMeID id) with a stable value.
	char title[256];
	if (name)
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s_%08X", parent_window->Name, name, id);
	else
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);

	const float backup_border_size = g.Style.ChildBorderSize;
	if (!border)
		g.Style.ChildBorderSize = 0.0f;
	bool ret = BeginShadowBackground(title, NULL, flags);
	g.Style.ChildBorderSize = backup_border_size;

	HanaLovesMeWindow* child_window = g.CurrentWindow;
	child_window->ChildId = id;
	child_window->AutoFitChildAxises = auto_fit_axises;

	// Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
	// While this is not really documented/defined, it seems that the expected thing to do.
	parent_window->DC.CursorPos = child_window->Pos;

	// Process navigation-in immediately so NavInit can run on first frame
	if (g.NavActivateId == id && !(flags & HanaLovesMeWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll))
	{
		FocusWindow(child_window);
		NavInitWindow(child_window, false);
		SetActiveID(id + 1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item
		g.ActiveIdSource = HanaLovesMeInputSource_Nav;
	}
	return ret;
}

bool HanaLovesMe::BeginShadow(const char* str_id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	HanaLovesMeWindow* window = GetCurrentWindow();
	return BeginShadowEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool HanaLovesMe::BeginShadow(HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	IM_ASSERT(id != 0);
	return BeginShadowEx(NULL, id, size_arg, border, extra_flags);
}

void HanaLovesMe::EndShadow()
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeWindow* window = g.CurrentWindow;

	IM_ASSERT(window->Flags & HanaLovesMeWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss
	if (window->BeginCount > 1)
	{
		End();
	}
	else
	{
		vsize sz = window->Size;
		if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
			sz.x = ImMax(4.0f, sz.x);
		if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_Y))
			sz.y = ImMax(4.0f, sz.y);
		End();

		HanaLovesMeWindow* parent_window = g.CurrentWindow;
		vsrect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
		ItemSize(sz);
		if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & HanaLovesMeWindowFlags_NavFlattened))
		{
			ItemAdd(bb, window->ChildId);
			RenderNavHighlight(bb, window->ChildId);

			// When browsing a window that has no activable items (scroll only) we keep a highlight on the child
			if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)
				RenderNavHighlight(vsrect(bb.Min - vsize(2, 2), bb.Max + vsize(2, 2)), g.NavId, HanaLovesMeNavHighlightFlags_TypeThin);
		}
		else
		{
			// Not navigable into
			ItemAdd(bb, 0);
		}
	}
}
//// v2 ////


static bool HanaLovesMe::BeginGroupBoxEx2(const char* name, HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags flags) {

	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeWindow* parent_window = g.CurrentWindow;

	flags |= HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoSavedSettings | HanaLovesMeWindowFlags_NoResize | HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_NoMove;
	flags |= (parent_window->Flags & HanaLovesMeWindowFlags_NoMove);  // Inherit the NoMove flag

	// Size
	const vsize content_avail = GetContentRegionAvail();

	vsize size = ImFloor(size_arg);

	const int auto_fit_axises = ((size.x == 0.0f) ? (1 << HanaLovesMeAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << HanaLovesMeAxis_Y) : 0x00);

	if (size.x <= 0.0f)
		size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)

	if (size.y <= 0.0f)
		size.y = ImMax(content_avail.y + size.y, 4.0f);

	const float backup_border_size = g.Style.ChildBorderSize;

	if (!border)
		g.Style.ChildBorderSize = 0.0f;

	char title[256];

	if (name)
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s_%08X", parent_window->Name, name, id);
	else
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);

	HanaLovesMe::SetNextWindowSize(size);

	PopFont();
	PushFont(globals::boldMenuFont);

	bool ret = HanaLovesMe::BeginGroupBoxMain(title, NULL, flags);

	PopFont();
	PushFont(globals::menuFont);

	HanaLovesMeWindow* child_window = g.CurrentWindow;
	child_window->AutoFitChildAxises = auto_fit_axises;
	g.Style.ChildBorderSize = backup_border_size;

	return ret;
}

bool HanaLovesMe::BeginGroupBox2(const char* str_id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	HanaLovesMeWindow* window = GetCurrentWindow();
	return BeginGroupBoxEx2(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool HanaLovesMe::BeginGroupBox2(HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	IM_ASSERT(id != 0);
	return BeginGroupBoxEx2(NULL, id, size_arg, border, extra_flags);
}



//// v2 ////

static bool HanaLovesMe::BeginGroupBoxEx(const char* name, HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags flags) {

	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeWindow* parent_window = g.CurrentWindow;

	flags |= HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoSavedSettings | HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_NoMove;
	flags |= (parent_window->Flags & HanaLovesMeWindowFlags_NoMove);  // Inherit the NoMove flag

	// Size
	const vsize content_avail = GetContentRegionAvail();

	vsize size = ImFloor(size_arg);

	const int auto_fit_axises = ((size.x == 0.0f) ? (1 << HanaLovesMeAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << HanaLovesMeAxis_Y) : 0x00);

	if (size.x <= 0.0f)
		size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)

	if (size.y <= 0.0f)
		size.y = ImMax(content_avail.y + size.y, 4.0f);

	const float backup_border_size = g.Style.ChildBorderSize;

	if (!border)
		g.Style.ChildBorderSize = 0.0f;

	char title[256];

	if (name)
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s_%08X", parent_window->Name, name, id);
	else
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);

	HanaLovesMe::SetNextWindowSize(size);

	PopFont();
	PushFont(globals::boldMenuFont);

	bool ret = HanaLovesMe::BeginGroupBoxMain(title, NULL, flags);

	PopFont();
	PushFont(globals::menuFont);

	HanaLovesMeWindow* child_window = g.CurrentWindow;
	child_window->AutoFitChildAxises = auto_fit_axises;
	g.Style.ChildBorderSize = backup_border_size;

	return ret;
}

bool HanaLovesMe::BeginGroupBox(const char* str_id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	HanaLovesMeWindow* window = GetCurrentWindow();
	return BeginGroupBoxEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool HanaLovesMe::BeginGroupBox(HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	IM_ASSERT(id != 0);
	return BeginGroupBoxEx(NULL, id, size_arg, border, extra_flags);
}

#pragma warning(disable: 4244)

template <typename T>
inline T Yeet(T number, T min, T max) {

	if (number < min)
		return min;
	else if (number > max)
		return max;
	else
		return number;
}
//globals::



void HanaLovesMe::EndGroupBox()
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeWindow* window = g.CurrentWindow;
	const HanaLovesMeStyle& style = g.Style;
	IM_ASSERT(window->Flags & HanaLovesMeWindowFlags_ChildWindow);

	auto minTop = HanaLovesMe::GetWindowPos();
	auto maxTop = minTop + vsize(GetWindowSize().x, 15);
	auto minBottom = minTop + vsize(0, GetWindowSize().y - 15);
	auto maxBottom = minBottom + vsize(GetWindowSize().x, 15);

	PopFont();
	PushFont(globals::controlFont);

	if (window->ScrollbarY) {

		if (window->Scroll.y > 1.0f) {

			window->DrawList->AddRectFilledMultiColor(minTop + vsize(2, 1), maxTop + vsize(1, -13), xuicolor(48, 48, 48), xuicolor(48, 48, 48), xuicolor(48, 48, 48), xuicolor(48, 48, 48));
			window->DrawList->AddRectFilledMultiColor(minTop + vsize(2, 2), maxTop + vsize(1, 4), xuicolor(23, 23, 23, 255), xuicolor(23, 23, 23, 255), xuicolor(23, 23, 23, 0), xuicolor(23, 23, 23, 0));
			RenderText(vsize(maxTop.x - 18, maxTop.y - 16), "B");
		}

		if ((GetScrollMaxY() - window->Scroll.y) > 1.f) {

			window->DrawList->AddRectFilledMultiColor(minBottom + vsize(2, 13), maxBottom + vsize(6, 20), xuicolor(48, 48, 48), xuicolor(48, 48, 48), xuicolor(48, 48, 48), xuicolor(48, 48, 48));
			window->DrawList->AddRectFilledMultiColor(minBottom + vsize(2, -2), maxBottom + vsize(6, -2), xuicolor(23, 23, 23, 0), xuicolor(23, 23, 23, 0), xuicolor(23, 23, 23, 255), xuicolor(23, 23, 23, 255));
			RenderText(vsize(maxBottom.x - 18, maxBottom.y - 18), "A");
		}
	}

	if (window->BeginCount > 1) {

		End();
	}
	else {

		vsize sz = window->Size;

		if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_X))
			sz.x = ImMax(4.0f, sz.x);

		if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_Y))
			sz.y = ImMax(4.0f, sz.y);

		End();

		HanaLovesMeWindow* parent_window = g.CurrentWindow;
		vsrect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
		ItemSize(sz);

		if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & HanaLovesMeWindowFlags_NavFlattened)) {

			ItemAdd(bb, window->ChildId);
			RenderNavHighlight(bb, window->ChildId);

			if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)
				RenderNavHighlight(vsrect(bb.Min - vsize(2, 2), bb.Max + vsize(2, 2)), g.NavId, HanaLovesMeNavHighlightFlags_TypeThin);
		}
		else {

			ItemAdd(bb, 0);
		}
	}
}

static bool HanaLovesMe::BeginGroupBoxScrollEx(const char* name, const char* groupboxName, HanaLovesMeID id, const vsize& size_arg, bool border, HanaLovesMeWindowFlags flags) {

	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeWindow* parent_window = g.CurrentWindow;

	flags |= HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoResize | HanaLovesMeWindowFlags_NoSavedSettings | HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoScrollbar | HanaLovesMeWindowFlags_NoScrollWithMouse;
	flags |= (parent_window->Flags & HanaLovesMeWindowFlags_NoMove);  // Inherit the NoMove flag

	// Size
	const vsize content_avail = GetContentRegionAvail();

	vsize size = ImFloor(size_arg);

	const int auto_fit_axises = ((size.x == 0.0f) ? (1 << HanaLovesMeAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << HanaLovesMeAxis_Y) : 0x00);

	if (size.x <= 0.0f)
		size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)

	const float backup_border_size = g.Style.ChildBorderSize;

	if (!border)
		g.Style.ChildBorderSize = 0.0f;

	char title[256];

	if (name)
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s_%08X", parent_window->Name, name, id);
	else
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);

	HanaLovesMe::SetNextWindowSize(size);

	PopFont();
	PushFont(globals::boldMenuFont);

	bool ret = HanaLovesMe::BeginGroupBoxScrollMain(title, groupboxName, NULL, flags);

	PopFont();
	PushFont(globals::menuFont);

	HanaLovesMeWindow* child_window = g.CurrentWindow;
	child_window->AutoFitChildAxises = auto_fit_axises;
	g.Style.ChildBorderSize = backup_border_size;

	return ret;
}

bool HanaLovesMe::BeginGroupBoxScroll(const char* str_id, const char* groupboxName, const vsize& size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	HanaLovesMeWindow* window = GetCurrentWindow();
	return BeginGroupBoxScrollEx(str_id, groupboxName, window->GetID(str_id), size_arg, border, extra_flags);
}

bool HanaLovesMe::BeginGroupBoxScroll(HanaLovesMeID id, const char* groupboxName, const vsize& size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	IM_ASSERT(id != 0);
	return BeginGroupBoxScrollEx(NULL, groupboxName, id, size_arg, border, extra_flags);
}

void HanaLovesMe::EndGroupBoxScroll()
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeWindow* window = g.CurrentWindow;
	IM_ASSERT(window->Flags & HanaLovesMeWindowFlags_ChildWindow);

	if (window->BeginCount > 1) {

		End();
	}
	else {

		vsize sz = window->Size;

		if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
			sz.x = ImMax(4.0f, sz.x);

		if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_Y))
			sz.y = ImMax(4.0f, sz.y);

		End();

		HanaLovesMeWindow* parent_window = g.CurrentWindow;
		vsrect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
		ItemSize(sz);

		if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & HanaLovesMeWindowFlags_NavFlattened)) {

			ItemAdd(bb, window->ChildId);
			RenderNavHighlight(bb, window->ChildId);

			if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)
				RenderNavHighlight(vsrect(bb.Min - vsize(2, 2), bb.Max + vsize(2, 2)), g.NavId, HanaLovesMeNavHighlightFlags_TypeThin);
		}
		else {

			ItemAdd(bb, 0);
		}
	}
}

bool HanaLovesMe::GroupBoxTitleEx(const char* label, const vsize& size_arg, HanaLovesMeButtonFlags flags) {

	HanaLovesMeWindow* window = GetCurrentWindow();

	if (window->SkipItems)
		return false;

	HanaLovesMeContext& g = *GHanaLovesMe;

	const HanaLovesMeStyle& style = g.Style;
	const HanaLovesMeID id = window->GetID(label);
	const vsize label_size = CalcTextSize(label, NULL, true);

	vsize pos = window->DC.CursorPos;

	if ((flags & HanaLovesMeButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrentLineTextBaseOffset)
		pos.y += window->DC.CurrentLineTextBaseOffset - style.FramePadding.y;

	vsize size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

	const vsrect bb(pos, pos + size);

	ItemSize(bb, style.FramePadding.y);

	if (!ItemAdd(bb, id))
		return false;

	if (window->DC.ItemFlags & HanaLovesMeItemFlags_ButtonRepeat)
		flags |= HanaLovesMeButtonFlags_Repeat;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	//Render

	auto topColor = xuicolor(170, 170, 170, 255);
	auto bottomColor = xuicolor(170, 170, 170, 255);

	window->DrawList->AddRectFilledMultiColor(bb.Min - vsize(0, 7), bb.Max + vsize(-2, 7), topColor, topColor, bottomColor, bottomColor);

	PushColor(HanaLovesMeCol_Text, HanaLovesMeCol_TextShadow, xuifloatcolor(0.0f, 0.0f, 0.0f, 0.0f));
	RenderText(vsize(bb.Min.x + style.FramePadding.x + 1, bb.Max.y - style.FramePadding.y - 34), label);
	HanaLovesMe::PopStyleColor();

	PushStyleColor(HanaLovesMeCol_Text, g.Style.Colors[(hovered && held) ? HanaLovesMeCol_Text : hovered ? HanaLovesMeCol_Text : HanaLovesMeCol_Text]);
	RenderText(vsize(bb.Min.x + style.FramePadding.x, bb.Max.y - style.FramePadding.y - 35), label);
	
	HanaLovesMe::PopStyleColor();

	return pressed;
}

bool HanaLovesMe::GroupBoxTitle(const char* label, const vsize& size_arg)
{
	return GroupBoxTitleEx(label, size_arg, 0);
}

static bool HanaLovesMe::BeginChildEx(const char* name, HanaLovesMeID id, const vsize & size_arg, bool border, HanaLovesMeWindowFlags flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* parent_window = g.CurrentWindow;

    flags |= HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoResize | HanaLovesMeWindowFlags_NoSavedSettings | HanaLovesMeWindowFlags_ChildWindow;
    flags |= (parent_window->Flags & HanaLovesMeWindowFlags_NoMove);  // Inherit the NoMove flag

    // Size
    const vsize content_avail = GetContentRegionAvail();
    vsize size = ImFloor(size_arg);
    const int auto_fit_axises = ((size.x == 0.0f) ? (1 << HanaLovesMeAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << HanaLovesMeAxis_Y) : 0x00);
    if (size.x <= 0.0f)
        size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
    if (size.y <= 0.0f)
        size.y = ImMax(content_avail.y + size.y, 4.0f);
    SetNextWindowSize(size);

    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(HanaLovesMeID id) with a stable value.
    char title[256];
    if (name)
        ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s_%08X", parent_window->Name, name, id);
    else
        ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);

    const float backup_border_size = g.Style.ChildBorderSize;
    if (!border)
        g.Style.ChildBorderSize = 0.0f;
    bool ret = Begin(title, NULL, flags);
    g.Style.ChildBorderSize = backup_border_size;

    HanaLovesMeWindow * child_window = g.CurrentWindow;
    child_window->ChildId = id;
    child_window->AutoFitChildAxises = auto_fit_axises;

    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
    // While this is not really documented/defined, it seems that the expected thing to do.
    if (child_window->BeginCount == 1)
        parent_window->DC.CursorPos = child_window->Pos;

    // Process navigation-in immediately so NavInit can run on first frame
    if (g.NavActivateId == id && !(flags & HanaLovesMeWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll))
    {
        FocusWindow(child_window);
        NavInitWindow(child_window, false);
        SetActiveID(id + 1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item
        g.ActiveIdSource = HanaLovesMeInputSource_Nav;
    }
    return ret;
}

bool HanaLovesMe::BeginChild(const char* str_id, const vsize & size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool HanaLovesMe::BeginChild(HanaLovesMeID id, const vsize & size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
    IM_ASSERT(id != 0);
    return BeginChildEx(NULL, id, size_arg, border, extra_flags);
}

void HanaLovesMe::EndChild()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;

    IM_ASSERT(window->Flags & HanaLovesMeWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss
    if (window->BeginCount > 1)
    {
        End();
    } else
    {
        vsize sz = window->Size;
        if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
            sz.x = ImMax(4.0f, sz.x);
        if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_Y))
            sz.y = ImMax(4.0f, sz.y);
        End();

        HanaLovesMeWindow * parent_window = g.CurrentWindow;
        vsrect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
        ItemSize(sz);
        if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & HanaLovesMeWindowFlags_NavFlattened))
        {
            ItemAdd(bb, window->ChildId);
            RenderNavHighlight(bb, window->ChildId);

            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child
            if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)
                RenderNavHighlight(vsrect(bb.Min - vsize(2, 2), bb.Max + vsize(2, 2)), g.NavId, HanaLovesMeNavHighlightFlags_TypeThin);
        } else
        {
            // Not navigable into
            ItemAdd(bb, 0);
        }
    }
}

static bool HanaLovesMe::BeginTabsEx(const char* name, HanaLovesMeID id, const vsize & size_arg, bool border, HanaLovesMeWindowFlags flags)
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeWindow* parent_window = g.CurrentWindow;

	flags |= HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoResize | HanaLovesMeWindowFlags_NoSavedSettings | HanaLovesMeWindowFlags_ChildWindow;
	flags |= (parent_window->Flags & HanaLovesMeWindowFlags_NoMove);  // Inherit the NoMove flag

	// Size
	const vsize content_avail = GetContentRegionAvail();
	vsize size = ImFloor(size_arg);
	const int auto_fit_axises = ((size.x == 0.0f) ? (1 << HanaLovesMeAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << HanaLovesMeAxis_Y) : 0x00);
	if (size.x <= 0.0f)
		size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
	if (size.y <= 0.0f)
		size.y = ImMax(content_avail.y + size.y, 4.0f);
	SetNextWindowSize(size);

	// Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(HanaLovesMeID id) with a stable value.
	char title[256];
	if (name)
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s_%08X", parent_window->Name, name, id);
	else
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);

	const float backup_border_size = g.Style.ChildBorderSize;
	if (!border)
		g.Style.ChildBorderSize = 0.0f;
	bool ret = BeginTabsBackground(title, NULL, flags);
	g.Style.ChildBorderSize = backup_border_size;

	HanaLovesMeWindow * child_window = g.CurrentWindow;
	child_window->ChildId = id;
	child_window->AutoFitChildAxises = auto_fit_axises;

	// Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
	// While this is not really documented/defined, it seems that the expected thing to do.
	if (child_window->BeginCount == 1)
		parent_window->DC.CursorPos = child_window->Pos;

	// Process navigation-in immediately so NavInit can run on first frame
	if (g.NavActivateId == id && !(flags & HanaLovesMeWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll))
	{
		FocusWindow(child_window);
		NavInitWindow(child_window, false);
		SetActiveID(id + 1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item
		g.ActiveIdSource = HanaLovesMeInputSource_Nav;
	}
	return ret;
}

bool HanaLovesMe::BeginTabs(const char* str_id, const vsize & size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	HanaLovesMeWindow* window = GetCurrentWindow();
	return BeginTabsEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool HanaLovesMe::BeginTabs(HanaLovesMeID id, const vsize & size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	IM_ASSERT(id != 0);
	return BeginTabsEx(NULL, id, size_arg, border, extra_flags);
}

void HanaLovesMe::EndTabs()
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeWindow* window = g.CurrentWindow;

	IM_ASSERT(window->Flags & HanaLovesMeWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss
	if (window->BeginCount > 1)
	{
		End();
	}
	else
	{
		vsize sz = window->Size;
		if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
			sz.x = ImMax(4.0f, sz.x);
		if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_Y))
			sz.y = ImMax(4.0f, sz.y);
		End();

		HanaLovesMeWindow * parent_window = g.CurrentWindow;
		vsrect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
		ItemSize(sz);
		if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & HanaLovesMeWindowFlags_NavFlattened))
		{
			ItemAdd(bb, window->ChildId);
			RenderNavHighlight(bb, window->ChildId);

			// When browsing a window that has no activable items (scroll only) we keep a highlight on the child
			if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)
				RenderNavHighlight(vsrect(bb.Min - vsize(2, 2), bb.Max + vsize(2, 2)), g.NavId, HanaLovesMeNavHighlightFlags_TypeThin);
		}
		else
		{
			// Not navigable into
			ItemAdd(bb, 0);
		}
	}
}




















// end our border (big fucking gay)

static bool HanaLovesMe::EndBorderEx(const char* name, HanaLovesMeID id, const vsize & size_arg, bool border, HanaLovesMeWindowFlags flags)
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeWindow* parent_window = g.CurrentWindow;

	flags |= HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoResize | HanaLovesMeWindowFlags_NoSavedSettings | HanaLovesMeWindowFlags_ChildWindow;
	flags |= (parent_window->Flags & HanaLovesMeWindowFlags_NoMove);  // Inherit the NoMove flag

	// Size
	const vsize content_avail = GetContentRegionAvail();
	vsize size = ImFloor(size_arg);
	const int auto_fit_axises = ((size.x == 0.0f) ? (1 << HanaLovesMeAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << HanaLovesMeAxis_Y) : 0x00);
	if (size.x <= 0.0f)
		size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
	if (size.y <= 0.0f)
		size.y = ImMax(content_avail.y + size.y, 4.0f);
	SetNextWindowSize(size);

	// Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(HanaLovesMeID id) with a stable value.
	char title[256];
	if (name)
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s_%08X", parent_window->Name, name, id);
	else
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);

	const float backup_border_size = g.Style.ChildBorderSize;
	if (!border)
		g.Style.ChildBorderSize = 0.0f;
	bool ret = BeginEndBorder(title, NULL, flags);
	g.Style.ChildBorderSize = backup_border_size;

	HanaLovesMeWindow * child_window = g.CurrentWindow;
	child_window->ChildId = id;
	child_window->AutoFitChildAxises = auto_fit_axises;

	// Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
	// While this is not really documented/defined, it seems that the expected thing to do.
	if (child_window->BeginCount == 1)
		parent_window->DC.CursorPos = child_window->Pos;

	// Process navigation-in immediately so NavInit can run on first frame
	if (g.NavActivateId == id && !(flags & HanaLovesMeWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll))
	{
		FocusWindow(child_window);
		NavInitWindow(child_window, false);
		SetActiveID(id + 1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item
		g.ActiveIdSource = HanaLovesMeInputSource_Nav;
	}
	return ret;
}

bool HanaLovesMe::EndBorder(const char* str_id, const vsize & size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	HanaLovesMeWindow* window = GetCurrentWindow();
	return EndBorderEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool HanaLovesMe::EndBorder(HanaLovesMeID id, const vsize & size_arg, bool border, HanaLovesMeWindowFlags extra_flags)
{
	IM_ASSERT(id != 0);
	return EndBorderEx(NULL, id, size_arg, border, extra_flags);
}

void HanaLovesMe::EndEndBorder()
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeWindow* window = g.CurrentWindow;

	IM_ASSERT(window->Flags & HanaLovesMeWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss
	if (window->BeginCount > 1)
	{
		End();
	}
	else
	{
		vsize sz = window->Size;
		if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
			sz.x = ImMax(4.0f, sz.x);
		if (window->AutoFitChildAxises & (1 << HanaLovesMeAxis_Y))
			sz.y = ImMax(4.0f, sz.y);
		End();

		HanaLovesMeWindow * parent_window = g.CurrentWindow;
		vsrect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
		ItemSize(sz);
		if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & HanaLovesMeWindowFlags_NavFlattened))
		{
			ItemAdd(bb, window->ChildId);
			RenderNavHighlight(bb, window->ChildId);

			// When browsing a window that has no activable items (scroll only) we keep a highlight on the child
			if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)
				RenderNavHighlight(vsrect(bb.Min - vsize(2, 2), bb.Max + vsize(2, 2)), g.NavId, HanaLovesMeNavHighlightFlags_TypeThin);
		}
		else
		{
			// Not navigable into
			ItemAdd(bb, 0);
		}
	}
}

// Helper to create a child window / scrolling region that looks like a normal widget frame.
bool HanaLovesMe::BeginChildFrame(HanaLovesMeID id, const vsize & size, HanaLovesMeWindowFlags extra_flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    const HanaLovesMeStyle& style = g.Style;
    PushStyleColor(HanaLovesMeCol_ChildBg, style.Colors[HanaLovesMeCol_FrameBg]);
    PushStyleVar(HanaLovesMeStyleVar_ChildRounding, style.FrameRounding);
    PushStyleVar(HanaLovesMeStyleVar_ChildBorderSize, style.FrameBorderSize);
    PushStyleVar(HanaLovesMeStyleVar_WindowPadding, style.FramePadding);
    bool ret = BeginChild(id, size, true, HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_AlwaysUseWindowPadding | extra_flags);
    PopStyleVar(3);
    PopStyleColor();
    return ret;
}

void HanaLovesMe::EndChildFrame()
{
    EndChild();
}

// Save and compare stack sizes on Begin()/End() to detect usage errors
static void CheckStacksSize(HanaLovesMeWindow * window, bool write)
{
    // NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
    HanaLovesMeContext& g = *GHanaLovesMe;
    short* p_backup = &window->DC.StackSizesBackup[0];
    { int current = window->IDStack.Size;       if (write)* p_backup = (short)current; else IM_ASSERT(*p_backup == current && "PushID/PopID or TreeNode/TreePop Mismatch!");   p_backup++; }    // Too few or too many PopID()/TreePop()
    { int current = window->DC.GroupStack.Size; if (write)* p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginGroup/EndGroup Mismatch!");                p_backup++; }    // Too few or too many EndGroup()
    { int current = g.BeginPopupStack.Size;     if (write)* p_backup = (short)current; else IM_ASSERT(*p_backup == current && "BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch"); p_backup++; }// Too few or too many EndMenu()/EndPopup()
    // For color, style and font stacks there is an incentive to use Push/Begin/Pop/.../End patterns, so we relax our checks a little to allow them.
    { int current = g.ColorModifiers.Size;      if (write)* p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleColor/PopStyleColor Mismatch!");       p_backup++; }    // Too few or too many PopStyleColor()
    { int current = g.StyleModifiers.Size;      if (write)* p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushStyleVar/PopStyleVar Mismatch!");           p_backup++; }    // Too few or too many PopStyleVar()
    { int current = g.FontStack.Size;           if (write)* p_backup = (short)current; else IM_ASSERT(*p_backup >= current && "PushFont/PopFont Mismatch!");                   p_backup++; }    // Too few or too many PopFont()
    IM_ASSERT(p_backup == window->DC.StackSizesBackup + IM_ARRAYSIZE(window->DC.StackSizesBackup));
}

static void SetWindowConditionAllowFlags(HanaLovesMeWindow * window, HanaLovesMeCond flags, bool enabled)
{
    window->SetWindowPosAllowFlags = enabled ? (window->SetWindowPosAllowFlags | flags) : (window->SetWindowPosAllowFlags & ~flags);
    window->SetWindowSizeAllowFlags = enabled ? (window->SetWindowSizeAllowFlags | flags) : (window->SetWindowSizeAllowFlags & ~flags);
    window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
}

HanaLovesMeWindow * HanaLovesMe::FindWindowByID(HanaLovesMeID id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return (HanaLovesMeWindow*)g.WindowsById.GetVoidPtr(id);
}

HanaLovesMeWindow* HanaLovesMe::FindWindowByName(const char* name)
{
    HanaLovesMeID id = ImHashStr(name, 0);
    return FindWindowByID(id);
}

static HanaLovesMeWindow* CreateNewWindow(const char* name, vsize size, HanaLovesMeWindowFlags flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    // Create window the first time
    HanaLovesMeWindow* window = IM_NEW(HanaLovesMeWindow)(&g, name);
    window->Flags = flags;
    g.WindowsById.SetVoidPtr(window->ID, window);

    // Default/arbitrary window position. Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
    window->Pos = vsize(60, 60);

    // User can disable loading and saving of settings. Tooltip and child windows also don't store settings.
    if (!(flags & HanaLovesMeWindowFlags_NoSavedSettings))
        if (HanaLovesMeWindowSettings * settings = HanaLovesMe::FindWindowSettings(window->ID))
        {
            // Retrieve settings from .ini file
            window->SettingsIdx = g.SettingsWindows.index_from_ptr(settings);
            SetWindowConditionAllowFlags(window, HanaLovesMeCond_FirstUseEver, false);
            window->Pos = ImFloor(settings->Pos);
            window->Collapsed = settings->Collapsed;
            if (ImLengthSqr(settings->Size) > 0.00001f)
                size = ImFloor(settings->Size);
        }
    window->Size = window->SizeFull = window->SizeFullAtLastBegin = ImFloor(size);
    window->DC.CursorMaxPos = window->Pos; // So first call to CalcSizeContents() doesn't return crazy values

    if ((flags & HanaLovesMeWindowFlags_AlwaysAutoResize) != 0)
    {
        window->AutoFitFramesX = window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    } else
    {
        if (window->Size.x <= 0.0f)
            window->AutoFitFramesX = 2;
        if (window->Size.y <= 0.0f)
            window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
    }

    g.WindowsFocusOrder.push_back(window);
    if (flags & HanaLovesMeWindowFlags_NoBringToFrontOnFocus)
        g.Windows.push_front(window); // Quite slow but rare and only once
    else
        g.Windows.push_back(window);
    return window;
}

static vsize CalcSizeAfterConstraint(HanaLovesMeWindow * window, vsize new_size)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.NextWindowData.SizeConstraintCond != 0)
    {
        // Using -1,-1 on either X/Y axis to preserve the current size.
        vsrect cr = g.NextWindowData.SizeConstraintRect;
        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
        if (g.NextWindowData.SizeCallback)
        {
            HanaLovesMeSizeCallbackData data;
            data.UserData = g.NextWindowData.SizeCallbackUserData;
            data.Pos = window->Pos;
            data.CurrentSize = window->SizeFull;
            data.DesiredSize = new_size;
            g.NextWindowData.SizeCallback(&data);
            new_size = data.DesiredSize;
        }
    }

    // Minimum size
    if (!(window->Flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_AlwaysAutoResize)))
    {
        new_size = ImMax(new_size, g.Style.WindowMinSize);
        new_size.y = ImMax(new_size.y, window->TitleBarHeight() + window->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f)); // Reduce artifacts with very small windows
    }
    return new_size;
}

static vsize CalcSizeContents(HanaLovesMeWindow * window)
{
    if (window->Collapsed)
        if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
            return window->SizeContents;
    if (window->Hidden && window->HiddenFramesCannotSkipItems == 0 && window->HiddenFramesCanSkipItems > 0)
        return window->SizeContents;

    vsize sz;
    sz.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : (window->DC.CursorMaxPos.x - window->Pos.x + window->Scroll.x));
    sz.y = (float)(int)((window->SizeContentsExplicit.y != 0.0f) ? window->SizeContentsExplicit.y : (window->DC.CursorMaxPos.y - window->Pos.y + window->Scroll.y));
    return sz + window->WindowPadding;
}

static vsize CalcSizeAutoFit(HanaLovesMeWindow * window, const vsize & size_contents)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeStyle& style = g.Style;
    if (window->Flags & HanaLovesMeWindowFlags_Tooltip)
    {
        // Tooltip always resize
        return size_contents;
    } else
    {
        // Maximum window size is determined by the display size
        const bool is_popup = (window->Flags & HanaLovesMeWindowFlags_Popup) != 0;
        const bool is_menu = (window->Flags & HanaLovesMeWindowFlags_ChildMenu) != 0;
        vsize size_min = style.WindowMinSize;
        if (is_popup || is_menu) // Popups and menus bypass style.WindowMinSize by default, but we give then a non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
            size_min = ImMin(size_min, vsize(4.0f, 4.0f));
        vsize size_auto_fit = ImClamp(size_contents, size_min, ImMax(size_min, g.IO.DisplaySize - style.DisplaySafeAreaPadding * 2.0f));

        // When the window cannot fit all contents (either because of constraints, either because screen is too small),
        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
        vsize size_auto_fit_after_constraint = CalcSizeAfterConstraint(window, size_auto_fit);
        if (size_auto_fit_after_constraint.x < size_contents.x && !(window->Flags & HanaLovesMeWindowFlags_NoScrollbar) && (window->Flags & HanaLovesMeWindowFlags_HorizontalScrollbar))
            size_auto_fit.y += style.ScrollbarSize;
        if (size_auto_fit_after_constraint.y < size_contents.y && !(window->Flags & HanaLovesMeWindowFlags_NoScrollbar))
            size_auto_fit.x += style.ScrollbarSize;
        return size_auto_fit;
    }
}

vsize HanaLovesMe::CalcWindowExpectedSize(HanaLovesMeWindow * window)
{
    vsize size_contents = CalcSizeContents(window);
    return CalcSizeAfterConstraint(window, CalcSizeAutoFit(window, size_contents));
}

float HanaLovesMe::GetWindowScrollMaxX(HanaLovesMeWindow * window)
{
    return ImMax(0.0f, window->SizeContents.x - (window->SizeFull.x - window->ScrollbarSizes.x));
}

float HanaLovesMe::GetWindowScrollMaxY(HanaLovesMeWindow * window)
{
    return ImMax(0.0f, window->SizeContents.y - (window->SizeFull.y - window->ScrollbarSizes.y));
}

static vsize CalcNextScrollFromScrollTargetAndClamp(HanaLovesMeWindow * window, bool snap_on_edges)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    vsize scroll = window->Scroll;
    if (window->ScrollTarget.x < FLT_MAX)
    {
        float cr_x = window->ScrollTargetCenterRatio.x;
        scroll.x = window->ScrollTarget.x - cr_x * (window->SizeFull.x - window->ScrollbarSizes.x);
    }
    if (window->ScrollTarget.y < FLT_MAX)
    {
        // 'snap_on_edges' allows for a discontinuity at the edge of scrolling limits to take account of WindowPadding so that scrolling to make the last item visible scroll far enough to see the padding.
        float cr_y = window->ScrollTargetCenterRatio.y;
        float target_y = window->ScrollTarget.y;
        if (snap_on_edges && cr_y <= 0.0f && target_y <= window->WindowPadding.y)
            target_y = 0.0f;
        if (snap_on_edges && cr_y >= 1.0f && target_y >= window->SizeContents.y - window->WindowPadding.y + g.Style.ItemSpacing.y)
            target_y = window->SizeContents.y;
        scroll.y = target_y - (1.0f - cr_y) * (window->TitleBarHeight() + window->MenuBarHeight()) - cr_y * (window->SizeFull.y - window->ScrollbarSizes.y);
    }
    scroll = ImMax(scroll, vsize(0.0f, 0.0f));
    if (!window->Collapsed && !window->SkipItems)
    {
        scroll.x = ImMin(scroll.x, HanaLovesMe::GetWindowScrollMaxX(window));
        scroll.y = ImMin(scroll.y, HanaLovesMe::GetWindowScrollMaxY(window));
    }
    return scroll;
}

static HanaLovesMeCol GetWindowBgColorIdxFromFlags(HanaLovesMeWindowFlags flags)
{
    if (flags & (HanaLovesMeWindowFlags_Tooltip | HanaLovesMeWindowFlags_Popup))
        return HanaLovesMeCol_PopupBg;
    if (flags & HanaLovesMeWindowFlags_ChildWindow)
        return HanaLovesMeCol_ChildBg;
    return HanaLovesMeCol_WindowBg;
}

static void CalcResizePosSizeFromAnyCorner(HanaLovesMeWindow * window, const vsize & corner_target, const vsize & corner_norm, vsize * out_pos, vsize * out_size)
{
    vsize pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left
    vsize pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
    vsize size_expected = pos_max - pos_min;
    vsize size_constrained = CalcSizeAfterConstraint(window, size_expected);
    *out_pos = pos_min;
    if (corner_norm.x == 0.0f)
        out_pos->x -= (size_constrained.x - size_expected.x);
    if (corner_norm.y == 0.0f)
        out_pos->y -= (size_constrained.y - size_expected.y);
    *out_size = size_constrained;
}

struct HanaLovesMeResizeGripDef
{
    vsize  CornerPosN;
    vsize  InnerDir;
    int     AngleMin12, AngleMax12;
};

static const HanaLovesMeResizeGripDef resize_grip_def[4] =
{
    { vsize(1,1), vsize(-1,-1), 0, 3 }, // Lower right
    { vsize(0,1), vsize(+1,-1), 3, 6 }, // Lower left
    { vsize(0,0), vsize(+1,+1), 6, 9 }, // Upper left
    { vsize(1,0), vsize(-1,+1), 9,12 }, // Upper right
};

static vsrect GetResizeBorderRect(HanaLovesMeWindow * window, int border_n, float perp_padding, float thickness)
{
    vsrect rect = window->Rect();
    if (thickness == 0.0f) rect.Max -= vsize(1, 1);
    if (border_n == 0) return vsrect(rect.Min.x + perp_padding, rect.Min.y - thickness, rect.Max.x - perp_padding, rect.Min.y + thickness);      // Top
    if (border_n == 1) return vsrect(rect.Max.x - thickness, rect.Min.y + perp_padding, rect.Max.x + thickness, rect.Max.y - perp_padding);   // Right
    if (border_n == 2) return vsrect(rect.Min.x + perp_padding, rect.Max.y - thickness, rect.Max.x - perp_padding, rect.Max.y + thickness);      // Bottom
    if (border_n == 3) return vsrect(rect.Min.x - thickness, rect.Min.y + perp_padding, rect.Min.x + thickness, rect.Max.y - perp_padding);   // Left
    IM_ASSERT(0);
    return vsrect();
}

// Handle resize for: Resize Grips, Borders, Gamepad
static void HanaLovesMe::UpdateManualResize(HanaLovesMeWindow * window, const vsize & size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4])
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindowFlags flags = window->Flags;
    if ((flags & HanaLovesMeWindowFlags_NoResize) || (flags & HanaLovesMeWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        return;
    if (window->WasActive == false) // Early out to avoid running this code for e.g. an hidden implicit/fallback Debug window.
        return;

    const int resize_border_count = g.IO.ConfigWindowsResizeFromEdges ? 4 : 0;
	const float grip_draw_size = (float)(int)ImMax(9 * 1.0f, window->WindowRounding + 0.0f + g.FontSize * 0.f); // sedmapickamaterina
    const float grip_hover_inner_size = (float)(int)(grip_draw_size * 0.75f);
    const float grip_hover_outer_size = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS : 0.0f;

    vsize pos_target(FLT_MAX, FLT_MAX);
    vsize size_target(FLT_MAX, FLT_MAX);

    // Resize grips and borders are on layer 1
    window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Menu;
    window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Menu);

    // Manual resize grips
    PushID("#RESIZE");
    for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
    {
        const HanaLovesMeResizeGripDef& grip = resize_grip_def[resize_grip_n];
        const vsize corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);

        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
        vsrect resize_rect(corner - grip.InnerDir * grip_hover_outer_size, corner + grip.InnerDir * grip_hover_inner_size);
        if (resize_rect.Min.x > resize_rect.Max.x) ImSwap(resize_rect.Min.x, resize_rect.Max.x);
        if (resize_rect.Min.y > resize_rect.Max.y) ImSwap(resize_rect.Min.y, resize_rect.Max.y);
        bool hovered, held;
        ButtonBehavior(resize_rect, window->GetID((void*)(intptr_t)resize_grip_n), &hovered, &held, HanaLovesMeButtonFlags_FlattenChildren | HanaLovesMeButtonFlags_NoNavFocus);
        //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
        if (hovered || held)
            g.MouseCursor = (resize_grip_n & 1) ? HanaLovesMeMouseCursor_ResizeNESW : HanaLovesMeMouseCursor_ResizeNWSE;

        if (held && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)
        {
            // Manual auto-fit when double-clicking
            size_target = CalcSizeAfterConstraint(window, size_auto_fit);
            ClearActiveID();
        } else if (held)
        {
            // Resize from any of the four corners
            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
            vsize corner_target = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(grip.InnerDir * grip_hover_outer_size, grip.InnerDir * -grip_hover_inner_size, grip.CornerPosN); // Corner of the window corresponding to our corner grip
            CalcResizePosSizeFromAnyCorner(window, corner_target, grip.CornerPosN, &pos_target, &size_target);
        }
        if (resize_grip_n == 0 || held || hovered)
            resize_grip_col[resize_grip_n] = GetColorU32(held ? HanaLovesMeCol_ResizeGripActive : hovered ? HanaLovesMeCol_ResizeGripHovered : HanaLovesMeCol_ResizeGrip);
    }
    for (int border_n = 0; border_n < resize_border_count; border_n++)
    {
        bool hovered, held;
        vsrect border_rect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS);
        ButtonBehavior(border_rect, window->GetID((void*)(intptr_t)(border_n + 4)), &hovered, &held, HanaLovesMeButtonFlags_FlattenChildren);
        //GetForegroundDrawLists(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
        if ((hovered && g.HoveredIdTimer > WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER) || held)
        {
            g.MouseCursor = (border_n & 1) ? HanaLovesMeMouseCursor_ResizeEW : HanaLovesMeMouseCursor_ResizeNS;
            if (held)
                * border_held = border_n;
        }
        if (held)
        {
            vsize border_target = window->Pos;
            vsize border_posn;
            if (border_n == 0) { border_posn = vsize(0, 0); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Top
            if (border_n == 1) { border_posn = vsize(1, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Right
            if (border_n == 2) { border_posn = vsize(0, 1); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Bottom
            if (border_n == 3) { border_posn = vsize(0, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS); } // Left
            CalcResizePosSizeFromAnyCorner(window, border_target, border_posn, &pos_target, &size_target);
        }
    }
    PopID();

    // Navigation resize (keyboard/gamepad)
    if (g.NavWindowingTarget && g.NavWindowingTarget->RootWindow == window)
    {
        vsize nav_resize_delta;
        if (g.NavInputSource == HanaLovesMeInputSource_NavKeyboard && g.IO.KeyShift)
            nav_resize_delta = GetNavInputAmount2d(HanaLovesMeNavDirSourceFlags_Keyboard, HanaLovesMeInputReadMode_Down);
        if (g.NavInputSource == HanaLovesMeInputSource_NavGamepad)
            nav_resize_delta = GetNavInputAmount2d(HanaLovesMeNavDirSourceFlags_PadDPad, HanaLovesMeInputReadMode_Down);
        if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)
        {
            const float NAV_RESIZE_SPEED = 600.0f;
            nav_resize_delta *= ImFloor(NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));
            g.NavWindowingToggleLayer = false;
            g.NavDisableMouseHover = true;
            resize_grip_col[0] = GetColorU32(HanaLovesMeCol_ResizeGripActive);
            // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
            size_target = CalcSizeAfterConstraint(window, window->SizeFull + nav_resize_delta);
        }
    }

    // Apply back modified position/size to window
    if (size_target.x != FLT_MAX)
    {
        window->SizeFull = size_target;
        MarkIniSettingsDirty(window);
    }
    if (pos_target.x != FLT_MAX)
    {
        window->Pos = ImFloor(pos_target);
        MarkIniSettingsDirty(window);
    }

    // Resize nav layer
    window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Main;
    window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Main);

    window->Size = window->SizeFull;
}

static inline void ClampWindowRect(HanaLovesMeWindow * window, const vsrect & rect, const vsize & padding)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    vsize size_for_clamping = (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window->Flags & HanaLovesMeWindowFlags_NoTitleBar)) ? vsize(window->Size.x, window->TitleBarHeight()) : window->Size;
    window->Pos = ImMin(rect.Max - padding, ImMax(window->Pos + size_for_clamping, rect.Min + padding) - size_for_clamping);
}

static void HanaLovesMe::RenderOuterBorders(HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    float rounding = window->WindowRounding;
    float border_size = window->WindowBorderSize;
    if (border_size > 0.0f && !(window->Flags & HanaLovesMeWindowFlags_NoBackground))
        window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(HanaLovesMeCol_Border), rounding, ImDrawCornerFlags_All, border_size);

    int border_held = window->ResizeBorderHeld;
    if (border_held != -1)
    {
        struct HanaLovesMeResizeBorderDef
        {
            vsize InnerDir;
            vsize CornerPosN1, CornerPosN2;
            float  OuterAngle;
        };
        static const HanaLovesMeResizeBorderDef resize_border_def[4] =
        {
            { vsize(0,+1), vsize(0,0), vsize(1,0), IM_PI * 1.50f }, // Top
            { vsize(-1,0), vsize(1,0), vsize(1,1), IM_PI * 0.00f }, // Right
            { vsize(0,-1), vsize(1,1), vsize(0,1), IM_PI * 0.50f }, // Bottom
            { vsize(+1,0), vsize(0,1), vsize(0,0), IM_PI * 1.00f }  // Left
        };
        const HanaLovesMeResizeBorderDef& def = resize_border_def[border_held];
        vsrect border_r = GetResizeBorderRect(window, border_held, rounding, 0.0f);
        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.CornerPosN1) + vsize(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25f, def.OuterAngle);
        window->DrawList->PathArcTo(ImLerp(border_r.Min, border_r.Max, def.CornerPosN2) + vsize(0.5f, 0.5f) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25f);
        window->DrawList->PathStroke(GetColorU32(HanaLovesMeCol_SeparatorActive), false, ImMax(2.0f, border_size)); // Thicker than usual
    }
    if (g.Style.FrameBorderSize > 0 && !(window->Flags & HanaLovesMeWindowFlags_NoTitleBar))
    {
        float y = window->Pos.y + window->TitleBarHeight() - 1;
        window->DrawList->AddLine(vsize(window->Pos.x + border_size, y), vsize(window->Pos.x + window->Size.x - border_size, y), GetColorU32(HanaLovesMeCol_Border), g.Style.FrameBorderSize);
    }
}

void HanaLovesMe::UpdateWindowParentAndRootLinks(HanaLovesMeWindow * window, HanaLovesMeWindowFlags flags, HanaLovesMeWindow * parent_window)
{
    window->ParentWindow = parent_window;
    window->RootWindow = window->RootWindowForTitleBarHighlight = window->RootWindowForNav = window;
    if (parent_window && (flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & HanaLovesMeWindowFlags_Tooltip))
        window->RootWindow = parent_window->RootWindow;
    if (parent_window && !(flags & HanaLovesMeWindowFlags_Modal) && (flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Popup)))
        window->RootWindowForTitleBarHighlight = parent_window->RootWindowForTitleBarHighlight;
    while (window->RootWindowForNav->Flags & HanaLovesMeWindowFlags_NavFlattened)
    {
        IM_ASSERT(window->RootWindowForNav->ParentWindow != NULL);
        window->RootWindowForNav = window->RootWindowForNav->ParentWindow;
    }
}

// Push a new HanaLovesMe window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call HanaLovesMe::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.



bool HanaLovesMe::Begin(const char* name, bool* p_open, HanaLovesMeWindowFlags flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    const HanaLovesMeStyle& style = g.Style;
    IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
    IM_ASSERT(g.FrameScopeActive);                  // Forgot to call HanaLovesMe::NewFrame()
    IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called HanaLovesMe::Render() or HanaLovesMe::EndFrame() and haven't called HanaLovesMe::NewFrame() again yet

    // Find or create
    HanaLovesMeWindow * window = FindWindowByName(name);
    const bool window_just_created = (window == NULL);
    if (window_just_created)
    {
        vsize size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : vsize(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
        window = CreateNewWindow(name, size_on_first_use, flags);
    }

    // Automatically disable manual moving/resizing when NoInputs is set
    if ((flags & HanaLovesMeWindowFlags_NoInputs) == HanaLovesMeWindowFlags_NoInputs)
        flags |= HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoResize;

    if (flags & HanaLovesMeWindowFlags_NavFlattened)
        IM_ASSERT(flags & HanaLovesMeWindowFlags_ChildWindow);

    const int current_frame = g.FrameCount;
    const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

    // Update the Appearing flag
    bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
    const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
    if (flags & HanaLovesMeWindowFlags_Popup)
    {
        HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
        window_just_activated_by_user |= (window != popup_ref.Window);
    }
    window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, true);

    // Update Flags, LastFrameActive, BeginOrderXXX fields
    if (first_begin_of_the_frame)
    {
        window->Flags = (HanaLovesMeWindowFlags)flags;
        window->LastFrameActive = current_frame;
        window->BeginOrderWithinParent = 0;
        window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
    } else
    {
        flags = window->Flags;
    }

    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
    HanaLovesMeWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
    HanaLovesMeWindow* parent_window = first_begin_of_the_frame ? ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
    IM_ASSERT(parent_window != NULL || !(flags & HanaLovesMeWindowFlags_ChildWindow));

    // Add to stack
    // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
    g.CurrentWindowStack.push_back(window);
    g.CurrentWindow = NULL;
    CheckStacksSize(window, true);
    if (flags & HanaLovesMeWindowFlags_Popup)
    {
        HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
        popup_ref.Window = window;
        g.BeginPopupStack.push_back(popup_ref);
        window->PopupId = popup_ref.PopupId;
    }

    if (window_just_appearing_after_hidden_for_resize && !(flags & HanaLovesMeWindowFlags_ChildWindow))
        window->NavLastIds[0] = 0;

    // Process SetNextWindow***() calls
    bool window_pos_set_by_api = false;
    bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
    if (g.NextWindowData.PosCond)
    {
        window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
        {
            // May be processed on the next frame if this is our first frame and we are measuring size
            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
            window->SetWindowPosVal = g.NextWindowData.PosVal;
            window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
            window->SetWindowPosAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);
        } else
        {
            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
        }
    }
    if (g.NextWindowData.SizeCond)
    {
        window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
        window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
    }
    if (g.NextWindowData.ContentSizeCond)
    {
        // Adjust passed "client size" to become a "window size"
        window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
        if (window->SizeContentsExplicit.y != 0.0f)
            window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
    } else if (first_begin_of_the_frame)
    {
        window->SizeContentsExplicit = vsize(0.0f, 0.0f);
    }
    if (g.NextWindowData.CollapsedCond)
        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
    if (g.NextWindowData.FocusCond)
        FocusWindow(window);
    if (window->Appearing)
        SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, false);

    // When reusing window again multiple times a frame, just append content (don't need to setup again)
    if (first_begin_of_the_frame)
    {
        // Initialize
        const bool window_is_child_tooltip = (flags & HanaLovesMeWindowFlags_ChildWindow) && (flags & HanaLovesMeWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
        UpdateWindowParentAndRootLinks(window, flags, parent_window);

        window->Active = true;
        window->HasCloseButton = (p_open != NULL);
        window->ClipRect = xuifloatcolor(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
        window->IDStack.resize(1);

        // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
        // The title bar always display the 'name' parameter, so we only update the string stohnly if it needs to be visible to the end-user elsewhere.
        bool window_title_visible_elsewhere = false;
        if (g.NavWindowingList != NULL && (window->Flags & HanaLovesMeWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
            window_title_visible_elsewhere = true;
        if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
        {
            size_t buf_len = (size_t)window->NameBufLen;
            window->Name = ImStrdupcpy(window->Name, &buf_len, name);
            window->NameBufLen = (int)buf_len;
        }

        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

        // Update contents size from last frame for auto-fitting (or use explicit size)
        window->SizeContents = CalcSizeContents(window);
        if (window->HiddenFramesCanSkipItems > 0)
            window->HiddenFramesCanSkipItems--;
        if (window->HiddenFramesCannotSkipItems > 0)
            window->HiddenFramesCannotSkipItems--;

        // Hide new windows for one frame until they calculate their size
        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
            window->HiddenFramesCannotSkipItems = 1;

        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
        // We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
        if (window_just_activated_by_user && (flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) != 0)
        {
            window->HiddenFramesCannotSkipItems = 1;
            if (flags & HanaLovesMeWindowFlags_AlwaysAutoResize)
            {
                if (!window_size_x_set_by_api)
                    window->Size.x = window->SizeFull.x = 0.f;
                if (!window_size_y_set_by_api)
                    window->Size.y = window->SizeFull.y = 0.f;
                window->SizeContents = vsize(0.f, 0.f);
            }
        }

        SetCurrentWindow(window);

        // Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
        if (flags & HanaLovesMeWindowFlags_ChildWindow)
            window->WindowBorderSize = style.ChildBorderSize;
        else
            window->WindowBorderSize = ((flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
        window->WindowPadding = style.WindowPadding;
        if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & (HanaLovesMeWindowFlags_AlwaysUseWindowPadding | HanaLovesMeWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
            window->WindowPadding = vsize(0.0f, (flags & HanaLovesMeWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
        window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
        window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

        // Collapse window by double-clicking on title bar
        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
        if (!(flags & HanaLovesMeWindowFlags_NoTitleBar) && !(flags & HanaLovesMeWindowFlags_NoCollapse))
        {
            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
            vsrect title_bar_rect = window->TitleBarRect();
            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
                window->WantCollapseToggle = true;
            if (window->WantCollapseToggle)
            {
                window->Collapsed = !window->Collapsed;
                MarkIniSettingsDirty(window);
                FocusWindow(window);
            }
        } else
        {
            window->Collapsed = false;
        }
        window->WantCollapseToggle = false;

        // SIZE

        // Calculate auto-fit size, handle automatic resize
        const vsize size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
        vsize size_full_modified(FLT_MAX, FLT_MAX);
        if ((flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && !window->Collapsed)
        {
            // Using SetNextWindowSize() overrides HanaLovesMeWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
            if (!window_size_x_set_by_api)
                window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
            if (!window_size_y_set_by_api)
                window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
        } else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
        {
            // Auto-fit may only grow window during the first few frames
            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor HanaLovesMeWindowFlags_AlwaysAutoResize when collapsed.
            if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
                window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
            if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
                window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
            if (!window->Collapsed)
                MarkIniSettingsDirty(window);
        }

        // Apply minimum/maximum window size constraints and final size
        window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
        window->Size = window->Collapsed && !(flags & HanaLovesMeWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

        // SCROLLBAR STATUS

        // Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
        if (!window->Collapsed)
        {
            // When reading the current size we need to read it after size constraints have been applied
            float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
            float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
            window->ScrollbarY = (flags & HanaLovesMeWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & HanaLovesMeWindowFlags_NoScrollbar));
            window->ScrollbarX = (flags & HanaLovesMeWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & HanaLovesMeWindowFlags_NoScrollbar) && (flags & HanaLovesMeWindowFlags_HorizontalScrollbar));
            if (window->ScrollbarX && !window->ScrollbarY)
                window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & HanaLovesMeWindowFlags_NoScrollbar);
            window->ScrollbarSizes = vsize(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
        }

        // POSITION

        // Popup latch its initial position, will position itself when it appears next frame
        if (window_just_activated_by_user)
        {
            window->AutoPosLastDirection = HanaLovesMeDir_None;
            if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api)
                window->Pos = g.BeginPopupStack.back().OpenPopupPos;
        }

        // Position child window
        if (flags & HanaLovesMeWindowFlags_ChildWindow)
        {
            IM_ASSERT(parent_window && parent_window->Active);
            window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
            parent_window->DC.ChildWindows.push_back(window);
            if (!(flags & HanaLovesMeWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
                window->Pos = parent_window->DC.CursorPos;
        }

        const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
        if (window_pos_with_pivot)
            SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
        else if ((flags & HanaLovesMeWindowFlags_ChildMenu) != 0)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
            window->Pos = FindBestWindowPosForPopup(window);
        else if ((flags & HanaLovesMeWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
            window->Pos = FindBestWindowPosForPopup(window);

        // Clamp position so it stays visible
        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
        vsrect viewport_rect(GetViewportRect());
        if (!window_pos_set_by_api && !(flags & HanaLovesMeWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
        {
            if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
            {
                vsize clamp_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
                ClampWindowRect(window, viewport_rect, clamp_padding);
            }
        }
        window->Pos = ImFloor(window->Pos);

        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
        window->WindowRounding = (flags & HanaLovesMeWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & HanaLovesMeWindowFlags_Popup) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

        // Apply scrolling
        window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
        window->ScrollTarget = vsize(FLT_MAX, FLT_MAX);

        // Apply window focus (new and reactivated windows are moved to front)
        bool want_focus = false;
        if (window_just_activated_by_user && !(flags & HanaLovesMeWindowFlags_NoFocusOnAppearing))
        {
            if (flags & HanaLovesMeWindowFlags_Popup)
                want_focus = true;
            else if ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Tooltip)) == 0)
                want_focus = true;
        }

        // Handle manual resize: Resize Grips, Borders, Gamepad
        int border_held = -1;
        ImU32 resize_grip_col[4] = { 0 };
        const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
		const float grip_draw_size = (float)(int)ImMax(9 * 1.0f, window->WindowRounding + 0.0f + g.FontSize * 0.f); // sedmapickamaterina
        if (!window->Collapsed)
            UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);
        window->ResizeBorderHeld = (signed char)border_held;

        // Default item width. Make it proportional to window size if window manually resizes
        if (window->Size.x > 0.0f && !(flags & HanaLovesMeWindowFlags_Tooltip) && !(flags & HanaLovesMeWindowFlags_AlwaysAutoResize))
            window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
        else
            window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

        // DRAWING

        // Setup draw list and outer clipping rectangle
        window->DrawList->Clear();
        window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
        window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
        if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & HanaLovesMeWindowFlags_Popup) && !window_is_child_tooltip)
            PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
        else
            PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

        // Draw modal window background (darkens what is behind them, all viewports)
        const bool dim_bg_for_modal = (flags & HanaLovesMeWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
        const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
        if (dim_bg_for_modal || dim_bg_for_window_list)
        {
            const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? HanaLovesMeCol_ModalWindowDimBg : HanaLovesMeCol_NavWindowingDimBg, g.DimBgRatio);
            window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
        }

        // Draw navigation selection/windowing rectangle background
        if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
        {
            vsrect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
                window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
        }

        // Draw window + handle manual resize
        // As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
        const float window_rounding = window->WindowRounding;
        const float window_border_size = window->WindowBorderSize;
        const HanaLovesMeWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
        const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
        const vsrect title_bar_rect = window->TitleBarRect();
        if (window->Collapsed)
        {
            // Title bar only
            float backup_border_size = style.FrameBorderSize;
            g.Style.FrameBorderSize = window->WindowBorderSize;
            ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBgCollapsed);
            RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
            g.Style.FrameBorderSize = backup_border_size;
        } else
        {
            // Window background
            if (!(flags & HanaLovesMeWindowFlags_NoBackground))
            {
                ImU32 bg_col = GetColorU32(GetWindowBgColorIdxFromFlags(flags));
                float alpha = 1.0f;
                if (g.NextWindowData.BgAlphaCond != 0)
                    alpha = g.NextWindowData.BgAlphaVal;
                if (alpha != 1.0f)
                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
                window->DrawList->AddRectFilled(window->Pos + vsize(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & HanaLovesMeWindowFlags_NoTitleBar) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Bot);
            }
            g.NextWindowData.BgAlphaCond = 0;

            // Title bar
            if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
            {
                ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBg);
                window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
            }

            // Menu bar
            if (flags & HanaLovesMeWindowFlags_MenuBar)
            {
                vsrect menu_bar_rect = window->MenuBarRect();
                menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
                window->DrawList->AddRectFilled(menu_bar_rect.Min + vsize(window_border_size, 0), menu_bar_rect.Max - vsize(window_border_size, 0), GetColorU32(HanaLovesMeCol_MenuBarBg), (flags & HanaLovesMeWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
                if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
                    window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(HanaLovesMeCol_Border), style.FrameBorderSize);
            }

            // Scrollbars
            if (window->ScrollbarX)
                Scrollbar(HanaLovesMeAxis_X);
            if (window->ScrollbarY)
                Scrollbar(HanaLovesMeAxis_Y);

            // Render resize grips (after their input handling so we don't have a frame of latency)
            if (!(flags & HanaLovesMeWindowFlags_NoResize))
            {
                for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
                {
                    const HanaLovesMeResizeGripDef& grip = resize_grip_def[resize_grip_n];
                    const vsize corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(window_border_size, grip_draw_size) : vsize(grip_draw_size, window_border_size)));
                    window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(grip_draw_size, window_border_size) : vsize(window_border_size, grip_draw_size)));
                    window->DrawList->PathArcToFast(vsize(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
                    window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
                }
            }

            // Borders
            RenderOuterBorders(window);
        }

        // Draw navigation selection/windowing rectangle border
        if (g.NavWindowingTargetAnim == window)
        {
            float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
            vsrect bb = window->Rect();
            bb.Expand(g.FontSize);
            if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
            {
                bb.Expand(-g.FontSize - 1.0f);
                rounding = window->WindowRounding;
            }
            window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
        }

        // Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
        window->SizeFullAtLastBegin = window->SizeFull;

        // Update various regions. Variables they depends on are set above in this function.
        // FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
        window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
        window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
        window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
        window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

        // Setup drawing context
        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
        window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
        window->DC.GroupOffset.x = 0.0f;
        window->DC.ColumnsOffset.x = 0.0f;
        window->DC.CursorStartPos = window->Pos + vsize(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
        window->DC.CursorPos = window->DC.CursorStartPos;
        window->DC.CursorPosPrevLine = window->DC.CursorPos;
        window->DC.CursorMaxPos = window->DC.CursorStartPos;
        window->DC.CurrentLineSize = window->DC.PrevLineSize = vsize(0.0f, 0.0f);
        window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
        window->DC.NavHideHighlightOneFrame = false;
        window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
        window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
        window->DC.NavLayerActiveMaskNext = 0x00;
        window->DC.MenuBarAppending = false;
        window->DC.ChildWindows.resize(0);
        window->DC.LayoutType = HanaLovesMeLayoutType_Vertical;
        window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : HanaLovesMeLayoutType_Vertical;
        window->DC.FocusCounterAll = window->DC.FocusCounterTab = -1;
        window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : HanaLovesMeItemFlags_Default_;
        window->DC.ItemWidth = window->ItemWidthDefault;
        window->DC.TextWrapPos = -1.0f; // disabled
        window->DC.ItemFlagsStack.resize(0);
        window->DC.ItemWidthStack.resize(0);
        window->DC.TextWrapPosStack.resize(0);
        window->DC.CurrentColumns = NULL;
        window->DC.TreeDepth = 0;
        window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
        window->DC.StateStohnly = &window->StateStohnly;
        window->DC.GroupStack.resize(0);
        window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

        if ((flags & HanaLovesMeWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
        {
            window->DC.ItemFlags = parent_window->DC.ItemFlags;
            window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
        }

        if (window->AutoFitFramesX > 0)
            window->AutoFitFramesX--;
        if (window->AutoFitFramesY > 0)
            window->AutoFitFramesY--;

        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
        if (want_focus)
        {
            FocusWindow(window);
            NavInitWindow(window, false);
        }

        // Title bar
        if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
        {
            // Close & collapse button are on layer 1 (same as menus) and don't default focus
            const HanaLovesMeItemFlags item_flags_backup = window->DC.ItemFlags;
            window->DC.ItemFlags |= HanaLovesMeItemFlags_NoNavDefaultFocus;
            window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Menu;
            window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Menu);

            // Collapse button
            if (!(flags & HanaLovesMeWindowFlags_NoCollapse))
                if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
                    window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

            // Close button
            if (p_open != NULL)
            {
                const float rad = g.FontSize * 0.5f;
                if (CloseButton(window->GetID("#CLOSE"), vsize(window->Pos.x + window->Size.x - style.FramePadding.x - rad, window->Pos.y + style.FramePadding.y + rad), rad + 1))
                    * p_open = false;
            }

            window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Main;
            window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Main);
            window->DC.ItemFlags = item_flags_backup;

            // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
            // FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
            const char* UNSAVED_DOCUMENT_MARKER = "*";
            float marker_size_x = (flags & HanaLovesMeWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
            vsize text_size = CalcTextSize(name, NULL, true) + vsize(marker_size_x, 0.0f);
            vsrect text_r = title_bar_rect;
            float pad_left = (flags & HanaLovesMeWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
            float pad_right = (p_open == NULL) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
            if (style.WindowTitleAlign.x > 0.0f)
                pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
            text_r.Min.x += pad_left;
            text_r.Max.x -= pad_right;
            vsrect clip_rect = text_r;
            clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
            RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
            if (flags & HanaLovesMeWindowFlags_UnsavedDocument)
            {
                vsize marker_pos = vsize(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + vsize(2 - marker_size_x, 0.0f);
                vsize off = vsize(0.0f, (float)(int)(-g.FontSize * 0.25f));
                RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, vsize(0, style.WindowTitleAlign.y), &clip_rect);
            }
        }

        // Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
        window->OuterRectClipped = window->Rect();
        window->OuterRectClipped.ClipWith(window->ClipRect);

        // Pressing CTRL+C while holding on a window copy its content to the clipboard
        // This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
        // Maybe we can support CTRL+C on every element?
        /*
        if (g.ActiveId == move_id)
            if (g.IO.KeyCtrl && IsKeyPressedMap(HanaLovesMeKey_C))
                LogToClipboard();
        */

        // Inner rectangle
        // We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
        window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
        window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & HanaLovesMeWindowFlags_MenuBar) || !(flags & HanaLovesMeWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
        window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
        window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
        //window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

        // Inner clipping rectangle
        // Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
        window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
        window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
        window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
        window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

        // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
        // This is useful to allow creating context menus on title bar only, etc.
        window->DC.LastItemId = window->MoveId;
        window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? HanaLovesMeItemStatusFlags_HoveredRect : 0;
        window->DC.LastItemRect = title_bar_rect;
#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
        if (!(window->Flags & HanaLovesMeWindowFlags_NoTitleBar))
            HanaLovesMe_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);
#endif
    } else
    {
        // Append
        SetCurrentWindow(window);
    }

    PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
    if (first_begin_of_the_frame)
        window->WriteAccessed = false;

    window->BeginCount++;
    g.NextWindowData.Clear();

    if (flags & HanaLovesMeWindowFlags_ChildWindow)
    {
        // Child window can be out of sight and have "negative" clip windows.
        // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
        IM_ASSERT((flags & HanaLovesMeWindowFlags_NoTitleBar) != 0);
        if (!(flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
            if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
                window->HiddenFramesCanSkipItems = 1;

        // Completely hide along with parent or if parent is collapsed
        if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
            window->HiddenFramesCanSkipItems = 1;
    }

    // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
    if (style.Alpha <= 0.0f)
        window->HiddenFramesCanSkipItems = 1;

    // Update the Hidden flag
    window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);

    // Update the SkipItems flag, used to early out of all items functions (no layout required)
    bool skip_items = false;
    if (window->Collapsed || !window->Active || window->Hidden)
        if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
            skip_items = true;
    window->SkipItems = skip_items;

    return !skip_items;
}

bool HanaLovesMe::BeginColorPickerBackground(const char* name, bool* p_open, HanaLovesMeWindowFlags flags)
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	const HanaLovesMeStyle& style = g.Style;
	IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
	IM_ASSERT(g.FrameScopeActive);                  // Forgot to call HanaLovesMe::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called HanaLovesMe::Render() or HanaLovesMe::EndFrame() and haven't called HanaLovesMe::NewFrame() again yet

	// Find or create
	HanaLovesMeWindow * window = FindWindowByName(name);
	const bool window_just_created = (window == NULL);
	if (window_just_created)
	{
		vsize size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : vsize(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
		window = CreateNewWindow(name, size_on_first_use, flags);
	}

	// Automatically disable manual moving/resizing when NoInputs is set
	if ((flags & HanaLovesMeWindowFlags_NoInputs) == HanaLovesMeWindowFlags_NoInputs)
		flags |= HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoResize;

	if (flags & HanaLovesMeWindowFlags_NavFlattened)
		IM_ASSERT(flags & HanaLovesMeWindowFlags_ChildWindow);

	const int current_frame = g.FrameCount;
	const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

	// Update the Appearing flag
	bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window);
	}
	window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, true);

	// Update Flags, LastFrameActive, BeginOrderXXX fields
	if (first_begin_of_the_frame)
	{
		window->Flags = (HanaLovesMeWindowFlags)flags;
		window->LastFrameActive = current_frame;
		window->BeginOrderWithinParent = 0;
		window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
	}
	else
	{
		flags = window->Flags;
	}

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	HanaLovesMeWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
	HanaLovesMeWindow* parent_window = first_begin_of_the_frame ? ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
	IM_ASSERT(parent_window != NULL || !(flags & HanaLovesMeWindowFlags_ChildWindow));

	// Add to stack
	// We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
	g.CurrentWindowStack.push_back(window);
	g.CurrentWindow = NULL;
	CheckStacksSize(window, true);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		popup_ref.Window = window;
		g.BeginPopupStack.push_back(popup_ref);
		window->PopupId = popup_ref.PopupId;
	}

	if (window_just_appearing_after_hidden_for_resize && !(flags & HanaLovesMeWindowFlags_ChildWindow))
		window->NavLastIds[0] = 0;

	// Process SetNextWindow***() calls
	bool window_pos_set_by_api = false;
	bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
	if (g.NextWindowData.PosCond)
	{
		window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
		if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
		{
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window->SetWindowPosVal = g.NextWindowData.PosVal;
			window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
			window->SetWindowPosAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);
		}
		else
		{
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
		}
	}
	if (g.NextWindowData.SizeCond)
	{
		window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
		window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
	}
	if (g.NextWindowData.ContentSizeCond)
	{
		// Adjust passed "client size" to become a "window size"
		window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
		if (window->SizeContentsExplicit.y != 0.0f)
			window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
	}
	else if (first_begin_of_the_frame)
	{
		window->SizeContentsExplicit = vsize(0.0f, 0.0f);
	}
	if (g.NextWindowData.CollapsedCond)
		SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
	if (g.NextWindowData.FocusCond)
		FocusWindow(window);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, false);

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if (first_begin_of_the_frame)
	{
		// Initialize
		const bool window_is_child_tooltip = (flags & HanaLovesMeWindowFlags_ChildWindow) && (flags & HanaLovesMeWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
		UpdateWindowParentAndRootLinks(window, flags, parent_window);

		window->Active = true;
		window->HasCloseButton = (p_open != NULL);
		window->ClipRect = xuifloatcolor(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
		window->IDStack.resize(1);

		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
		// The title bar always display the 'name' parameter, so we only update the string stohnly if it needs to be visible to the end-user elsewhere.
		bool window_title_visible_elsewhere = false;
		if (g.NavWindowingList != NULL && (window->Flags & HanaLovesMeWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
			window_title_visible_elsewhere = true;
		if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
		{
			size_t buf_len = (size_t)window->NameBufLen;
			window->Name = ImStrdupcpy(window->Name, &buf_len, name);
			window->NameBufLen = (int)buf_len;
		}

		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

		// Update contents size from last frame for auto-fitting (or use explicit size)
		window->SizeContents = CalcSizeContents(window);
		if (window->HiddenFramesCanSkipItems > 0)
			window->HiddenFramesCanSkipItems--;
		if (window->HiddenFramesCannotSkipItems > 0)
			window->HiddenFramesCannotSkipItems--;

		// Hide new windows for one frame until they calculate their size
		if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
			window->HiddenFramesCannotSkipItems = 1;

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		// We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
		if (window_just_activated_by_user && (flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) != 0)
		{
			window->HiddenFramesCannotSkipItems = 1;
			if (flags & HanaLovesMeWindowFlags_AlwaysAutoResize)
			{
				if (!window_size_x_set_by_api)
					window->Size.x = window->SizeFull.x = 0.f;
				if (!window_size_y_set_by_api)
					window->Size.y = window->SizeFull.y = 0.f;
				window->SizeContents = vsize(0.f, 0.f);
			}
		}

		SetCurrentWindow(window);

		// Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
			window->WindowBorderSize = style.ChildBorderSize;
		else
			window->WindowBorderSize = ((flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
		window->WindowPadding = style.WindowPadding;
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & (HanaLovesMeWindowFlags_AlwaysUseWindowPadding | HanaLovesMeWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
			window->WindowPadding = vsize(0.0f, (flags & HanaLovesMeWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
		window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
		window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar) && !(flags & HanaLovesMeWindowFlags_NoCollapse))
		{
			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
			vsrect title_bar_rect = window->TitleBarRect();
			if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
				window->WantCollapseToggle = true;
			if (window->WantCollapseToggle)
			{
				window->Collapsed = !window->Collapsed;
				MarkIniSettingsDirty(window);
				FocusWindow(window);
			}
		}
		else
		{
			window->Collapsed = false;
		}
		window->WantCollapseToggle = false;

		// SIZE

		// Calculate auto-fit size, handle automatic resize
		const vsize size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
		vsize size_full_modified(FLT_MAX, FLT_MAX);
		if ((flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && !window->Collapsed)
		{
			// Using SetNextWindowSize() overrides HanaLovesMeWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if (!window_size_x_set_by_api)
				window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
			if (!window_size_y_set_by_api)
				window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
		}
		else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
		{
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor HanaLovesMeWindowFlags_AlwaysAutoResize when collapsed.
			if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
				window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
			if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
				window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
			if (!window->Collapsed)
				MarkIniSettingsDirty(window);
		}

		// Apply minimum/maximum window size constraints and final size
		window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
		window->Size = window->Collapsed && !(flags & HanaLovesMeWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

		// SCROLLBAR STATUS

		// Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
		if (!window->Collapsed)
		{
			// When reading the current size we need to read it after size constraints have been applied
			float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
			float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
			window->ScrollbarY = (flags & HanaLovesMeWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & HanaLovesMeWindowFlags_NoScrollbar));
			window->ScrollbarX = (flags & HanaLovesMeWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & HanaLovesMeWindowFlags_NoScrollbar) && (flags & HanaLovesMeWindowFlags_HorizontalScrollbar));
			if (window->ScrollbarX && !window->ScrollbarY)
				window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & HanaLovesMeWindowFlags_NoScrollbar);
			window->ScrollbarSizes = vsize(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
		}

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if (window_just_activated_by_user)
		{
			window->AutoPosLastDirection = HanaLovesMeDir_None;
			if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api)
				window->Pos = g.BeginPopupStack.back().OpenPopupPos;
		}

		// Position child window
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
		{
			IM_ASSERT(parent_window && parent_window->Active);
			window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
			parent_window->DC.ChildWindows.push_back(window);
			if (!(flags & HanaLovesMeWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
				window->Pos = parent_window->DC.CursorPos;
		}

		const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
		if (window_pos_with_pivot)
			SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
		else if ((flags & HanaLovesMeWindowFlags_ChildMenu) != 0)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
			window->Pos = FindBestWindowPosForPopup(window);

		// Clamp position so it stays visible
		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
		vsrect viewport_rect(GetViewportRect());
		if (!window_pos_set_by_api && !(flags & HanaLovesMeWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
		{
			if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
			{
				vsize clamp_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
				ClampWindowRect(window, viewport_rect, clamp_padding);
			}
		}
		window->Pos = ImFloor(window->Pos);

		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
		window->WindowRounding = (flags & HanaLovesMeWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & HanaLovesMeWindowFlags_Popup) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

		// Apply scrolling
		window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
		window->ScrollTarget = vsize(FLT_MAX, FLT_MAX);

		// Apply window focus (new and reactivated windows are moved to front)
		bool want_focus = false;
		if (window_just_activated_by_user && !(flags & HanaLovesMeWindowFlags_NoFocusOnAppearing))
		{
			if (flags & HanaLovesMeWindowFlags_Popup)
				want_focus = true;
			else if ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Tooltip)) == 0)
				want_focus = true;
		}

		// Handle manual resize: Resize Grips, Borders, Gamepad
		int border_held = -1;
		ImU32 resize_grip_col[4] = { 0 };
		const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
		const float grip_draw_size = (float)(int)ImMax(9 * 1.0f, window->WindowRounding + 0.0f + g.FontSize * 0.f); // sedmapickamaterina
		if (!window->Collapsed)
			UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);
		window->ResizeBorderHeld = (signed char)border_held;

		// Default item width. Make it proportional to window size if window manually resizes
		if (window->Size.x > 0.0f && !(flags & HanaLovesMeWindowFlags_Tooltip) && !(flags & HanaLovesMeWindowFlags_AlwaysAutoResize))
			window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
		else
			window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

		// DRAWING

		// Setup draw list and outer clipping rectangle
		window->DrawList->Clear();
		window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
		window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & HanaLovesMeWindowFlags_Popup) && !window_is_child_tooltip)
			PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
		else
			PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

		// Draw modal window background (darkens what is behind them, all viewports)
		const bool dim_bg_for_modal = (flags & HanaLovesMeWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
		const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
		if (dim_bg_for_modal || dim_bg_for_window_list)
		{
			const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? HanaLovesMeCol_ModalWindowDimBg : HanaLovesMeCol_NavWindowingDimBg, g.DimBgRatio);
			window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
		}

		// Draw navigation selection/windowing rectangle background
		if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
		{
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
				window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
		}

		// Draw window + handle manual resize
		// As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
		const float window_rounding = window->WindowRounding;
		const float window_border_size = window->WindowBorderSize;
		const HanaLovesMeWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
		const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
		const vsrect title_bar_rect = window->TitleBarRect();
		if (window->Collapsed)
		{
			// Title bar only
			float backup_border_size = style.FrameBorderSize;
			g.Style.FrameBorderSize = window->WindowBorderSize;
			ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBgCollapsed);
			RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
			g.Style.FrameBorderSize = backup_border_size;
		}
		else
		{
			// Window background
			auto backgroundColor = xuicolor(40, 40, 40, 255);
			auto borderColor = xuicolor(10, 10, 10, 255);
			auto innerBorderColor = xuicolor(60, 60, 60, 255);
			window->DrawList->AddRectFilledMultiColor(window->Pos + vsize(0, window->TitleBarHeight()), window->Pos + window->Size + vsize(1, 1), backgroundColor, backgroundColor, backgroundColor, backgroundColor);
			window->DrawList->AddRect(window->Pos + vsize(1, window->TitleBarHeight() + 1), window->Pos + window->Size, innerBorderColor, 0, false, 0.4);
			window->DrawList->AddRect(window->Pos + vsize(0, window->TitleBarHeight()), window->Pos + window->Size + vsize(1, 1), borderColor, 0, false, 0.4);

			// Title bar
			if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
			{
				ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBg);
				window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
			}

			// Menu bar
			if (flags & HanaLovesMeWindowFlags_MenuBar)
			{
				vsrect menu_bar_rect = window->MenuBarRect();
				menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
				window->DrawList->AddRectFilled(menu_bar_rect.Min + vsize(window_border_size, 0), menu_bar_rect.Max - vsize(window_border_size, 0), GetColorU32(HanaLovesMeCol_MenuBarBg), (flags & HanaLovesMeWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
				if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
					window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(HanaLovesMeCol_Border), style.FrameBorderSize);
			}

			// Scrollbars
			if (window->ScrollbarX)
				Scrollbar(HanaLovesMeAxis_X);
			if (window->ScrollbarY)
				Scrollbar(HanaLovesMeAxis_Y);

			// Render resize grips (after their input handling so we don't have a frame of latency)
			if (!(flags & HanaLovesMeWindowFlags_NoResize))
			{
				for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
				{
					const HanaLovesMeResizeGripDef& grip = resize_grip_def[resize_grip_n];
					const vsize corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(window_border_size, grip_draw_size) : vsize(grip_draw_size, window_border_size)));
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(grip_draw_size, window_border_size) : vsize(window_border_size, grip_draw_size)));
					window->DrawList->PathArcToFast(vsize(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
					window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
				}
			}

			// Borders
			RenderOuterBorders(window);
		}

		// Draw navigation selection/windowing rectangle border
		if (g.NavWindowingTargetAnim == window)
		{
			float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
			{
				bb.Expand(-g.FontSize - 1.0f);
				rounding = window->WindowRounding;
			}
			window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
		}

		// Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
		window->SizeFullAtLastBegin = window->SizeFull;

		// Update various regions. Variables they depends on are set above in this function.
		// FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
		window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
		window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
		window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
		window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
		window->DC.GroupOffset.x = 0.0f;
		window->DC.ColumnsOffset.x = 0.0f;
		window->DC.CursorStartPos = window->Pos + vsize(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
		window->DC.CursorPos = window->DC.CursorStartPos;
		window->DC.CursorPosPrevLine = window->DC.CursorPos;
		window->DC.CursorMaxPos = window->DC.CursorStartPos;
		window->DC.CurrentLineSize = window->DC.PrevLineSize = vsize(0.0f, 0.0f);
		window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
		window->DC.NavHideHighlightOneFrame = false;
		window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
		window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
		window->DC.NavLayerActiveMaskNext = 0x00;
		window->DC.MenuBarAppending = false;
		window->DC.ChildWindows.resize(0);
		window->DC.LayoutType = HanaLovesMeLayoutType_Vertical;
		window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : HanaLovesMeLayoutType_Vertical;
		window->DC.FocusCounterAll = window->DC.FocusCounterTab = -1;
		window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : HanaLovesMeItemFlags_Default_;
		window->DC.ItemWidth = window->ItemWidthDefault;
		window->DC.TextWrapPos = -1.0f; // disabled
		window->DC.ItemFlagsStack.resize(0);
		window->DC.ItemWidthStack.resize(0);
		window->DC.TextWrapPosStack.resize(0);
		window->DC.CurrentColumns = NULL;
		window->DC.TreeDepth = 0;
		window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
		window->DC.StateStohnly = &window->StateStohnly;
		window->DC.GroupStack.resize(0);
		window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
		{
			window->DC.ItemFlags = parent_window->DC.ItemFlags;
			window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
		}

		if (window->AutoFitFramesX > 0)
			window->AutoFitFramesX--;
		if (window->AutoFitFramesY > 0)
			window->AutoFitFramesY--;

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		if (want_focus)
		{
			FocusWindow(window);
			NavInitWindow(window, false);
		}

		// Title bar
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
		{
			// Close & collapse button are on layer 1 (same as menus) and don't default focus
			const HanaLovesMeItemFlags item_flags_backup = window->DC.ItemFlags;
			window->DC.ItemFlags |= HanaLovesMeItemFlags_NoNavDefaultFocus;
			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Menu;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Menu);

			// Collapse button
			if (!(flags & HanaLovesMeWindowFlags_NoCollapse))
				if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
					window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

			// Close button
			if (p_open != NULL)
			{
				const float rad = g.FontSize * 0.5f;
				if (CloseButton(window->GetID("#CLOSE"), vsize(window->Pos.x + window->Size.x - style.FramePadding.x - rad, window->Pos.y + style.FramePadding.y + rad), rad + 1))
					* p_open = false;
			}

			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Main;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Main);
			window->DC.ItemFlags = item_flags_backup;

			// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
			// FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
			const char* UNSAVED_DOCUMENT_MARKER = "*";
			float marker_size_x = (flags & HanaLovesMeWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
			vsize text_size = CalcTextSize(name, NULL, true) + vsize(marker_size_x, 0.0f);
			vsrect text_r = title_bar_rect;
			float pad_left = (flags & HanaLovesMeWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			float pad_right = (p_open == NULL) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			if (style.WindowTitleAlign.x > 0.0f)
				pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
			text_r.Min.x += pad_left;
			text_r.Max.x -= pad_right;
			vsrect clip_rect = text_r;
			clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
			RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
			if (flags & HanaLovesMeWindowFlags_UnsavedDocument)
			{
				vsize marker_pos = vsize(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + vsize(2 - marker_size_x, 0.0f);
				vsize off = vsize(0.0f, (float)(int)(-g.FontSize * 0.25f));
				RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, vsize(0, style.WindowTitleAlign.y), &clip_rect);
			}
		}

		// Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
		window->OuterRectClipped = window->Rect();
		window->OuterRectClipped.ClipWith(window->ClipRect);

		// Pressing CTRL+C while holding on a window copy its content to the clipboard
		// This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
		// Maybe we can support CTRL+C on every element?
		/*
		if (g.ActiveId == move_id)
			if (g.IO.KeyCtrl && IsKeyPressedMap(HanaLovesMeKey_C))
				LogToClipboard();
		*/

		// Inner rectangle
		// We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
		window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
		window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & HanaLovesMeWindowFlags_MenuBar) || !(flags & HanaLovesMeWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
		window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
		window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
		//window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

		// Inner clipping rectangle
		// Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
		window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

		// We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
		// This is useful to allow creating context menus on title bar only, etc.
		window->DC.LastItemId = window->MoveId;
		window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? HanaLovesMeItemStatusFlags_HoveredRect : 0;
		window->DC.LastItemRect = title_bar_rect;
#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
		if (!(window->Flags & HanaLovesMeWindowFlags_NoTitleBar))
			HanaLovesMe_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);
#endif
	}
	else
	{
		// Append
		SetCurrentWindow(window);
	}

	PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	if (first_begin_of_the_frame)
		window->WriteAccessed = false;

	window->BeginCount++;
	g.NextWindowData.Clear();

	if (flags & HanaLovesMeWindowFlags_ChildWindow)
	{
		// Child window can be out of sight and have "negative" clip windows.
		// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
		IM_ASSERT((flags & HanaLovesMeWindowFlags_NoTitleBar) != 0);
		if (!(flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
			if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
				window->HiddenFramesCanSkipItems = 1;

		// Completely hide along with parent or if parent is collapsed
		if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
			window->HiddenFramesCanSkipItems = 1;
	}

	// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
	if (style.Alpha <= 0.0f)
		window->HiddenFramesCanSkipItems = 1;

	// Update the Hidden flag
	window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);

	// Update the SkipItems flag, used to early out of all items functions (no layout required)
	bool skip_items = false;
	if (window->Collapsed || !window->Active || window->Hidden)
		if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
			skip_items = true;
	window->SkipItems = skip_items;

	return !skip_items;
}

bool HanaLovesMe::BeginTabsBackground(const char* name, bool* p_open, HanaLovesMeWindowFlags flags)
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	const HanaLovesMeStyle& style = g.Style;
	IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
	IM_ASSERT(g.FrameScopeActive);                  // Forgot to call HanaLovesMe::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called HanaLovesMe::Render() or HanaLovesMe::EndFrame() and haven't called HanaLovesMe::NewFrame() again yet

	// Find or create
	HanaLovesMeWindow * window = FindWindowByName(name);
	const bool window_just_created = (window == NULL);
	if (window_just_created)
	{
		vsize size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : vsize(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
		window = CreateNewWindow(name, size_on_first_use, flags);
	}

	// Automatically disable manual moving/resizing when NoInputs is set
	if ((flags & HanaLovesMeWindowFlags_NoInputs) == HanaLovesMeWindowFlags_NoInputs)
		flags |= HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoResize;

	if (flags & HanaLovesMeWindowFlags_NavFlattened)
		IM_ASSERT(flags & HanaLovesMeWindowFlags_ChildWindow);

	const int current_frame = g.FrameCount;
	const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

	// Update the Appearing flag
	bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window);
	}
	window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, true);

	// Update Flags, LastFrameActive, BeginOrderXXX fields
	if (first_begin_of_the_frame)
	{
		window->Flags = (HanaLovesMeWindowFlags)flags;
		window->LastFrameActive = current_frame;
		window->BeginOrderWithinParent = 0;
		window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
	}
	else
	{
		flags = window->Flags;
	}

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	HanaLovesMeWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
	HanaLovesMeWindow* parent_window = first_begin_of_the_frame ? ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
	IM_ASSERT(parent_window != NULL || !(flags & HanaLovesMeWindowFlags_ChildWindow));

	// Add to stack
	// We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
	g.CurrentWindowStack.push_back(window);
	g.CurrentWindow = NULL;
	CheckStacksSize(window, true);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		popup_ref.Window = window;
		g.BeginPopupStack.push_back(popup_ref);
		window->PopupId = popup_ref.PopupId;
	}

	if (window_just_appearing_after_hidden_for_resize && !(flags & HanaLovesMeWindowFlags_ChildWindow))
		window->NavLastIds[0] = 0;

	// Process SetNextWindow***() calls
	bool window_pos_set_by_api = false;
	bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
	if (g.NextWindowData.PosCond)
	{
		window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
		if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
		{
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window->SetWindowPosVal = g.NextWindowData.PosVal;
			window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
			window->SetWindowPosAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);
		}
		else
		{
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
		}
	}
	if (g.NextWindowData.SizeCond)
	{
		window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
		window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
	}
	if (g.NextWindowData.ContentSizeCond)
	{
		// Adjust passed "client size" to become a "window size"
		window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
		if (window->SizeContentsExplicit.y != 0.0f)
			window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
	}
	else if (first_begin_of_the_frame)
	{
		window->SizeContentsExplicit = vsize(0.0f, 0.0f);
	}
	if (g.NextWindowData.CollapsedCond)
		SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
	if (g.NextWindowData.FocusCond)
		FocusWindow(window);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, false);

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if (first_begin_of_the_frame)
	{
		// Initialize
		const bool window_is_child_tooltip = (flags & HanaLovesMeWindowFlags_ChildWindow) && (flags & HanaLovesMeWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
		UpdateWindowParentAndRootLinks(window, flags, parent_window);

		window->Active = true;
		window->HasCloseButton = (p_open != NULL);
		window->ClipRect = xuifloatcolor(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
		window->IDStack.resize(1);

		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
		// The title bar always display the 'name' parameter, so we only update the string stohnly if it needs to be visible to the end-user elsewhere.
		bool window_title_visible_elsewhere = false;
		if (g.NavWindowingList != NULL && (window->Flags & HanaLovesMeWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
			window_title_visible_elsewhere = true;
		if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
		{
			size_t buf_len = (size_t)window->NameBufLen;
			window->Name = ImStrdupcpy(window->Name, &buf_len, name);
			window->NameBufLen = (int)buf_len;
		}

		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

		// Update contents size from last frame for auto-fitting (or use explicit size)
		window->SizeContents = CalcSizeContents(window);
		if (window->HiddenFramesCanSkipItems > 0)
			window->HiddenFramesCanSkipItems--;
		if (window->HiddenFramesCannotSkipItems > 0)
			window->HiddenFramesCannotSkipItems--;

		// Hide new windows for one frame until they calculate their size
		if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
			window->HiddenFramesCannotSkipItems = 1;

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		// We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
		if (window_just_activated_by_user && (flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) != 0)
		{
			window->HiddenFramesCannotSkipItems = 1;
			if (flags & HanaLovesMeWindowFlags_AlwaysAutoResize)
			{
				if (!window_size_x_set_by_api)
					window->Size.x = window->SizeFull.x = 0.f;
				if (!window_size_y_set_by_api)
					window->Size.y = window->SizeFull.y = 0.f;
				window->SizeContents = vsize(0.f, 0.f);
			}
		}

		SetCurrentWindow(window);

		// Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
			window->WindowBorderSize = style.ChildBorderSize;
		else
			window->WindowBorderSize = ((flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
		window->WindowPadding = style.WindowPadding;
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & (HanaLovesMeWindowFlags_AlwaysUseWindowPadding | HanaLovesMeWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
			window->WindowPadding = vsize(0.0f, (flags & HanaLovesMeWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
		window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
		window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar) && !(flags & HanaLovesMeWindowFlags_NoCollapse))
		{
			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
			vsrect title_bar_rect = window->TitleBarRect();
			if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
				window->WantCollapseToggle = true;
			if (window->WantCollapseToggle)
			{
				window->Collapsed = !window->Collapsed;
				MarkIniSettingsDirty(window);
				FocusWindow(window);
			}
		}
		else
		{
			window->Collapsed = false;
		}
		window->WantCollapseToggle = false;

		// SIZE

		// Calculate auto-fit size, handle automatic resize
		const vsize size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
		vsize size_full_modified(FLT_MAX, FLT_MAX);
		if ((flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && !window->Collapsed)
		{
			// Using SetNextWindowSize() overrides HanaLovesMeWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if (!window_size_x_set_by_api)
				window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
			if (!window_size_y_set_by_api)
				window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
		}
		else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
		{
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor HanaLovesMeWindowFlags_AlwaysAutoResize when collapsed.
			if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
				window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
			if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
				window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
			if (!window->Collapsed)
				MarkIniSettingsDirty(window);
		}

		// Apply minimum/maximum window size constraints and final size
		window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
		window->Size = window->Collapsed && !(flags & HanaLovesMeWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

		// SCROLLBAR STATUS

		// Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
		if (!window->Collapsed)
		{
			// When reading the current size we need to read it after size constraints have been applied
			float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
			float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
			window->ScrollbarY = (flags & HanaLovesMeWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & HanaLovesMeWindowFlags_NoScrollbar));
			window->ScrollbarX = (flags & HanaLovesMeWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & HanaLovesMeWindowFlags_NoScrollbar) && (flags & HanaLovesMeWindowFlags_HorizontalScrollbar));
			if (window->ScrollbarX && !window->ScrollbarY)
				window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & HanaLovesMeWindowFlags_NoScrollbar);
			window->ScrollbarSizes = vsize(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
		}

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if (window_just_activated_by_user)
		{
			window->AutoPosLastDirection = HanaLovesMeDir_None;
			if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api)
				window->Pos = g.BeginPopupStack.back().OpenPopupPos;
		}

		// Position child window
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
		{
			IM_ASSERT(parent_window && parent_window->Active);
			window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
			parent_window->DC.ChildWindows.push_back(window);
			if (!(flags & HanaLovesMeWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
				window->Pos = parent_window->DC.CursorPos;
		}

		const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
		if (window_pos_with_pivot)
			SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
		else if ((flags & HanaLovesMeWindowFlags_ChildMenu) != 0)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
			window->Pos = FindBestWindowPosForPopup(window);

		// Clamp position so it stays visible
		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
		vsrect viewport_rect(GetViewportRect());
		if (!window_pos_set_by_api && !(flags & HanaLovesMeWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
		{
			if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
			{
				vsize clamp_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
				ClampWindowRect(window, viewport_rect, clamp_padding);
			}
		}
		window->Pos = ImFloor(window->Pos);

		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
		window->WindowRounding = (flags & HanaLovesMeWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & HanaLovesMeWindowFlags_Popup) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

		// Apply scrolling
		window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
		window->ScrollTarget = vsize(FLT_MAX, FLT_MAX);

		// Apply window focus (new and reactivated windows are moved to front)
		bool want_focus = false;
		if (window_just_activated_by_user && !(flags & HanaLovesMeWindowFlags_NoFocusOnAppearing))
		{
			if (flags & HanaLovesMeWindowFlags_Popup)
				want_focus = true;
			else if ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Tooltip)) == 0)
				want_focus = true;
		}

		// Handle manual resize: Resize Grips, Borders, Gamepad
		int border_held = -1;
		ImU32 resize_grip_col[4] = { 0 };
		const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
		const float grip_draw_size = (float)(int)ImMax(9 * 1.0f, window->WindowRounding + 0.0f + g.FontSize * 0.f); // sedmapickamaterina
		if (!window->Collapsed)
			UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);
		window->ResizeBorderHeld = (signed char)border_held;

		// Default item width. Make it proportional to window size if window manually resizes
		if (window->Size.x > 0.0f && !(flags & HanaLovesMeWindowFlags_Tooltip) && !(flags & HanaLovesMeWindowFlags_AlwaysAutoResize))
			window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
		else
			window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

		// DRAWING

		// Setup draw list and outer clipping rectangle
		window->DrawList->Clear();
		window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
		window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & HanaLovesMeWindowFlags_Popup) && !window_is_child_tooltip)
			PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
		else
			PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

		// Draw modal window background (darkens what is behind them, all viewports)
		const bool dim_bg_for_modal = (flags & HanaLovesMeWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
		const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
		if (dim_bg_for_modal || dim_bg_for_window_list)
		{
			const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? HanaLovesMeCol_ModalWindowDimBg : HanaLovesMeCol_NavWindowingDimBg, g.DimBgRatio);
			window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
		}

		// Draw navigation selection/windowing rectangle background
		if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
		{
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
				window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
		}

		// Draw window + handle manual resize
		// As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
		const float window_rounding = window->WindowRounding;
		const float window_border_size = window->WindowBorderSize;
		const HanaLovesMeWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
		const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
		const vsrect title_bar_rect = window->TitleBarRect();
		if (window->Collapsed)
		{
			// Title bar only
			float backup_border_size = style.FrameBorderSize;
			g.Style.FrameBorderSize = window->WindowBorderSize;
			ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBgCollapsed);
			RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
			g.Style.FrameBorderSize = backup_border_size;
		}
		else
		{
			// Window background   outerBorderColor
			auto backgroundColor = xuicolor(12, 12, 12);
			auto outerBorderColor = xuicolor(48, 48, 48);
			auto innerBorderColor = xuicolor(0, 0, 0);
                                                                                                                             /// TABLINEFIX 622
			window->DrawList->AddRect(window->Pos + vsize(0, window->TitleBarHeight() - 2), window->Pos + window->Size - vsize(0, 592), outerBorderColor, 0, false, 0.4); /// TABLINEFIX
			window->DrawList->AddRect(window->Pos + vsize(0, window->TitleBarHeight() - 2), window->Pos + window->Size - vsize(1, 592), innerBorderColor, 0, false, 0.4);
			window->DrawList->AddRect(window->Pos + vsize(0, window->TitleBarHeight() - 2), window->Pos + window->Size - vsize(2, 592), backgroundColor, 0, false, 0.4);
			//window->DrawList->AddRectFilledMultiColor(window->Pos + vsize(-2, window->TitleBarHeight() - 1), window->Pos + window->Size, backgroundColor, backgroundColor, backgroundColor, backgroundColor);

			// Title bar
			if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
			{
				ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBg);
				window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
			}

			// Menu bar
			if (flags & HanaLovesMeWindowFlags_MenuBar)
			{
				vsrect menu_bar_rect = window->MenuBarRect();
				menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
				window->DrawList->AddRectFilled(menu_bar_rect.Min + vsize(window_border_size, 0), menu_bar_rect.Max - vsize(window_border_size, 0), GetColorU32(HanaLovesMeCol_MenuBarBg), (flags & HanaLovesMeWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
				if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
					window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(HanaLovesMeCol_Border), style.FrameBorderSize);
			}

			// Scrollbars
			if (window->ScrollbarX)
				Scrollbar(HanaLovesMeAxis_X);
			if (window->ScrollbarY)
				Scrollbar(HanaLovesMeAxis_Y);

			// Render resize grips (after their input handling so we don't have a frame of latency)
			if (!(flags & HanaLovesMeWindowFlags_NoResize))
			{
				for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
				{
					const HanaLovesMeResizeGripDef& grip = resize_grip_def[resize_grip_n];
					const vsize corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(window_border_size, grip_draw_size) : vsize(grip_draw_size, window_border_size)));
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(grip_draw_size, window_border_size) : vsize(window_border_size, grip_draw_size)));
					window->DrawList->PathArcToFast(vsize(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
					window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
				}
			}

			// Borders
			RenderOuterBorders(window);
		}

		// Draw navigation selection/windowing rectangle border
		if (g.NavWindowingTargetAnim == window)
		{
			float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
			{
				bb.Expand(-g.FontSize - 1.0f);
				rounding = window->WindowRounding;
			}
			window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
		}

		// Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
		window->SizeFullAtLastBegin = window->SizeFull;

		// Update various regions. Variables they depends on are set above in this function.
		// FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
		window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
		window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
		window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
		window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
		window->DC.GroupOffset.x = 0.0f;
		window->DC.ColumnsOffset.x = 0.0f;
		window->DC.CursorStartPos = window->Pos + vsize(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
		window->DC.CursorPos = window->DC.CursorStartPos;
		window->DC.CursorPosPrevLine = window->DC.CursorPos;
		window->DC.CursorMaxPos = window->DC.CursorStartPos;
		window->DC.CurrentLineSize = window->DC.PrevLineSize = vsize(0.0f, 0.0f);
		window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
		window->DC.NavHideHighlightOneFrame = false;
		window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
		window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
		window->DC.NavLayerActiveMaskNext = 0x00;
		window->DC.MenuBarAppending = false;
		window->DC.ChildWindows.resize(0);
		window->DC.LayoutType = HanaLovesMeLayoutType_Vertical;
		window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : HanaLovesMeLayoutType_Vertical;
		window->DC.FocusCounterAll = window->DC.FocusCounterTab = -1;
		window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : HanaLovesMeItemFlags_Default_;
		window->DC.ItemWidth = window->ItemWidthDefault;
		window->DC.TextWrapPos = -1.0f; // disabled
		window->DC.ItemFlagsStack.resize(0);
		window->DC.ItemWidthStack.resize(0);
		window->DC.TextWrapPosStack.resize(0);
		window->DC.CurrentColumns = NULL;
		window->DC.TreeDepth = 0;
		window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
		window->DC.StateStohnly = &window->StateStohnly;
		window->DC.GroupStack.resize(0);
		window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
		{
			window->DC.ItemFlags = parent_window->DC.ItemFlags;
			window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
		}

		if (window->AutoFitFramesX > 0)
			window->AutoFitFramesX--;
		if (window->AutoFitFramesY > 0)
			window->AutoFitFramesY--;

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		if (want_focus)
		{
			FocusWindow(window);
			NavInitWindow(window, false);
		}

		// Title bar
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
		{
			// Close & collapse button are on layer 1 (same as menus) and don't default focus
			const HanaLovesMeItemFlags item_flags_backup = window->DC.ItemFlags;
			window->DC.ItemFlags |= HanaLovesMeItemFlags_NoNavDefaultFocus;
			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Menu;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Menu);

			// Collapse button
			if (!(flags & HanaLovesMeWindowFlags_NoCollapse))
				if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
					window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

			// Close button
			if (p_open != NULL)
			{
				const float rad = g.FontSize * 0.5f;
				if (CloseButton(window->GetID("#CLOSE"), vsize(window->Pos.x + window->Size.x - style.FramePadding.x - rad, window->Pos.y + style.FramePadding.y + rad), rad + 1))
					* p_open = false;
			}

			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Main;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Main);
			window->DC.ItemFlags = item_flags_backup;

			// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
			// FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
			const char* UNSAVED_DOCUMENT_MARKER = "*";
			float marker_size_x = (flags & HanaLovesMeWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
			vsize text_size = CalcTextSize(name, NULL, true) + vsize(marker_size_x, 0.0f);
			vsrect text_r = title_bar_rect;
			float pad_left = (flags & HanaLovesMeWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			float pad_right = (p_open == NULL) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			if (style.WindowTitleAlign.x > 0.0f)
				pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
			text_r.Min.x += pad_left;
			text_r.Max.x -= pad_right;
			vsrect clip_rect = text_r;
			clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
			RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
			if (flags & HanaLovesMeWindowFlags_UnsavedDocument)
			{
				vsize marker_pos = vsize(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + vsize(2 - marker_size_x, 0.0f);
				vsize off = vsize(0.0f, (float)(int)(-g.FontSize * 0.25f));
				RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, vsize(0, style.WindowTitleAlign.y), &clip_rect);
			}
		}

		// Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
		window->OuterRectClipped = window->Rect();
		window->OuterRectClipped.ClipWith(window->ClipRect);

		// Pressing CTRL+C while holding on a window copy its content to the clipboard
		// This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
		// Maybe we can support CTRL+C on every element?
		/*
		if (g.ActiveId == move_id)
			if (g.IO.KeyCtrl && IsKeyPressedMap(HanaLovesMeKey_C))
				LogToClipboard();
		*/

		// Inner rectangle
		// We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
		window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
		window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & HanaLovesMeWindowFlags_MenuBar) || !(flags & HanaLovesMeWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
		window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
		window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
		//window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

		// Inner clipping rectangle
		// Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
		window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

		// We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
		// This is useful to allow creating context menus on title bar only, etc.
		window->DC.LastItemId = window->MoveId;
		window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? HanaLovesMeItemStatusFlags_HoveredRect : 0;
		window->DC.LastItemRect = title_bar_rect;
#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
		if (!(window->Flags & HanaLovesMeWindowFlags_NoTitleBar))
			HanaLovesMe_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);
#endif
	}
	else
	{
		// Append
		SetCurrentWindow(window);
	}

	PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	if (first_begin_of_the_frame)
		window->WriteAccessed = false;

	window->BeginCount++;
	g.NextWindowData.Clear();

	if (flags & HanaLovesMeWindowFlags_ChildWindow)
	{
		// Child window can be out of sight and have "negative" clip windows.
		// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
		IM_ASSERT((flags & HanaLovesMeWindowFlags_NoTitleBar) != 0);
		if (!(flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
			if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
				window->HiddenFramesCanSkipItems = 1;

		// Completely hide along with parent or if parent is collapsed
		if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
			window->HiddenFramesCanSkipItems = 1;
	}

	// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
	if (style.Alpha <= 0.0f)
		window->HiddenFramesCanSkipItems = 1;

	// Update the Hidden flag
	window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);

	// Update the SkipItems flag, used to early out of all items functions (no layout required)
	bool skip_items = false;
	if (window->Collapsed || !window->Active || window->Hidden)
		if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
			skip_items = true;
	window->SkipItems = skip_items;

	return !skip_items;
}

bool HanaLovesMe::BeginEndBorder(const char* name, bool* p_open, HanaLovesMeWindowFlags flags)
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	const HanaLovesMeStyle& style = g.Style;
	IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
	IM_ASSERT(g.FrameScopeActive);                  // Forgot to call HanaLovesMe::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called HanaLovesMe::Render() or HanaLovesMe::EndFrame() and haven't called HanaLovesMe::NewFrame() again yet

	// Find or create
	HanaLovesMeWindow * window = FindWindowByName(name);
	const bool window_just_created = (window == NULL);
	if (window_just_created)
	{
		vsize size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : vsize(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
		window = CreateNewWindow(name, size_on_first_use, flags);
	}

	// Automatically disable manual moving/resizing when NoInputs is set
	if ((flags & HanaLovesMeWindowFlags_NoInputs) == HanaLovesMeWindowFlags_NoInputs)
		flags |= HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoResize;

	if (flags & HanaLovesMeWindowFlags_NavFlattened)
		IM_ASSERT(flags & HanaLovesMeWindowFlags_ChildWindow);

	const int current_frame = g.FrameCount;
	const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

	// Update the Appearing flag
	bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window);
	}
	window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, true);

	// Update Flags, LastFrameActive, BeginOrderXXX fields
	if (first_begin_of_the_frame)
	{
		window->Flags = (HanaLovesMeWindowFlags)flags;
		window->LastFrameActive = current_frame;
		window->BeginOrderWithinParent = 0;
		window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
	}
	else
	{
		flags = window->Flags;
	}

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	HanaLovesMeWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
	HanaLovesMeWindow* parent_window = first_begin_of_the_frame ? ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
	IM_ASSERT(parent_window != NULL || !(flags & HanaLovesMeWindowFlags_ChildWindow));

	// Add to stack
	// We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
	g.CurrentWindowStack.push_back(window);
	g.CurrentWindow = NULL;
	CheckStacksSize(window, true);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		popup_ref.Window = window;
		g.BeginPopupStack.push_back(popup_ref);
		window->PopupId = popup_ref.PopupId;
	}

	if (window_just_appearing_after_hidden_for_resize && !(flags & HanaLovesMeWindowFlags_ChildWindow))
		window->NavLastIds[0] = 0;

	// Process SetNextWindow***() calls
	bool window_pos_set_by_api = false;
	bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
	if (g.NextWindowData.PosCond)
	{
		window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
		if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
		{
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window->SetWindowPosVal = g.NextWindowData.PosVal;
			window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
			window->SetWindowPosAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);
		}
		else
		{
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
		}
	}
	if (g.NextWindowData.SizeCond)
	{
		window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
		window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
	}
	if (g.NextWindowData.ContentSizeCond)
	{
		// Adjust passed "client size" to become a "window size"
		window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
		if (window->SizeContentsExplicit.y != 0.0f)
			window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
	}
	else if (first_begin_of_the_frame)
	{
		window->SizeContentsExplicit = vsize(0.0f, 0.0f);
	}
	if (g.NextWindowData.CollapsedCond)
		SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
	if (g.NextWindowData.FocusCond)
		FocusWindow(window);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, false);

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if (first_begin_of_the_frame)
	{
		// Initialize
		const bool window_is_child_tooltip = (flags & HanaLovesMeWindowFlags_ChildWindow) && (flags & HanaLovesMeWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
		UpdateWindowParentAndRootLinks(window, flags, parent_window);

		window->Active = true;
		window->HasCloseButton = (p_open != NULL);
		window->ClipRect = xuifloatcolor(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
		window->IDStack.resize(1);

		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
		// The title bar always display the 'name' parameter, so we only update the string stohnly if it needs to be visible to the end-user elsewhere.
		bool window_title_visible_elsewhere = false;
		if (g.NavWindowingList != NULL && (window->Flags & HanaLovesMeWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
			window_title_visible_elsewhere = true;
		if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
		{
			size_t buf_len = (size_t)window->NameBufLen;
			window->Name = ImStrdupcpy(window->Name, &buf_len, name);
			window->NameBufLen = (int)buf_len;
		}

		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

		// Update contents size from last frame for auto-fitting (or use explicit size)
		window->SizeContents = CalcSizeContents(window);
		if (window->HiddenFramesCanSkipItems > 0)
			window->HiddenFramesCanSkipItems--;
		if (window->HiddenFramesCannotSkipItems > 0)
			window->HiddenFramesCannotSkipItems--;

		// Hide new windows for one frame until they calculate their size
		if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
			window->HiddenFramesCannotSkipItems = 1;

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		// We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
		if (window_just_activated_by_user && (flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) != 0)
		{
			window->HiddenFramesCannotSkipItems = 1;
			if (flags & HanaLovesMeWindowFlags_AlwaysAutoResize)
			{
				if (!window_size_x_set_by_api)
					window->Size.x = window->SizeFull.x = 0.f;
				if (!window_size_y_set_by_api)
					window->Size.y = window->SizeFull.y = 0.f;
				window->SizeContents = vsize(0.f, 0.f);
			}
		}

		SetCurrentWindow(window);

		// Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
			window->WindowBorderSize = style.ChildBorderSize;
		else
			window->WindowBorderSize = ((flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
		window->WindowPadding = style.WindowPadding;
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & (HanaLovesMeWindowFlags_AlwaysUseWindowPadding | HanaLovesMeWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
			window->WindowPadding = vsize(0.0f, (flags & HanaLovesMeWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
		window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
		window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar) && !(flags & HanaLovesMeWindowFlags_NoCollapse))
		{
			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
			vsrect title_bar_rect = window->TitleBarRect();
			if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
				window->WantCollapseToggle = true;
			if (window->WantCollapseToggle)
			{
				window->Collapsed = !window->Collapsed;
				MarkIniSettingsDirty(window);
				FocusWindow(window);
			}
		}
		else
		{
			window->Collapsed = false;
		}
		window->WantCollapseToggle = false;

		// SIZE

		// Calculate auto-fit size, handle automatic resize
		const vsize size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
		vsize size_full_modified(FLT_MAX, FLT_MAX);
		if ((flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && !window->Collapsed)
		{
			// Using SetNextWindowSize() overrides HanaLovesMeWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if (!window_size_x_set_by_api)
				window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
			if (!window_size_y_set_by_api)
				window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
		}
		else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
		{
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor HanaLovesMeWindowFlags_AlwaysAutoResize when collapsed.
			if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
				window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
			if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
				window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
			if (!window->Collapsed)
				MarkIniSettingsDirty(window);
		}

		// Apply minimum/maximum window size constraints and final size
		window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
		window->Size = window->Collapsed && !(flags & HanaLovesMeWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

		// SCROLLBAR STATUS

		// Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
		if (!window->Collapsed)
		{
			// When reading the current size we need to read it after size constraints have been applied
			float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
			float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
			window->ScrollbarY = (flags & HanaLovesMeWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & HanaLovesMeWindowFlags_NoScrollbar));
			window->ScrollbarX = (flags & HanaLovesMeWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & HanaLovesMeWindowFlags_NoScrollbar) && (flags & HanaLovesMeWindowFlags_HorizontalScrollbar));
			if (window->ScrollbarX && !window->ScrollbarY)
				window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & HanaLovesMeWindowFlags_NoScrollbar);
			window->ScrollbarSizes = vsize(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
		}

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if (window_just_activated_by_user)
		{
			window->AutoPosLastDirection = HanaLovesMeDir_None;
			if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api)
				window->Pos = g.BeginPopupStack.back().OpenPopupPos;
		}

		// Position child window
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
		{
			IM_ASSERT(parent_window && parent_window->Active);
			window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
			parent_window->DC.ChildWindows.push_back(window);
			if (!(flags & HanaLovesMeWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
				window->Pos = parent_window->DC.CursorPos;
		}

		const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
		if (window_pos_with_pivot)
			SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
		else if ((flags & HanaLovesMeWindowFlags_ChildMenu) != 0)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
			window->Pos = FindBestWindowPosForPopup(window);

		// Clamp position so it stays visible
		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
		vsrect viewport_rect(GetViewportRect());
		if (!window_pos_set_by_api && !(flags & HanaLovesMeWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
		{
			if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
			{
				vsize clamp_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
				ClampWindowRect(window, viewport_rect, clamp_padding);
			}
		}
		window->Pos = ImFloor(window->Pos);

		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
		window->WindowRounding = (flags & HanaLovesMeWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & HanaLovesMeWindowFlags_Popup) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

		// Apply scrolling
		window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
		window->ScrollTarget = vsize(FLT_MAX, FLT_MAX);

		// Apply window focus (new and reactivated windows are moved to front)
		bool want_focus = false;
		if (window_just_activated_by_user && !(flags & HanaLovesMeWindowFlags_NoFocusOnAppearing))
		{
			if (flags & HanaLovesMeWindowFlags_Popup)
				want_focus = true;
			else if ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Tooltip)) == 0)
				want_focus = true;
		}

		// Handle manual resize: Resize Grips, Borders, Gamepad
		int border_held = -1;
		ImU32 resize_grip_col[4] = { 0 };
		const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
		const float grip_draw_size = (float)(int)ImMax(9 * 1.0f, window->WindowRounding + 0.0f + g.FontSize * 0.f); // sedmapickamaterina
		if (!window->Collapsed)
			UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);
		window->ResizeBorderHeld = (signed char)border_held;

		// Default item width. Make it proportional to window size if window manually resizes
		if (window->Size.x > 0.0f && !(flags & HanaLovesMeWindowFlags_Tooltip) && !(flags & HanaLovesMeWindowFlags_AlwaysAutoResize))
			window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
		else
			window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

		// DRAWING

		// Setup draw list and outer clipping rectangle
		window->DrawList->Clear();
		window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
		window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & HanaLovesMeWindowFlags_Popup) && !window_is_child_tooltip)
			PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
		else
			PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

		// Draw modal window background (darkens what is behind them, all viewports)
		const bool dim_bg_for_modal = (flags & HanaLovesMeWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
		const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
		if (dim_bg_for_modal || dim_bg_for_window_list)
		{
			const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? HanaLovesMeCol_ModalWindowDimBg : HanaLovesMeCol_NavWindowingDimBg, g.DimBgRatio);
			window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
		}

		// Draw navigation selection/windowing rectangle background
		if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
		{
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
				window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
		}

		// Draw window + handle manual resize
		// As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
		const float window_rounding = window->WindowRounding;
		const float window_border_size = window->WindowBorderSize;
		const HanaLovesMeWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
		const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
		const vsrect title_bar_rect = window->TitleBarRect();
		if (window->Collapsed)
		{
			// Title bar only
			float backup_border_size = style.FrameBorderSize;
			g.Style.FrameBorderSize = window->WindowBorderSize;
			ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBgCollapsed);
			RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
			g.Style.FrameBorderSize = backup_border_size;
		}
		else
		{
			// Window background
			auto backgroundColor = GetColorU32(HanaLovesMeCol_WindowBg);
			auto innerBorderColor = xuicolor(255, 255, 255);

			//window->DrawList->AddRectFilled(window->Pos + vsize(0, window->TitleBarHeight()), window->Pos + window->Size, backgroundColor, 0.f);
			window->DrawList->AddRect(window->Pos + vsize(1, window->TitleBarHeight() + 1), window->Pos + window->Size, innerBorderColor, 0, false, 1.f);

			// Title bar
			if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
			{
				ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBg);
				window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
			}

			// Menu bar
			if (flags & HanaLovesMeWindowFlags_MenuBar)
			{
				vsrect menu_bar_rect = window->MenuBarRect();
				menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
				window->DrawList->AddRectFilled(menu_bar_rect.Min + vsize(window_border_size, 0), menu_bar_rect.Max - vsize(window_border_size, 0), GetColorU32(HanaLovesMeCol_MenuBarBg), (flags & HanaLovesMeWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
				if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
					window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(HanaLovesMeCol_Border), style.FrameBorderSize);
			}

			// Scrollbars
			if (window->ScrollbarX)
				Scrollbar(HanaLovesMeAxis_X);
			if (window->ScrollbarY)
				Scrollbar(HanaLovesMeAxis_Y);

			// Render resize grips (after their input handling so we don't have a frame of latency)
			if (!(flags & HanaLovesMeWindowFlags_NoResize))
			{
				for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
				{
					const HanaLovesMeResizeGripDef& grip = resize_grip_def[resize_grip_n];
					const vsize corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(window_border_size, grip_draw_size) : vsize(grip_draw_size, window_border_size)));
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(grip_draw_size, window_border_size) : vsize(window_border_size, grip_draw_size)));
					window->DrawList->PathArcToFast(vsize(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
					window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
				}
			}

			// Borders
			RenderOuterBorders(window);
		}

		// Draw navigation selection/windowing rectangle border
		if (g.NavWindowingTargetAnim == window)
		{
			float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
			{
				bb.Expand(-g.FontSize - 1.0f);
				rounding = window->WindowRounding;
			}
			window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
		}

		// Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
		window->SizeFullAtLastBegin = window->SizeFull;

		// Update various regions. Variables they depends on are set above in this function.
		// FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
		window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
		window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
		window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
		window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
		window->DC.GroupOffset.x = 0.0f;
		window->DC.ColumnsOffset.x = 0.0f;
		window->DC.CursorStartPos = window->Pos + vsize(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
		window->DC.CursorPos = window->DC.CursorStartPos;
		window->DC.CursorPosPrevLine = window->DC.CursorPos;
		window->DC.CursorMaxPos = window->DC.CursorStartPos;
		window->DC.CurrentLineSize = window->DC.PrevLineSize = vsize(0.0f, 0.0f);
		window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
		window->DC.NavHideHighlightOneFrame = false;
		window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
		window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
		window->DC.NavLayerActiveMaskNext = 0x00;
		window->DC.MenuBarAppending = false;
		window->DC.ChildWindows.resize(0);
		window->DC.LayoutType = HanaLovesMeLayoutType_Vertical;
		window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : HanaLovesMeLayoutType_Vertical;
		window->DC.FocusCounterAll = window->DC.FocusCounterTab = -1;
		window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : HanaLovesMeItemFlags_Default_;
		window->DC.ItemWidth = window->ItemWidthDefault;
		window->DC.TextWrapPos = -1.0f; // disabled
		window->DC.ItemFlagsStack.resize(0);
		window->DC.ItemWidthStack.resize(0);
		window->DC.TextWrapPosStack.resize(0);
		window->DC.CurrentColumns = NULL;
		window->DC.TreeDepth = 0;
		window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
		window->DC.StateStohnly = &window->StateStohnly;
		window->DC.GroupStack.resize(0);
		window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
		{
			window->DC.ItemFlags = parent_window->DC.ItemFlags;
			window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
		}

		if (window->AutoFitFramesX > 0)
			window->AutoFitFramesX--;
		if (window->AutoFitFramesY > 0)
			window->AutoFitFramesY--;

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		if (want_focus)
		{
			FocusWindow(window);
			NavInitWindow(window, false);
		}

		// Title bar
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
		{
			// Close & collapse button are on layer 1 (same as menus) and don't default focus
			const HanaLovesMeItemFlags item_flags_backup = window->DC.ItemFlags;
			window->DC.ItemFlags |= HanaLovesMeItemFlags_NoNavDefaultFocus;
			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Menu;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Menu);

			// Collapse button
			if (!(flags & HanaLovesMeWindowFlags_NoCollapse))
				if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
					window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

			// Close button
			if (p_open != NULL)
			{
				const float rad = g.FontSize * 0.5f;
				if (CloseButton(window->GetID("#CLOSE"), vsize(window->Pos.x + window->Size.x - style.FramePadding.x - rad, window->Pos.y + style.FramePadding.y + rad), rad + 1))
					* p_open = false;
			}

			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Main;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Main);
			window->DC.ItemFlags = item_flags_backup;

			// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
			// FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
			const char* UNSAVED_DOCUMENT_MARKER = "*";
			float marker_size_x = (flags & HanaLovesMeWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
			vsize text_size = CalcTextSize(name, NULL, true) + vsize(marker_size_x, 0.0f);
			vsrect text_r = title_bar_rect;
			float pad_left = (flags & HanaLovesMeWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			float pad_right = (p_open == NULL) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			if (style.WindowTitleAlign.x > 0.0f)
				pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
			text_r.Min.x += pad_left;
			text_r.Max.x -= pad_right;
			vsrect clip_rect = text_r;
			clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
			RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
			if (flags & HanaLovesMeWindowFlags_UnsavedDocument)
			{
				vsize marker_pos = vsize(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + vsize(2 - marker_size_x, 0.0f);
				vsize off = vsize(0.0f, (float)(int)(-g.FontSize * 0.25f));
				RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, vsize(0, style.WindowTitleAlign.y), &clip_rect);
			}
		}

		// Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
		window->OuterRectClipped = window->Rect();
		window->OuterRectClipped.ClipWith(window->ClipRect);

		// Pressing CTRL+C while holding on a window copy its content to the clipboard
		// This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
		// Maybe we can support CTRL+C on every element?
		/*
		if (g.ActiveId == move_id)
			if (g.IO.KeyCtrl && IsKeyPressedMap(HanaLovesMeKey_C))
				LogToClipboard();
		*/

		// Inner rectangle
		// We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
		window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
		window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & HanaLovesMeWindowFlags_MenuBar) || !(flags & HanaLovesMeWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
		window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
		window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
		//window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

		// Inner clipping rectangle
		// Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
		window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

		// We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
		// This is useful to allow creating context menus on title bar only, etc.
		window->DC.LastItemId = window->MoveId;
		window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? HanaLovesMeItemStatusFlags_HoveredRect : 0;
		window->DC.LastItemRect = title_bar_rect;
#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
		if (!(window->Flags & HanaLovesMeWindowFlags_NoTitleBar))
			HanaLovesMe_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);
#endif
	}
	else
	{
		// Append
		SetCurrentWindow(window);
	}

	PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	if (first_begin_of_the_frame)
		window->WriteAccessed = false;

	window->BeginCount++;
	g.NextWindowData.Clear();

	if (flags & HanaLovesMeWindowFlags_ChildWindow)
	{
		// Child window can be out of sight and have "negative" clip windows.
		// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
		IM_ASSERT((flags & HanaLovesMeWindowFlags_NoTitleBar) != 0);
		if (!(flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
			if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
				window->HiddenFramesCanSkipItems = 1;

		// Completely hide along with parent or if parent is collapsed
		if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
			window->HiddenFramesCanSkipItems = 1;
	}

	// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
	if (style.Alpha <= 0.0f)
		window->HiddenFramesCanSkipItems = 1;

	// Update the Hidden flag
	window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);

	// Update the SkipItems flag, used to early out of all items functions (no layout required)
	bool skip_items = false;
	if (window->Collapsed || !window->Active || window->Hidden)
		if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
			skip_items = true;
	window->SkipItems = skip_items;

	return !skip_items;
}

bool HanaLovesMe::BeginMenuBackground(const char* name, bool* p_open, HanaLovesMeWindowFlags flags)
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	const HanaLovesMeStyle& style = g.Style;
	IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
	IM_ASSERT(g.FrameScopeActive);                  // Forgot to call HanaLovesMe::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called HanaLovesMe::Render() or HanaLovesMe::EndFrame() and haven't called HanaLovesMe::NewFrame() again yet

	// Find or create
	HanaLovesMeWindow * window = FindWindowByName(name);
	const bool window_just_created = (window == NULL);
	if (window_just_created)
	{
		vsize size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : vsize(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
		window = CreateNewWindow(name, size_on_first_use, flags);
	}

	// Automatically disable manual moving/resizing when NoInputs is set
	if ((flags & HanaLovesMeWindowFlags_NoInputs) == HanaLovesMeWindowFlags_NoInputs)
		flags |= HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoResize;

	if (flags & HanaLovesMeWindowFlags_NavFlattened)
		IM_ASSERT(flags & HanaLovesMeWindowFlags_ChildWindow);

	const int current_frame = g.FrameCount;
	const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

	// Update the Appearing flag
	bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window);
	}
	window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, true);

	// Update Flags, LastFrameActive, BeginOrderXXX fields
	if (first_begin_of_the_frame)
	{
		window->Flags = (HanaLovesMeWindowFlags)flags;
		window->LastFrameActive = current_frame;
		window->BeginOrderWithinParent = 0;
		window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
	}
	else
	{
		flags = window->Flags;
	}

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	HanaLovesMeWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
	HanaLovesMeWindow* parent_window = first_begin_of_the_frame ? ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
	IM_ASSERT(parent_window != NULL || !(flags & HanaLovesMeWindowFlags_ChildWindow));

	// Add to stack
	// We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
	g.CurrentWindowStack.push_back(window);
	g.CurrentWindow = NULL;
	CheckStacksSize(window, true);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		popup_ref.Window = window;
		g.BeginPopupStack.push_back(popup_ref);
		window->PopupId = popup_ref.PopupId;
	}

	if (window_just_appearing_after_hidden_for_resize && !(flags & HanaLovesMeWindowFlags_ChildWindow))
		window->NavLastIds[0] = 0;

	// Process SetNextWindow***() calls
	bool window_pos_set_by_api = false;
	bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
	if (g.NextWindowData.PosCond)
	{
		window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
		if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
		{
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window->SetWindowPosVal = g.NextWindowData.PosVal;
			window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
			window->SetWindowPosAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);
		}
		else
		{
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
		}
	}
	if (g.NextWindowData.SizeCond)
	{
		window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
		window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
	}
	if (g.NextWindowData.ContentSizeCond)
	{
		// Adjust passed "client size" to become a "window size"
		window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
		if (window->SizeContentsExplicit.y != 0.0f)
			window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
	}
	else if (first_begin_of_the_frame)
	{
		window->SizeContentsExplicit = vsize(0.0f, 0.0f);
	}
	if (g.NextWindowData.CollapsedCond)
		SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
	if (g.NextWindowData.FocusCond)
		FocusWindow(window);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, false);

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if (first_begin_of_the_frame)
	{
		// Initialize
		const bool window_is_child_tooltip = (flags & HanaLovesMeWindowFlags_ChildWindow) && (flags & HanaLovesMeWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
		UpdateWindowParentAndRootLinks(window, flags, parent_window);

		window->Active = true;
		window->HasCloseButton = (p_open != NULL);
		window->ClipRect = xuifloatcolor(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
		window->IDStack.resize(1);

		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
		// The title bar always display the 'name' parameter, so we only update the string stohnly if it needs to be visible to the end-user elsewhere.
		bool window_title_visible_elsewhere = false;
		if (g.NavWindowingList != NULL && (window->Flags & HanaLovesMeWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
			window_title_visible_elsewhere = true;
		if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
		{
			size_t buf_len = (size_t)window->NameBufLen;
			window->Name = ImStrdupcpy(window->Name, &buf_len, name);
			window->NameBufLen = (int)buf_len;
		}

		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

		// Update contents size from last frame for auto-fitting (or use explicit size)
		window->SizeContents = CalcSizeContents(window);
		if (window->HiddenFramesCanSkipItems > 0)
			window->HiddenFramesCanSkipItems--;
		if (window->HiddenFramesCannotSkipItems > 0)
			window->HiddenFramesCannotSkipItems--;

		// Hide new windows for one frame until they calculate their size
		if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
			window->HiddenFramesCannotSkipItems = 1;

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		// We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
		if (window_just_activated_by_user && (flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) != 0)
		{
			window->HiddenFramesCannotSkipItems = 1;
			if (flags & HanaLovesMeWindowFlags_AlwaysAutoResize)
			{
				if (!window_size_x_set_by_api)
					window->Size.x = window->SizeFull.x = 0.f;
				if (!window_size_y_set_by_api)
					window->Size.y = window->SizeFull.y = 0.f;
				window->SizeContents = vsize(0.f, 0.f);
			}
		}

		SetCurrentWindow(window);

		// Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
			window->WindowBorderSize = style.ChildBorderSize;
		else
			window->WindowBorderSize = ((flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
		window->WindowPadding = style.WindowPadding;
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & (HanaLovesMeWindowFlags_AlwaysUseWindowPadding | HanaLovesMeWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
			window->WindowPadding = vsize(0.0f, (flags & HanaLovesMeWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
		window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
		window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar) && !(flags & HanaLovesMeWindowFlags_NoCollapse))
		{
			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
			vsrect title_bar_rect = window->TitleBarRect();
			if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
				window->WantCollapseToggle = true;
			if (window->WantCollapseToggle)
			{
				window->Collapsed = !window->Collapsed;
				MarkIniSettingsDirty(window);
				FocusWindow(window);
			}
		}
		else
		{
			window->Collapsed = false;
		}
		window->WantCollapseToggle = false;

		// SIZE

		// Calculate auto-fit size, handle automatic resize
		const vsize size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
		vsize size_full_modified(FLT_MAX, FLT_MAX);
		if ((flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && !window->Collapsed)
		{
			// Using SetNextWindowSize() overrides HanaLovesMeWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if (!window_size_x_set_by_api)
				window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
			if (!window_size_y_set_by_api)
				window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
		}
		else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
		{
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor HanaLovesMeWindowFlags_AlwaysAutoResize when collapsed.
			if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
				window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
			if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
				window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
			if (!window->Collapsed)
				MarkIniSettingsDirty(window);
		}

		// Apply minimum/maximum window size constraints and final size
		window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
		window->Size = window->Collapsed && !(flags & HanaLovesMeWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

		// SCROLLBAR STATUS

		// Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
		if (!window->Collapsed)
		{
			// When reading the current size we need to read it after size constraints have been applied
			float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
			float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
			window->ScrollbarY = (flags & HanaLovesMeWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & HanaLovesMeWindowFlags_NoScrollbar));
			window->ScrollbarX = (flags & HanaLovesMeWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & HanaLovesMeWindowFlags_NoScrollbar) && (flags & HanaLovesMeWindowFlags_HorizontalScrollbar));
			if (window->ScrollbarX && !window->ScrollbarY)
				window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & HanaLovesMeWindowFlags_NoScrollbar);
			window->ScrollbarSizes = vsize(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
		}

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if (window_just_activated_by_user)
		{
			window->AutoPosLastDirection = HanaLovesMeDir_None;
			if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api)
				window->Pos = g.BeginPopupStack.back().OpenPopupPos;
		}

		// Position child window
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
		{
			IM_ASSERT(parent_window && parent_window->Active);
			window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
			parent_window->DC.ChildWindows.push_back(window);
			if (!(flags & HanaLovesMeWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
				window->Pos = parent_window->DC.CursorPos;
		}

		const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
		if (window_pos_with_pivot)
			SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
		else if ((flags & HanaLovesMeWindowFlags_ChildMenu) != 0)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
			window->Pos = FindBestWindowPosForPopup(window);

		// Clamp position so it stays visible
		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
		vsrect viewport_rect(GetViewportRect());
		if (!window_pos_set_by_api && !(flags & HanaLovesMeWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
		{
			if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
			{
				vsize clamp_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
				ClampWindowRect(window, viewport_rect, clamp_padding);
			}
		}
		window->Pos = ImFloor(window->Pos);

		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
		window->WindowRounding = (flags & HanaLovesMeWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & HanaLovesMeWindowFlags_Popup) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

		// Apply scrolling
		window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
		window->ScrollTarget = vsize(FLT_MAX, FLT_MAX);

		// Apply window focus (new and reactivated windows are moved to front)
		bool want_focus = false;
		if (window_just_activated_by_user && !(flags & HanaLovesMeWindowFlags_NoFocusOnAppearing))
		{
			if (flags & HanaLovesMeWindowFlags_Popup)
				want_focus = true;
			else if ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Tooltip)) == 0)
				want_focus = true;
		}

		// Handle manual resize: Resize Grips, Borders, Gamepad
		int border_held = -1;
		ImU32 resize_grip_col[4] = { 0 };
		const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
		const float grip_draw_size = (float)(int)ImMax(9 * 1.0f, window->WindowRounding + 0.0f + g.FontSize * 0.f); // sedmapickamaterina
		if (!window->Collapsed)
			UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);
		window->ResizeBorderHeld = (signed char)border_held;

		// Default item width. Make it proportional to window size if window manually resizes
		if (window->Size.x > 0.0f && !(flags & HanaLovesMeWindowFlags_Tooltip) && !(flags & HanaLovesMeWindowFlags_AlwaysAutoResize))
			window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
		else
			window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

		// DRAWING

		// Setup draw list and outer clipping rectangle
		window->DrawList->Clear();
		window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
		window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & HanaLovesMeWindowFlags_Popup) && !window_is_child_tooltip)
			PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
		else
			PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

		// Draw modal window background (darkens what is behind them, all viewports)
		const bool dim_bg_for_modal = (flags & HanaLovesMeWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
		const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
		if (dim_bg_for_modal || dim_bg_for_window_list)
		{
			const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? HanaLovesMeCol_ModalWindowDimBg : HanaLovesMeCol_NavWindowingDimBg, g.DimBgRatio);
			window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
		}

		// Draw navigation selection/windowing rectangle background
		if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
		{
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
				window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
		}

		// Draw window + handle manual resize
		// As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
		const float window_rounding = window->WindowRounding;
		const float window_border_size = window->WindowBorderSize;
		const HanaLovesMeWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
		const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
		const vsrect title_bar_rect = window->TitleBarRect();
		if (window->Collapsed)
		{
			// Title bar only
			float backup_border_size = style.FrameBorderSize;
			g.Style.FrameBorderSize = window->WindowBorderSize;
			ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBgCollapsed);
			RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
			g.Style.FrameBorderSize = backup_border_size;
		}
		else
		{
			// Window background
			auto backgroundColor = GetColorU32(HanaLovesMeCol_WindowBg);
			auto innerBorderColor = xuicolor(60, 60, 60);

			window->DrawList->AddRectFilled(window->Pos + vsize(0, window->TitleBarHeight()), window->Pos + window->Size, backgroundColor, 0.f);
			window->DrawList->AddRect(window->Pos + vsize(1, window->TitleBarHeight() + 1), window->Pos + window->Size - vsize(1, 1), innerBorderColor, 0, false, 0.4);

			window->DrawList->AddRect(window->Pos + vsize(5, window->TitleBarHeight() + 5), window->Pos + window->Size - vsize(5, 5), innerBorderColor, 0, false, 0.4);

			// Title bar
			if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
			{
				ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBg);
				window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
			}

			// Menu bar
			if (flags & HanaLovesMeWindowFlags_MenuBar)
			{
				vsrect menu_bar_rect = window->MenuBarRect();
				menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
				window->DrawList->AddRectFilled(menu_bar_rect.Min + vsize(window_border_size, 0), menu_bar_rect.Max - vsize(window_border_size, 0), GetColorU32(HanaLovesMeCol_MenuBarBg), (flags & HanaLovesMeWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
				if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
					window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(HanaLovesMeCol_Border), style.FrameBorderSize);
			}

			// Scrollbars
			if (window->ScrollbarX)
				Scrollbar(HanaLovesMeAxis_X);
			if (window->ScrollbarY)
				Scrollbar(HanaLovesMeAxis_Y);

			// Render resize grips (after their input handling so we don't have a frame of latency)
			if (!(flags & HanaLovesMeWindowFlags_NoResize))
			{
				for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
				{
					const HanaLovesMeResizeGripDef& grip = resize_grip_def[resize_grip_n];
					const vsize corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(window_border_size, grip_draw_size) : vsize(grip_draw_size, window_border_size)));
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(grip_draw_size, window_border_size) : vsize(window_border_size, grip_draw_size)));
					window->DrawList->PathArcToFast(vsize(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
					window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
				}
			}

			// Borders
			RenderOuterBorders(window);
		}

		// Draw navigation selection/windowing rectangle border
		if (g.NavWindowingTargetAnim == window)
		{
			float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
			{
				bb.Expand(-g.FontSize - 1.0f);
				rounding = window->WindowRounding;
			}
			window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
		}

		// Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
		window->SizeFullAtLastBegin = window->SizeFull;

		// Update various regions. Variables they depends on are set above in this function.
		// FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
		window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
		window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
		window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
		window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
		window->DC.GroupOffset.x = 0.0f;
		window->DC.ColumnsOffset.x = 0.0f;
		window->DC.CursorStartPos = window->Pos + vsize(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
		window->DC.CursorPos = window->DC.CursorStartPos;
		window->DC.CursorPosPrevLine = window->DC.CursorPos;
		window->DC.CursorMaxPos = window->DC.CursorStartPos;
		window->DC.CurrentLineSize = window->DC.PrevLineSize = vsize(0.0f, 0.0f);
		window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
		window->DC.NavHideHighlightOneFrame = false;
		window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
		window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
		window->DC.NavLayerActiveMaskNext = 0x00;
		window->DC.MenuBarAppending = false;
		window->DC.ChildWindows.resize(0);
		window->DC.LayoutType = HanaLovesMeLayoutType_Vertical;
		window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : HanaLovesMeLayoutType_Vertical;
		window->DC.FocusCounterAll = window->DC.FocusCounterTab = -1;
		window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : HanaLovesMeItemFlags_Default_;
		window->DC.ItemWidth = window->ItemWidthDefault;
		window->DC.TextWrapPos = -1.0f; // disabled
		window->DC.ItemFlagsStack.resize(0);
		window->DC.ItemWidthStack.resize(0);
		window->DC.TextWrapPosStack.resize(0);
		window->DC.CurrentColumns = NULL;
		window->DC.TreeDepth = 0;
		window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
		window->DC.StateStohnly = &window->StateStohnly;
		window->DC.GroupStack.resize(0);
		window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
		{
			window->DC.ItemFlags = parent_window->DC.ItemFlags;
			window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
		}

		if (window->AutoFitFramesX > 0)
			window->AutoFitFramesX--;
		if (window->AutoFitFramesY > 0)
			window->AutoFitFramesY--;

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		if (want_focus)
		{
			FocusWindow(window);
			NavInitWindow(window, false);
		}

		// Title bar
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
		{
			// Close & collapse button are on layer 1 (same as menus) and don't default focus
			const HanaLovesMeItemFlags item_flags_backup = window->DC.ItemFlags;
			window->DC.ItemFlags |= HanaLovesMeItemFlags_NoNavDefaultFocus;
			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Menu;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Menu);

			// Collapse button
			if (!(flags & HanaLovesMeWindowFlags_NoCollapse))
				if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
					window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

			// Close button
			if (p_open != NULL)
			{
				const float rad = g.FontSize * 0.5f;
				if (CloseButton(window->GetID("#CLOSE"), vsize(window->Pos.x + window->Size.x - style.FramePadding.x - rad, window->Pos.y + style.FramePadding.y + rad), rad + 1))
					* p_open = false;
			}

			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Main;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Main);
			window->DC.ItemFlags = item_flags_backup;

			// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
			// FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
			const char* UNSAVED_DOCUMENT_MARKER = "*";
			float marker_size_x = (flags & HanaLovesMeWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
			vsize text_size = CalcTextSize(name, NULL, true) + vsize(marker_size_x, 0.0f);
			vsrect text_r = title_bar_rect;
			float pad_left = (flags & HanaLovesMeWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			float pad_right = (p_open == NULL) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			if (style.WindowTitleAlign.x > 0.0f)
				pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
			text_r.Min.x += pad_left;
			text_r.Max.x -= pad_right;
			vsrect clip_rect = text_r;
			clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
			RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
			if (flags & HanaLovesMeWindowFlags_UnsavedDocument)
			{
				vsize marker_pos = vsize(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + vsize(2 - marker_size_x, 0.0f);
				vsize off = vsize(0.0f, (float)(int)(-g.FontSize * 0.25f));
				RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, vsize(0, style.WindowTitleAlign.y), &clip_rect);
			}
		}

		// Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
		window->OuterRectClipped = window->Rect();
		window->OuterRectClipped.ClipWith(window->ClipRect);

		// Pressing CTRL+C while holding on a window copy its content to the clipboard
		// This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
		// Maybe we can support CTRL+C on every element?
		/*
		if (g.ActiveId == move_id)
			if (g.IO.KeyCtrl && IsKeyPressedMap(HanaLovesMeKey_C))
				LogToClipboard();
		*/

		// Inner rectangle
		// We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
		window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
		window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & HanaLovesMeWindowFlags_MenuBar) || !(flags & HanaLovesMeWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
		window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
		window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
		//window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

		// Inner clipping rectangle
		// Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
		window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

		// We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
		// This is useful to allow creating context menus on title bar only, etc.
		window->DC.LastItemId = window->MoveId;
		window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? HanaLovesMeItemStatusFlags_HoveredRect : 0;
		window->DC.LastItemRect = title_bar_rect;
#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
		if (!(window->Flags & HanaLovesMeWindowFlags_NoTitleBar))
			HanaLovesMe_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);
#endif
	}
	else
	{
		// Append
		SetCurrentWindow(window);
	}

	PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	if (first_begin_of_the_frame)
		window->WriteAccessed = false;

	window->BeginCount++;
	g.NextWindowData.Clear();

	if (flags & HanaLovesMeWindowFlags_ChildWindow)
	{
		// Child window can be out of sight and have "negative" clip windows.
		// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
		IM_ASSERT((flags & HanaLovesMeWindowFlags_NoTitleBar) != 0);
		if (!(flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
			if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
				window->HiddenFramesCanSkipItems = 1;

		// Completely hide along with parent or if parent is collapsed
		if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
			window->HiddenFramesCanSkipItems = 1;
	}

	// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
	if (style.Alpha <= 0.0f)
		window->HiddenFramesCanSkipItems = 1;

	// Update the Hidden flag
	window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);

	// Update the SkipItems flag, used to early out of all items functions (no layout required)
	bool skip_items = false;
	if (window->Collapsed || !window->Active || window->Hidden)
		if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
			skip_items = true;
	window->SkipItems = skip_items;

	return !skip_items;
}

bool HanaLovesMe::BeginShadowBackground(const char* name, bool* p_open, HanaLovesMeWindowFlags flags)
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	const HanaLovesMeStyle& style = g.Style;
	IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
	IM_ASSERT(g.FrameScopeActive);                  // Forgot to call HanaLovesMe::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called HanaLovesMe::Render() or HanaLovesMe::EndFrame() and haven't called HanaLovesMe::NewFrame() again yet

	// Find or create
	HanaLovesMeWindow * window = FindWindowByName(name);
	const bool window_just_created = (window == NULL);
	if (window_just_created)
	{
		vsize size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : vsize(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
		window = CreateNewWindow(name, size_on_first_use, flags);
	}

	// Automatically disable manual moving/resizing when NoInputs is set
	if ((flags & HanaLovesMeWindowFlags_NoInputs) == HanaLovesMeWindowFlags_NoInputs)
		flags |= HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoResize;

	if (flags & HanaLovesMeWindowFlags_NavFlattened)
		IM_ASSERT(flags & HanaLovesMeWindowFlags_ChildWindow);

	const int current_frame = g.FrameCount;
	const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

	// Update the Appearing flag
	bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window);
	}
	window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, true);

	// Update Flags, LastFrameActive, BeginOrderXXX fields
	if (first_begin_of_the_frame)
	{
		window->Flags = (HanaLovesMeWindowFlags)flags;
		window->LastFrameActive = current_frame;
		window->BeginOrderWithinParent = 0;
		window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
	}
	else
	{
		flags = window->Flags;
	}

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	HanaLovesMeWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
	HanaLovesMeWindow* parent_window = first_begin_of_the_frame ? ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
	IM_ASSERT(parent_window != NULL || !(flags & HanaLovesMeWindowFlags_ChildWindow));

	// Add to stack
	// We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
	g.CurrentWindowStack.push_back(window);
	g.CurrentWindow = NULL;
	CheckStacksSize(window, true);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		popup_ref.Window = window;
		g.BeginPopupStack.push_back(popup_ref);
		window->PopupId = popup_ref.PopupId;
	}

	if (window_just_appearing_after_hidden_for_resize && !(flags & HanaLovesMeWindowFlags_ChildWindow))
		window->NavLastIds[0] = 0;

	// Process SetNextWindow***() calls
	bool window_pos_set_by_api = false;
	bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
	if (g.NextWindowData.PosCond)
	{
		window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
		if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
		{
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window->SetWindowPosVal = g.NextWindowData.PosVal;
			window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
			window->SetWindowPosAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);
		}
		else
		{
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
		}
	}
	if (g.NextWindowData.SizeCond)
	{
		window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
		window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
	}
	if (g.NextWindowData.ContentSizeCond)
	{
		// Adjust passed "client size" to become a "window size"
		window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
		if (window->SizeContentsExplicit.y != 0.0f)
			window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
	}
	else if (first_begin_of_the_frame)
	{
		window->SizeContentsExplicit = vsize(0.0f, 0.0f);
	}
	if (g.NextWindowData.CollapsedCond)
		SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
	if (g.NextWindowData.FocusCond)
		FocusWindow(window);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, false);

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if (first_begin_of_the_frame)
	{
		// Initialize
		const bool window_is_child_tooltip = (flags & HanaLovesMeWindowFlags_ChildWindow) && (flags & HanaLovesMeWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
		UpdateWindowParentAndRootLinks(window, flags, parent_window);

		window->Active = true;
		window->HasCloseButton = (p_open != NULL);
		window->ClipRect = xuifloatcolor(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
		window->IDStack.resize(1);

		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
		// The title bar always display the 'name' parameter, so we only update the string stohnly if it needs to be visible to the end-user elsewhere.
		bool window_title_visible_elsewhere = false;
		if (g.NavWindowingList != NULL && (window->Flags & HanaLovesMeWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
			window_title_visible_elsewhere = true;
		if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
		{
			size_t buf_len = (size_t)window->NameBufLen;
			window->Name = ImStrdupcpy(window->Name, &buf_len, name);
			window->NameBufLen = (int)buf_len;
		}

		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

		// Update contents size from last frame for auto-fitting (or use explicit size)
		window->SizeContents = CalcSizeContents(window);
		if (window->HiddenFramesCanSkipItems > 0)
			window->HiddenFramesCanSkipItems--;
		if (window->HiddenFramesCannotSkipItems > 0)
			window->HiddenFramesCannotSkipItems--;

		// Hide new windows for one frame until they calculate their size
		if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
			window->HiddenFramesCannotSkipItems = 1;

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		// We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
		if (window_just_activated_by_user && (flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) != 0)
		{
			window->HiddenFramesCannotSkipItems = 1;
			if (flags & HanaLovesMeWindowFlags_AlwaysAutoResize)
			{
				if (!window_size_x_set_by_api)
					window->Size.x = window->SizeFull.x = 0.f;
				if (!window_size_y_set_by_api)
					window->Size.y = window->SizeFull.y = 0.f;
				window->SizeContents = vsize(0.f, 0.f);
			}
		}

		SetCurrentWindow(window);

		// Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
			window->WindowBorderSize = style.ChildBorderSize;
		else
			window->WindowBorderSize = ((flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
		window->WindowPadding = style.WindowPadding;
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & (HanaLovesMeWindowFlags_AlwaysUseWindowPadding | HanaLovesMeWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
			window->WindowPadding = vsize(0.0f, (flags & HanaLovesMeWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
		window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
		window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar) && !(flags & HanaLovesMeWindowFlags_NoCollapse))
		{
			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
			vsrect title_bar_rect = window->TitleBarRect();
			if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
				window->WantCollapseToggle = true;
			if (window->WantCollapseToggle)
			{
				window->Collapsed = !window->Collapsed;
				MarkIniSettingsDirty(window);
				FocusWindow(window);
			}
		}
		else
		{
			window->Collapsed = false;
		}
		window->WantCollapseToggle = false;

		// SIZE

		// Calculate auto-fit size, handle automatic resize
		const vsize size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
		vsize size_full_modified(FLT_MAX, FLT_MAX);
		if ((flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && !window->Collapsed)
		{
			// Using SetNextWindowSize() overrides HanaLovesMeWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if (!window_size_x_set_by_api)
				window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
			if (!window_size_y_set_by_api)
				window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
		}
		else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
		{
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor HanaLovesMeWindowFlags_AlwaysAutoResize when collapsed.
			if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
				window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
			if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
				window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
			if (!window->Collapsed)
				MarkIniSettingsDirty(window);
		}

		// Apply minimum/maximum window size constraints and final size
		window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
		window->Size = window->Collapsed && !(flags & HanaLovesMeWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

		// SCROLLBAR STATUS

		// Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
		if (!window->Collapsed)
		{
			// When reading the current size we need to read it after size constraints have been applied
			float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
			float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
			window->ScrollbarY = (flags & HanaLovesMeWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & HanaLovesMeWindowFlags_NoScrollbar));
			window->ScrollbarX = (flags & HanaLovesMeWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & HanaLovesMeWindowFlags_NoScrollbar) && (flags & HanaLovesMeWindowFlags_HorizontalScrollbar));
			if (window->ScrollbarX && !window->ScrollbarY)
				window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & HanaLovesMeWindowFlags_NoScrollbar);
			window->ScrollbarSizes = vsize(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
		}

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if (window_just_activated_by_user)
		{
			window->AutoPosLastDirection = HanaLovesMeDir_None;
			if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api)
				window->Pos = g.BeginPopupStack.back().OpenPopupPos;
		}

		// Position child window
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
		{
			IM_ASSERT(parent_window && parent_window->Active);
			window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
			parent_window->DC.ChildWindows.push_back(window);
			if (!(flags & HanaLovesMeWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
				window->Pos = parent_window->DC.CursorPos;
		}

		const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
		if (window_pos_with_pivot)
			SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
		else if ((flags & HanaLovesMeWindowFlags_ChildMenu) != 0)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
			window->Pos = FindBestWindowPosForPopup(window);

		// Clamp position so it stays visible
		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
		vsrect viewport_rect(GetViewportRect());
		if (!window_pos_set_by_api && !(flags & HanaLovesMeWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
		{
			if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
			{
				vsize clamp_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
				ClampWindowRect(window, viewport_rect, clamp_padding);
			}
		}
		window->Pos = ImFloor(window->Pos);

		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
		window->WindowRounding = (flags & HanaLovesMeWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & HanaLovesMeWindowFlags_Popup) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

		// Apply scrolling
		window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
		window->ScrollTarget = vsize(FLT_MAX, FLT_MAX);

		// Apply window focus (new and reactivated windows are moved to front)
		bool want_focus = false;
		if (window_just_activated_by_user && !(flags & HanaLovesMeWindowFlags_NoFocusOnAppearing))
		{
			if (flags & HanaLovesMeWindowFlags_Popup)
				want_focus = true;
			else if ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Tooltip)) == 0)
				want_focus = true;
		}

		// Handle manual resize: Resize Grips, Borders, Gamepad
		int border_held = -1;
		ImU32 resize_grip_col[4] = { 0 };
		const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
		const float grip_draw_size = (float)(int)ImMax(9 * 1.0f, window->WindowRounding + 0.0f + g.FontSize * 0.f); // sedmapickamaterina
		if (!window->Collapsed)
			UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);
		window->ResizeBorderHeld = (signed char)border_held;

		// Default item width. Make it proportional to window size if window manually resizes
		if (window->Size.x > 0.0f && !(flags & HanaLovesMeWindowFlags_Tooltip) && !(flags & HanaLovesMeWindowFlags_AlwaysAutoResize))
			window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
		else
			window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

		// DRAWING

		// Setup draw list and outer clipping rectangle
		window->DrawList->Clear();
		window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
		window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & HanaLovesMeWindowFlags_Popup) && !window_is_child_tooltip)
			PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
		else
			PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

		// Draw modal window background (darkens what is behind them, all viewports)
		const bool dim_bg_for_modal = (flags & HanaLovesMeWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
		const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
		if (dim_bg_for_modal || dim_bg_for_window_list)
		{
			const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? HanaLovesMeCol_ModalWindowDimBg : HanaLovesMeCol_NavWindowingDimBg, g.DimBgRatio);
			window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
		}

		// Draw navigation selection/windowing rectangle background
		if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
		{
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
				window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
		}

		// Draw window + handle manual resize
		// As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
		const float window_rounding = window->WindowRounding;
		const float window_border_size = window->WindowBorderSize;
		const HanaLovesMeWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
		const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
		const vsrect title_bar_rect = window->TitleBarRect();
		if (window->Collapsed)
		{
			// Title bar only
			float backup_border_size = style.FrameBorderSize;
			g.Style.FrameBorderSize = window->WindowBorderSize;
			ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBgCollapsed);
			RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
			g.Style.FrameBorderSize = backup_border_size;
		}
		else
		{
			// Window background
			auto topColor = xuicolor(40, 40, 40, 255);
			auto bottomColor = xuicolor(49, 49, 49, 255);
			window->DrawList->AddRectFilledMultiColor(window->Pos + vsize(0, window->TitleBarHeight()), window->Pos + window->Size, topColor, topColor, bottomColor, bottomColor);

			// Title bar
			if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
			{
				ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBg);
				window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
			}

			// Menu bar
			if (flags & HanaLovesMeWindowFlags_MenuBar)
			{
				vsrect menu_bar_rect = window->MenuBarRect();
				menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
				window->DrawList->AddRectFilled(menu_bar_rect.Min + vsize(window_border_size, 0), menu_bar_rect.Max - vsize(window_border_size, 0), GetColorU32(HanaLovesMeCol_MenuBarBg), (flags & HanaLovesMeWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
				if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
					window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(HanaLovesMeCol_Border), style.FrameBorderSize);
			}

			// Scrollbars
			if (window->ScrollbarX)
				Scrollbar(HanaLovesMeAxis_X);
			if (window->ScrollbarY)
				Scrollbar(HanaLovesMeAxis_Y);

			// Render resize grips (after their input handling so we don't have a frame of latency)
			if (!(flags & HanaLovesMeWindowFlags_NoResize))
			{
				for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
				{
					const HanaLovesMeResizeGripDef& grip = resize_grip_def[resize_grip_n];
					const vsize corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(window_border_size, grip_draw_size) : vsize(grip_draw_size, window_border_size)));
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(grip_draw_size, window_border_size) : vsize(window_border_size, grip_draw_size)));
					window->DrawList->PathArcToFast(vsize(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
					window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
				}
			}

			// Borders
			RenderOuterBorders(window);
		}

		// Draw navigation selection/windowing rectangle border
		if (g.NavWindowingTargetAnim == window)
		{
			float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
			{
				bb.Expand(-g.FontSize - 1.0f);
				rounding = window->WindowRounding;
			}
			window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
		}

		// Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
		window->SizeFullAtLastBegin = window->SizeFull;

		// Update various regions. Variables they depends on are set above in this function.
		// FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
		window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
		window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
		window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
		window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
		window->DC.GroupOffset.x = 0.0f;
		window->DC.ColumnsOffset.x = 0.0f;
		window->DC.CursorStartPos = window->Pos + vsize(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
		window->DC.CursorPos = window->DC.CursorStartPos;
		window->DC.CursorPosPrevLine = window->DC.CursorPos;
		window->DC.CursorMaxPos = window->DC.CursorStartPos;
		window->DC.CurrentLineSize = window->DC.PrevLineSize = vsize(0.0f, 0.0f);
		window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
		window->DC.NavHideHighlightOneFrame = false;
		window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
		window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
		window->DC.NavLayerActiveMaskNext = 0x00;
		window->DC.MenuBarAppending = false;
		window->DC.ChildWindows.resize(0);
		window->DC.LayoutType = HanaLovesMeLayoutType_Vertical;
		window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : HanaLovesMeLayoutType_Vertical;
		window->DC.FocusCounterAll = window->DC.FocusCounterTab = -1;
		window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : HanaLovesMeItemFlags_Default_;
		window->DC.ItemWidth = window->ItemWidthDefault;
		window->DC.TextWrapPos = -1.0f; // disabled
		window->DC.ItemFlagsStack.resize(0);
		window->DC.ItemWidthStack.resize(0);
		window->DC.TextWrapPosStack.resize(0);
		window->DC.CurrentColumns = NULL;
		window->DC.TreeDepth = 0;
		window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
		window->DC.StateStohnly = &window->StateStohnly;
		window->DC.GroupStack.resize(0);
		window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
		{
			window->DC.ItemFlags = parent_window->DC.ItemFlags;
			window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
		}

		if (window->AutoFitFramesX > 0)
			window->AutoFitFramesX--;
		if (window->AutoFitFramesY > 0)
			window->AutoFitFramesY--;

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		if (want_focus)
		{
			FocusWindow(window);
			NavInitWindow(window, false);
		}

		// Title bar
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
		{
			// Close & collapse button are on layer 1 (same as menus) and don't default focus
			const HanaLovesMeItemFlags item_flags_backup = window->DC.ItemFlags;
			window->DC.ItemFlags |= HanaLovesMeItemFlags_NoNavDefaultFocus;
			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Menu;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Menu);

			// Collapse button
			if (!(flags & HanaLovesMeWindowFlags_NoCollapse))
				if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
					window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

			// Close button
			if (p_open != NULL)
			{
				const float rad = g.FontSize * 0.5f;
				if (CloseButton(window->GetID("#CLOSE"), vsize(window->Pos.x + window->Size.x - style.FramePadding.x - rad, window->Pos.y + style.FramePadding.y + rad), rad + 1))
					* p_open = false;
			}

			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Main;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Main);
			window->DC.ItemFlags = item_flags_backup;

			// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
			// FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
			const char* UNSAVED_DOCUMENT_MARKER = "*";
			float marker_size_x = (flags & HanaLovesMeWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
			vsize text_size = CalcTextSize(name, NULL, true) + vsize(marker_size_x, 0.0f);
			vsrect text_r = title_bar_rect;
			float pad_left = (flags & HanaLovesMeWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			float pad_right = (p_open == NULL) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			if (style.WindowTitleAlign.x > 0.0f)
				pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
			text_r.Min.x += pad_left;
			text_r.Max.x -= pad_right;
			vsrect clip_rect = text_r;
			clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
			RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
			if (flags & HanaLovesMeWindowFlags_UnsavedDocument)
			{
				vsize marker_pos = vsize(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + vsize(2 - marker_size_x, 0.0f);
				vsize off = vsize(0.0f, (float)(int)(-g.FontSize * 0.25f));
				RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, vsize(0, style.WindowTitleAlign.y), &clip_rect);
			}
		}

		// Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
		window->OuterRectClipped = window->Rect();
		window->OuterRectClipped.ClipWith(window->ClipRect);

		// Pressing CTRL+C while holding on a window copy its content to the clipboard
		// This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
		// Maybe we can support CTRL+C on every element?
		/*
		if (g.ActiveId == move_id)
			if (g.IO.KeyCtrl && IsKeyPressedMap(HanaLovesMeKey_C))
				LogToClipboard();
		*/

		// Inner rectangle
		// We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
		window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
		window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & HanaLovesMeWindowFlags_MenuBar) || !(flags & HanaLovesMeWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
		window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
		window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
		//window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

		// Inner clipping rectangle
		// Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
		window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

		// We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
		// This is useful to allow creating context menus on title bar only, etc.
		window->DC.LastItemId = window->MoveId;
		window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? HanaLovesMeItemStatusFlags_HoveredRect : 0;
		window->DC.LastItemRect = title_bar_rect;
#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
		if (!(window->Flags & HanaLovesMeWindowFlags_NoTitleBar))
			HanaLovesMe_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);
#endif
	}
	else
	{
		// Append
		SetCurrentWindow(window);
	}

	PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	if (first_begin_of_the_frame)
		window->WriteAccessed = false;

	window->BeginCount++;
	g.NextWindowData.Clear();

	if (flags & HanaLovesMeWindowFlags_ChildWindow)
	{
		// Child window can be out of sight and have "negative" clip windows.
		// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
		IM_ASSERT((flags & HanaLovesMeWindowFlags_NoTitleBar) != 0);
		if (!(flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
			if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
				window->HiddenFramesCanSkipItems = 1;

		// Completely hide along with parent or if parent is collapsed
		if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
			window->HiddenFramesCanSkipItems = 1;
	}

	// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
	if (style.Alpha <= 0.0f)
		window->HiddenFramesCanSkipItems = 1;

	// Update the Hidden flag
	window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);

	// Update the SkipItems flag, used to early out of all items functions (no layout required)
	bool skip_items = false;
	if (window->Collapsed || !window->Active || window->Hidden)
		if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
			skip_items = true;
	window->SkipItems = skip_items;

	return !skip_items;
}

bool HanaLovesMe::BeginGroupBoxMain(const char* name, bool* p_open, HanaLovesMeWindowFlags flags)
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	const HanaLovesMeStyle& style = g.Style;
	IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
	IM_ASSERT(g.FrameScopeActive);                  // Forgot to call HanaLovesMe::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called HanaLovesMe::Render() or HanaLovesMe::EndFrame() and haven't called HanaLovesMe::NewFrame() again yet

	// Find or create
	HanaLovesMeWindow * window = FindWindowByName(name);
	const bool window_just_created = (window == NULL);
	if (window_just_created)
	{
		vsize size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : vsize(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
		window = CreateNewWindow(name, size_on_first_use, flags);
	}

	// Automatically disable manual moving/resizing when NoInputs is set
	if ((flags & HanaLovesMeWindowFlags_NoInputs) == HanaLovesMeWindowFlags_NoInputs)
		flags |= HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoResize;

	if (flags & HanaLovesMeWindowFlags_NavFlattened)
		IM_ASSERT(flags & HanaLovesMeWindowFlags_ChildWindow);

	const int current_frame = g.FrameCount;
	const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

	// Update the Appearing flag
	bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window);
	}
	window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, true);

	// Update Flags, LastFrameActive, BeginOrderXXX fields
	if (first_begin_of_the_frame)
	{
		window->Flags = (HanaLovesMeWindowFlags)flags;
		window->LastFrameActive = current_frame;
		window->BeginOrderWithinParent = 0;
		window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
	}
	else
	{
		flags = window->Flags;
	}

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	HanaLovesMeWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
	HanaLovesMeWindow* parent_window = first_begin_of_the_frame ? ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
	IM_ASSERT(parent_window != NULL || !(flags & HanaLovesMeWindowFlags_ChildWindow));

	// Add to stack
	// We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
	g.CurrentWindowStack.push_back(window);
	g.CurrentWindow = NULL;
	CheckStacksSize(window, true);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		popup_ref.Window = window;
		g.BeginPopupStack.push_back(popup_ref);
		window->PopupId = popup_ref.PopupId;
	}

	if (window_just_appearing_after_hidden_for_resize && !(flags & HanaLovesMeWindowFlags_ChildWindow))
		window->NavLastIds[0] = 0;

	// Process SetNextWindow***() calls
	bool window_pos_set_by_api = false;
	bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
	if (g.NextWindowData.PosCond)
	{
		window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
		if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
		{
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window->SetWindowPosVal = g.NextWindowData.PosVal;
			window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
			window->SetWindowPosAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);
		}
		else
		{
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
		}
	}
	if (g.NextWindowData.SizeCond)
	{
		window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
		window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
	}
	if (g.NextWindowData.ContentSizeCond)
	{
		// Adjust passed "client size" to become a "window size"
		window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
		if (window->SizeContentsExplicit.y != 0.0f)
			window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
	}
	else if (first_begin_of_the_frame)
	{
		window->SizeContentsExplicit = vsize(0.0f, 0.0f);
	}
	if (g.NextWindowData.CollapsedCond)
		SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
	if (g.NextWindowData.FocusCond)
		FocusWindow(window);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, false);

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if (first_begin_of_the_frame)
	{
		// Initialize
		const bool window_is_child_tooltip = (flags & HanaLovesMeWindowFlags_ChildWindow) && (flags & HanaLovesMeWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
		UpdateWindowParentAndRootLinks(window, flags, parent_window);

		window->Active = true;
		window->HasCloseButton = (p_open != NULL);
		window->ClipRect = xuifloatcolor(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
		window->IDStack.resize(1);

		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
		// The title bar always display the 'name' parameter, so we only update the string stohnly if it needs to be visible to the end-user elsewhere.
		bool window_title_visible_elsewhere = false;
		if (g.NavWindowingList != NULL && (window->Flags & HanaLovesMeWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
			window_title_visible_elsewhere = true;
		if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
		{
			size_t buf_len = (size_t)window->NameBufLen;
			window->Name = ImStrdupcpy(window->Name, &buf_len, name);
			window->NameBufLen = (int)buf_len;
		}

		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

		// Update contents size from last frame for auto-fitting (or use explicit size)
		window->SizeContents = CalcSizeContents(window);
		if (window->HiddenFramesCanSkipItems > 0)
			window->HiddenFramesCanSkipItems--;
		if (window->HiddenFramesCannotSkipItems > 0)
			window->HiddenFramesCannotSkipItems--;

		// Hide new windows for one frame until they calculate their size
		if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
			window->HiddenFramesCannotSkipItems = 1;

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		// We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
		if (window_just_activated_by_user && (flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) != 0)
		{
			window->HiddenFramesCannotSkipItems = 1;
			if (flags & HanaLovesMeWindowFlags_AlwaysAutoResize)
			{
				if (!window_size_x_set_by_api)
					window->Size.x = window->SizeFull.x = 0.f;
				if (!window_size_y_set_by_api)
					window->Size.y = window->SizeFull.y = 0.f;
				window->SizeContents = vsize(0.f, 0.f);
			}
		}

		SetCurrentWindow(window);

		// Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
			window->WindowBorderSize = style.ChildBorderSize;
		else
			window->WindowBorderSize = ((flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
		window->WindowPadding = style.WindowPadding;
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & (HanaLovesMeWindowFlags_AlwaysUseWindowPadding | HanaLovesMeWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
			window->WindowPadding = vsize(0.0f, (flags & HanaLovesMeWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
		window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
		window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar) && !(flags & HanaLovesMeWindowFlags_NoCollapse))
		{
			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
			vsrect title_bar_rect = window->TitleBarRect();
			if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
				window->WantCollapseToggle = true;
			if (window->WantCollapseToggle)
			{
				window->Collapsed = !window->Collapsed;
				MarkIniSettingsDirty(window);
				FocusWindow(window);
			}
		}
		else
		{
			window->Collapsed = false;
		}
		window->WantCollapseToggle = false;

		// SIZE

		// Calculate auto-fit size, handle automatic resize
		const vsize size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
		vsize size_full_modified(FLT_MAX, FLT_MAX);
		if ((flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && !window->Collapsed)
		{
			// Using SetNextWindowSize() overrides HanaLovesMeWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if (!window_size_x_set_by_api)
				window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
			if (!window_size_y_set_by_api)
				window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
		}
		else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
		{
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor HanaLovesMeWindowFlags_AlwaysAutoResize when collapsed.
			if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
				window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
			if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
				window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
			if (!window->Collapsed)
				MarkIniSettingsDirty(window);
		}

		// Apply minimum/maximum window size constraints and final size
		window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
		window->Size = window->Collapsed && !(flags & HanaLovesMeWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

		// SCROLLBAR STATUS

		// Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
		if (!window->Collapsed)
		{
			// When reading the current size we need to read it after size constraints have been applied
			float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
			float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
			window->ScrollbarY = (flags & HanaLovesMeWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & HanaLovesMeWindowFlags_NoScrollbar));
			window->ScrollbarX = (flags & HanaLovesMeWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & HanaLovesMeWindowFlags_NoScrollbar) && (flags & HanaLovesMeWindowFlags_HorizontalScrollbar));
			if (window->ScrollbarX && !window->ScrollbarY)
				window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & HanaLovesMeWindowFlags_NoScrollbar);
			window->ScrollbarSizes = vsize(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
		}

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if (window_just_activated_by_user)
		{
			window->AutoPosLastDirection = HanaLovesMeDir_None;
			if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api)
				window->Pos = g.BeginPopupStack.back().OpenPopupPos;
		}

		// Position child window
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
		{
			IM_ASSERT(parent_window && parent_window->Active);
			window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
			parent_window->DC.ChildWindows.push_back(window);
			if (!(flags & HanaLovesMeWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
				window->Pos = parent_window->DC.CursorPos;
		}

		const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
		if (window_pos_with_pivot)
			SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
		else if ((flags & HanaLovesMeWindowFlags_ChildMenu) != 0)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
			window->Pos = FindBestWindowPosForPopup(window);

		// Clamp position so it stays visible
		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
		vsrect viewport_rect(GetViewportRect());
		if (!window_pos_set_by_api && !(flags & HanaLovesMeWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
		{
			if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
			{
				vsize clamp_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
				ClampWindowRect(window, viewport_rect, clamp_padding);
			}
		}
		window->Pos = ImFloor(window->Pos);

		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
		window->WindowRounding = (flags & HanaLovesMeWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & HanaLovesMeWindowFlags_Popup) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

		// Apply scrolling
		window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
		window->ScrollTarget = vsize(FLT_MAX, FLT_MAX);

		// Apply window focus (new and reactivated windows are moved to front)
		bool want_focus = false;
		if (window_just_activated_by_user && !(flags & HanaLovesMeWindowFlags_NoFocusOnAppearing))
		{
			if (flags & HanaLovesMeWindowFlags_Popup)
				want_focus = true;
			else if ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Tooltip)) == 0)
				want_focus = true;
		}

		// Handle manual resize: Resize Grips, Borders, Gamepad
		int border_held = -1;
		ImU32 resize_grip_col[4] = { 0 };
		const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
		const float grip_draw_size = (float)(int)ImMax(9 * 1.0f, window->WindowRounding + 0.0f + g.FontSize * 0.f); // sedmapickamaterina
		if (!window->Collapsed)
			UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);
		window->ResizeBorderHeld = (signed char)border_held;

		// Default item width. Make it proportional to window size if window manually resizes
		if (window->Size.x > 0.0f && !(flags & HanaLovesMeWindowFlags_Tooltip) && !(flags & HanaLovesMeWindowFlags_AlwaysAutoResize))
			window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
		else
			window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

		// DRAWING

		// Setup draw list and outer clipping rectangle
		window->DrawList->Clear();
		window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
		window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & HanaLovesMeWindowFlags_Popup) && !window_is_child_tooltip)
			PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
		else
			PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

		// Draw modal window background (darkens what is behind them, all viewports)
		const bool dim_bg_for_modal = (flags & HanaLovesMeWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
		const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
		if (dim_bg_for_modal || dim_bg_for_window_list)
		{
			const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? HanaLovesMeCol_ModalWindowDimBg : HanaLovesMeCol_NavWindowingDimBg, g.DimBgRatio);
			window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
		}

		// Draw navigation selection/windowing rectangle background
		if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
		{
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
				window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
		}

		// Draw window + handle manual resize
		// As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
		const float window_rounding = window->WindowRounding;
		const float window_border_size = window->WindowBorderSize;
		const HanaLovesMeWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
		const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
		const vsrect title_bar_rect = window->TitleBarRect();
		if (window->Collapsed)
		{
			// Title bar only
			float backup_border_size = style.FrameBorderSize;
			g.Style.FrameBorderSize = window->WindowBorderSize;
			ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBgCollapsed);
			RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
			g.Style.FrameBorderSize = backup_border_size;
		}
		else
		{
			auto backgroundColor = xuicolor(23, 23, 23);
			auto innerBorderColor = xuicolor(48, 48, 48);
			auto outerBorderColor = xuicolor(10, 10, 10);

			window->DrawList->AddRectFilledMultiColor(window->Pos + vsize(0, window->TitleBarHeight()), window->Pos + window->Size, backgroundColor, backgroundColor, backgroundColor, backgroundColor);
			window->DrawList->AddRect(window->Pos + vsize(1, window->TitleBarHeight() + 1), window->Pos + window->Size - vsize(1, 1), innerBorderColor, 0, false, 0.4);
			window->DrawList->AddRect(window->Pos + vsize(0, window->TitleBarHeight()), window->Pos + window->Size, outerBorderColor, 0, false, 0.4);

			// Title bar
			if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
			{
				ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBg);
				window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
			}

			// Menu bar
			if (flags & HanaLovesMeWindowFlags_MenuBar)
			{
				vsrect menu_bar_rect = window->MenuBarRect();
				menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
				window->DrawList->AddRectFilled(menu_bar_rect.Min + vsize(window_border_size, 0), menu_bar_rect.Max - vsize(window_border_size, 0), GetColorU32(HanaLovesMeCol_MenuBarBg), (flags & HanaLovesMeWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
				if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
					window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(HanaLovesMeCol_Border), style.FrameBorderSize);
			}

			// Scrollbars
			if (window->ScrollbarX)
				Scrollbar(HanaLovesMeAxis_X);
			if (window->ScrollbarY)
				Scrollbar(HanaLovesMeAxis_Y);

			// Render resize grips (after their input handling so we don't have a frame of latency)
			if (!(flags & HanaLovesMeWindowFlags_NoResize))
			{
				for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
				{
					const HanaLovesMeResizeGripDef& grip = resize_grip_def[resize_grip_n];
					const vsize corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n) ? vsize(window_border_size, grip_draw_size) : vsize(grip_draw_size, window_border_size)));
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n) ? vsize(grip_draw_size, window_border_size) : vsize(window_border_size, grip_draw_size)));
					window->DrawList->PathArcTo(vsize(corner.x -1 , corner.y -1), 0, 1, 1); // * (window_rounding + window_border_size)
					window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
				}
			}

			// Borders
			RenderOuterBorders(window);
		}

		// Draw navigation selection/windowing rectangle border
		if (g.NavWindowingTargetAnim == window)
		{
			float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
			{
				bb.Expand(-g.FontSize - 1.0f);
				rounding = window->WindowRounding;
			}
			window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
		}

		// Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
		window->SizeFullAtLastBegin = window->SizeFull;

		// Update various regions. Variables they depends on are set above in this function.
		// FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
		window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
		window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
		window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
		window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
		window->DC.GroupOffset.x = 0.0f;
		window->DC.ColumnsOffset.x = 0.0f;
		window->DC.CursorStartPos = window->Pos + vsize(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
		window->DC.CursorPos = window->DC.CursorStartPos;
		window->DC.CursorPosPrevLine = window->DC.CursorPos;
		window->DC.CursorMaxPos = window->DC.CursorStartPos;
		window->DC.CurrentLineSize = window->DC.PrevLineSize = vsize(0.0f, 0.0f);
		window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
		window->DC.NavHideHighlightOneFrame = false;
		window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
		window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
		window->DC.NavLayerActiveMaskNext = 0x00;
		window->DC.MenuBarAppending = false;
		window->DC.ChildWindows.resize(0);
		window->DC.LayoutType = HanaLovesMeLayoutType_Vertical;
		window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : HanaLovesMeLayoutType_Vertical;
		window->DC.FocusCounterAll = window->DC.FocusCounterTab = -1;
		window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : HanaLovesMeItemFlags_Default_;
		window->DC.ItemWidth = window->ItemWidthDefault;
		window->DC.TextWrapPos = -1.0f; // disabled
		window->DC.ItemFlagsStack.resize(0);
		window->DC.ItemWidthStack.resize(0);
		window->DC.TextWrapPosStack.resize(0);
		window->DC.CurrentColumns = NULL;
		window->DC.TreeDepth = 0;
		window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
		window->DC.StateStohnly = &window->StateStohnly;
		window->DC.GroupStack.resize(0);
		window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
		{
			window->DC.ItemFlags = parent_window->DC.ItemFlags;
			window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
		}

		if (window->AutoFitFramesX > 0)
			window->AutoFitFramesX--;
		if (window->AutoFitFramesY > 0)
			window->AutoFitFramesY--;

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		if (want_focus)
		{
			FocusWindow(window);
			NavInitWindow(window, false);
		}

		// Title bar
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
		{
			// Close & collapse button are on layer 1 (same as menus) and don't default focus
			const HanaLovesMeItemFlags item_flags_backup = window->DC.ItemFlags;
			window->DC.ItemFlags |= HanaLovesMeItemFlags_NoNavDefaultFocus;
			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Menu;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Menu);

			// Collapse button
			if (!(flags & HanaLovesMeWindowFlags_NoCollapse))
				if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
					window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

			// Close button
			if (p_open != NULL)
			{
				const float rad = g.FontSize * 0.5f;
				if (CloseButton(window->GetID("#CLOSE"), vsize(window->Pos.x + window->Size.x - style.FramePadding.x - rad, window->Pos.y + style.FramePadding.y + rad), rad + 1))
					* p_open = false;
			}

			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Main;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Main);
			window->DC.ItemFlags = item_flags_backup;

			// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
			// FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
			const char* UNSAVED_DOCUMENT_MARKER = "*";
			float marker_size_x = (flags & HanaLovesMeWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
			vsize text_size = CalcTextSize(name, NULL, true) + vsize(marker_size_x, 0.0f);
			vsrect text_r = title_bar_rect;
			float pad_left = (flags & HanaLovesMeWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			float pad_right = (p_open == NULL) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			if (style.WindowTitleAlign.x > 0.0f)
				pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
			text_r.Min.x += pad_left;
			text_r.Max.x -= pad_right;
			vsrect clip_rect = text_r;
			clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
			RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
			if (flags & HanaLovesMeWindowFlags_UnsavedDocument)
			{
				vsize marker_pos = vsize(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + vsize(2 - marker_size_x, 0.0f);
				vsize off = vsize(0.0f, (float)(int)(-g.FontSize * 0.25f));
				RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, vsize(0, style.WindowTitleAlign.y), &clip_rect);
			}
		}

		// Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
		window->OuterRectClipped = window->Rect();
		window->OuterRectClipped.ClipWith(window->ClipRect);

		// Pressing CTRL+C while holding on a window copy its content to the clipboard
		// This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
		// Maybe we can support CTRL+C on every element?
		/*
		if (g.ActiveId == move_id)
			if (g.IO.KeyCtrl && IsKeyPressedMap(HanaLovesMeKey_C))
				LogToClipboard();
		*/

		// Inner rectangle
		// We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
		window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
		window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & HanaLovesMeWindowFlags_MenuBar) || !(flags & HanaLovesMeWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
		window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
		window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
		//window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

		// Inner clipping rectangle
		// Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
		window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

		// We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
		// This is useful to allow creating context menus on title bar only, etc.
		window->DC.LastItemId = window->MoveId;
		window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? HanaLovesMeItemStatusFlags_HoveredRect : 0;
		window->DC.LastItemRect = title_bar_rect;
#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
		if (!(window->Flags & HanaLovesMeWindowFlags_NoTitleBar))
			HanaLovesMe_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);
#endif
	}
	else
	{
		// Append
		SetCurrentWindow(window);
	}

	PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	if (first_begin_of_the_frame)
		window->WriteAccessed = false;

	window->BeginCount++;
	g.NextWindowData.Clear();

	if (flags & HanaLovesMeWindowFlags_ChildWindow)
	{
		// Child window can be out of sight and have "negative" clip windows.
		// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
		IM_ASSERT((flags & HanaLovesMeWindowFlags_NoTitleBar) != 0);
		if (!(flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
			if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
				window->HiddenFramesCanSkipItems = 1;

		// Completely hide along with parent or if parent is collapsed
		if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
			window->HiddenFramesCanSkipItems = 1;
	}

	// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
	if (style.Alpha <= 0.0f)
		window->HiddenFramesCanSkipItems = 1;

	// Update the Hidden flag
	window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);

	// Update the SkipItems flag, used to early out of all items functions (no layout required)
	bool skip_items = false;
	if (window->Collapsed || !window->Active || window->Hidden)
		if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
			skip_items = true;
	window->SkipItems = skip_items;

	return !skip_items;
}

bool HanaLovesMe::BeginGroupBoxScrollMain(const char* name, const char* groupboxName, bool* p_open, HanaLovesMeWindowFlags flags)
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	const HanaLovesMeStyle& style = g.Style;
	IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
	IM_ASSERT(g.FrameScopeActive);                  // Forgot to call HanaLovesMe::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called HanaLovesMe::Render() or HanaLovesMe::EndFrame() and haven't called HanaLovesMe::NewFrame() again yet

	// Find or create
	HanaLovesMeWindow * window = FindWindowByName(name);
	const bool window_just_created = (window == NULL);
	if (window_just_created)
	{
		vsize size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : vsize(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
		window = CreateNewWindow(name, size_on_first_use, flags);
	}

	// Automatically disable manual moving/resizing when NoInputs is set
	if ((flags & HanaLovesMeWindowFlags_NoInputs) == HanaLovesMeWindowFlags_NoInputs)
		flags |= HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoResize;

	if (flags & HanaLovesMeWindowFlags_NavFlattened)
		IM_ASSERT(flags & HanaLovesMeWindowFlags_ChildWindow);

	const int current_frame = g.FrameCount;
	const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

	// Update the Appearing flag
	bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window);
	}
	window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, true);

	// Update Flags, LastFrameActive, BeginOrderXXX fields
	if (first_begin_of_the_frame)
	{
		window->Flags = (HanaLovesMeWindowFlags)flags;
		window->LastFrameActive = current_frame;
		window->BeginOrderWithinParent = 0;
		window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
	}
	else
	{
		flags = window->Flags;
	}

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	HanaLovesMeWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
	HanaLovesMeWindow* parent_window = first_begin_of_the_frame ? ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
	IM_ASSERT(parent_window != NULL || !(flags & HanaLovesMeWindowFlags_ChildWindow));

	// Add to stack
	// We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
	g.CurrentWindowStack.push_back(window);
	g.CurrentWindow = NULL;
	CheckStacksSize(window, true);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		popup_ref.Window = window;
		g.BeginPopupStack.push_back(popup_ref);
		window->PopupId = popup_ref.PopupId;
	}

	if (window_just_appearing_after_hidden_for_resize && !(flags & HanaLovesMeWindowFlags_ChildWindow))
		window->NavLastIds[0] = 0;

	// Process SetNextWindow***() calls
	bool window_pos_set_by_api = false;
	bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
	if (g.NextWindowData.PosCond)
	{
		window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
		if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
		{
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window->SetWindowPosVal = g.NextWindowData.PosVal;
			window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
			window->SetWindowPosAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);
		}
		else
		{
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
		}
	}
	if (g.NextWindowData.SizeCond)
	{
		window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
		window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
	}
	if (g.NextWindowData.ContentSizeCond)
	{
		// Adjust passed "client size" to become a "window size"
		window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
		if (window->SizeContentsExplicit.y != 0.0f)
			window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
	}
	else if (first_begin_of_the_frame)
	{
		window->SizeContentsExplicit = vsize(0.0f, 0.0f);
	}
	if (g.NextWindowData.CollapsedCond)
		SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
	if (g.NextWindowData.FocusCond)
		FocusWindow(window);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, false);

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if (first_begin_of_the_frame)
	{
		// Initialize
		const bool window_is_child_tooltip = (flags & HanaLovesMeWindowFlags_ChildWindow) && (flags & HanaLovesMeWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
		UpdateWindowParentAndRootLinks(window, flags, parent_window);

		window->Active = true;
		window->HasCloseButton = (p_open != NULL);
		window->ClipRect = xuifloatcolor(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
		window->IDStack.resize(1);

		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
		// The title bar always display the 'name' parameter, so we only update the string stohnly if it needs to be visible to the end-user elsewhere.
		bool window_title_visible_elsewhere = false;
		if (g.NavWindowingList != NULL && (window->Flags & HanaLovesMeWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
			window_title_visible_elsewhere = true;
		if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
		{
			size_t buf_len = (size_t)window->NameBufLen;
			window->Name = ImStrdupcpy(window->Name, &buf_len, name);
			window->NameBufLen = (int)buf_len;
		}

		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

		// Update contents size from last frame for auto-fitting (or use explicit size)
		window->SizeContents = CalcSizeContents(window);
		if (window->HiddenFramesCanSkipItems > 0)
			window->HiddenFramesCanSkipItems--;
		if (window->HiddenFramesCannotSkipItems > 0)
			window->HiddenFramesCannotSkipItems--;

		// Hide new windows for one frame until they calculate their size
		if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
			window->HiddenFramesCannotSkipItems = 1;

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		// We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
		if (window_just_activated_by_user && (flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) != 0)
		{
			window->HiddenFramesCannotSkipItems = 1;
			if (flags & HanaLovesMeWindowFlags_AlwaysAutoResize)
			{
				if (!window_size_x_set_by_api)
					window->Size.x = window->SizeFull.x = 0.f;
				if (!window_size_y_set_by_api)
					window->Size.y = window->SizeFull.y = 0.f;
				window->SizeContents = vsize(0.f, 0.f);
			}
		}

		SetCurrentWindow(window);

		// Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
			window->WindowBorderSize = style.ChildBorderSize;
		else
			window->WindowBorderSize = ((flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
		window->WindowPadding = style.WindowPadding;
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & (HanaLovesMeWindowFlags_AlwaysUseWindowPadding | HanaLovesMeWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
			window->WindowPadding = vsize(0.0f, (flags & HanaLovesMeWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
		window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
		window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar) && !(flags & HanaLovesMeWindowFlags_NoCollapse))
		{
			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
			vsrect title_bar_rect = window->TitleBarRect();
			if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
				window->WantCollapseToggle = true;
			if (window->WantCollapseToggle)
			{
				window->Collapsed = !window->Collapsed;
				MarkIniSettingsDirty(window);
				FocusWindow(window);
			}
		}
		else
		{
			window->Collapsed = false;
		}
		window->WantCollapseToggle = false;

		// SIZE

		// Calculate auto-fit size, handle automatic resize
		const vsize size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
		vsize size_full_modified(FLT_MAX, FLT_MAX);
		if ((flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && !window->Collapsed)
		{
			// Using SetNextWindowSize() overrides HanaLovesMeWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if (!window_size_x_set_by_api)
				window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
			if (!window_size_y_set_by_api)
				window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
		}
		else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
		{
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor HanaLovesMeWindowFlags_AlwaysAutoResize when collapsed.
			if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
				window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
			if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
				window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
			if (!window->Collapsed)
				MarkIniSettingsDirty(window);
		}

		// Apply minimum/maximum window size constraints and final size
		window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
		window->Size = window->Collapsed && !(flags & HanaLovesMeWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

		// SCROLLBAR STATUS

		// Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
		if (!window->Collapsed)
		{
			// When reading the current size we need to read it after size constraints have been applied
			float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
			float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
			window->ScrollbarY = (flags & HanaLovesMeWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & HanaLovesMeWindowFlags_NoScrollbar));
			window->ScrollbarX = (flags & HanaLovesMeWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & HanaLovesMeWindowFlags_NoScrollbar) && (flags & HanaLovesMeWindowFlags_HorizontalScrollbar));
			if (window->ScrollbarX && !window->ScrollbarY)
				window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & HanaLovesMeWindowFlags_NoScrollbar);
			window->ScrollbarSizes = vsize(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
		}

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if (window_just_activated_by_user)
		{
			window->AutoPosLastDirection = HanaLovesMeDir_None;
			if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api)
				window->Pos = g.BeginPopupStack.back().OpenPopupPos;
		}

		// Position child window
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
		{
			IM_ASSERT(parent_window && parent_window->Active);
			window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
			parent_window->DC.ChildWindows.push_back(window);
			if (!(flags & HanaLovesMeWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
				window->Pos = parent_window->DC.CursorPos;
		}

		const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
		if (window_pos_with_pivot)
			SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
		else if ((flags & HanaLovesMeWindowFlags_ChildMenu) != 0)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
			window->Pos = FindBestWindowPosForPopup(window);

		// Clamp position so it stays visible
		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
		vsrect viewport_rect(GetViewportRect());
		if (!window_pos_set_by_api && !(flags & HanaLovesMeWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
		{
			if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
			{
				vsize clamp_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
				ClampWindowRect(window, viewport_rect, clamp_padding);
			}
		}
		window->Pos = ImFloor(window->Pos);

		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
		window->WindowRounding = (flags & HanaLovesMeWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & HanaLovesMeWindowFlags_Popup) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

		// Apply scrolling
		window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
		window->ScrollTarget = vsize(FLT_MAX, FLT_MAX);

		// Apply window focus (new and reactivated windows are moved to front)
		bool want_focus = false;
		if (window_just_activated_by_user && !(flags & HanaLovesMeWindowFlags_NoFocusOnAppearing))
		{
			if (flags & HanaLovesMeWindowFlags_Popup)
				want_focus = true;
			else if ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Tooltip)) == 0)
				want_focus = true;
		}

		// Handle manual resize: Resize Grips, Borders, Gamepad
		int border_held = -1;
		ImU32 resize_grip_col[4] = { 0 };
		const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
		const float grip_draw_size = (float)(int)ImMax(9 * 1.0f, window->WindowRounding + 0.0f + g.FontSize * 0.f); // sedmapickamaterina
		if (!window->Collapsed)
			UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);
		window->ResizeBorderHeld = (signed char)border_held;

		// Default item width. Make it proportional to window size if window manually resizes
		if (window->Size.x > 0.0f && !(flags & HanaLovesMeWindowFlags_Tooltip) && !(flags & HanaLovesMeWindowFlags_AlwaysAutoResize))
			window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
		else
			window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

		// DRAWING

		// Setup draw list and outer clipping rectangle
		window->DrawList->Clear();
		window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
		window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & HanaLovesMeWindowFlags_Popup) && !window_is_child_tooltip)
			PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
		else
			PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

		// Draw modal window background (darkens what is behind them, all viewports)
		const bool dim_bg_for_modal = (flags & HanaLovesMeWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
		const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
		if (dim_bg_for_modal || dim_bg_for_window_list)
		{
			const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? HanaLovesMeCol_ModalWindowDimBg : HanaLovesMeCol_NavWindowingDimBg, g.DimBgRatio);
			window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
		}

		// Draw navigation selection/windowing rectangle background
		if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
		{
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
				window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
		}

		// Draw window + handle manual resize
		// As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
		const float window_rounding = window->WindowRounding;
		const float window_border_size = window->WindowBorderSize;
		const HanaLovesMeWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
		const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
		const vsrect title_bar_rect = window->TitleBarRect();
		if (window->Collapsed)
		{
			// Title bar only
			float backup_border_size = style.FrameBorderSize;
			g.Style.FrameBorderSize = window->WindowBorderSize;
			ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBgCollapsed);
			RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
			g.Style.FrameBorderSize = backup_border_size;
		}
		else
		{
			auto backgroundColor = xuicolor(23, 23, 23);
			auto backgroundColor2 = xuicolor(23, 23, 230);
			auto innerBorderColor = xuicolor(48, 48, 48);
			auto outerBorderColor = xuicolor(10, 10, 10);

			//window->DrawList->AddRectFilledMultiColor(window->Pos + vsize(0, window->TitleBarHeight()), window->Pos + window->Size, backgroundColor, backgroundColor, backgroundColor, backgroundColor);
			//window->DrawList->AddRect(window->Pos + vsize(1, window->TitleBarHeight() + 1), window->Pos + window->Size - vsize(1, 1), innerBorderColor, 0, false, 0.4);
			//window->DrawList->AddRect(window->Pos + vsize(0, window->TitleBarHeight()), window->Pos + window->Size, outerBorderColor, 0, false, 0.4);

			const HanaLovesMeID id = window->GetID(groupboxName);
			const vsize labelSize = CalcTextSize(groupboxName, NULL, true);
			vsize pos = window->DC.CursorPos;
			vsize size = CalcItemSize(vsize(window->Size.x, window->Size.y), labelSize.x + style.FramePadding.x * 2.0f, labelSize.y + style.FramePadding.y * 2.0f);
			const vsrect bb(pos + vsize(5, 0), pos + vsize(labelSize.x + 14, 0));
			ItemSize(bb, style.FramePadding.y);

			window->DrawList->AddRectFilledMultiColor(bb.Min - vsize(0, 6), bb.Max + vsize(-2, -2), backgroundColor, backgroundColor, backgroundColor, backgroundColor);

			PushColor(HanaLovesMeCol_Text, HanaLovesMeCol_TextShadow, xuifloatcolor(0.0f, 0.0f, 0.0f, 0.0f));
			RenderTextClipped(window->Pos + vsize(15, window->TitleBarHeight() - 5), window->Pos + window->Size - vsize(8, 5), groupboxName, NULL, NULL, vsize(0, 0));
			PopStyleColor();

			PushColor(HanaLovesMeCol_Text, HanaLovesMeCol_Text, xuifloatcolor(0.0f, 0.0f, 0.0f, 0.0f));
			RenderTextClipped(window->Pos + vsize(14, window->TitleBarHeight() - 6), window->Pos + window->Size - vsize(8, 5), groupboxName, NULL, NULL, vsize(0, 0));
			PopStyleColor();

			// Title bar
			if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
			{
				ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBg);
				window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
			}

			// Menu bar
			if (flags & HanaLovesMeWindowFlags_MenuBar)
			{
				vsrect menu_bar_rect = window->MenuBarRect();
				menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
				window->DrawList->AddRectFilled(menu_bar_rect.Min + vsize(window_border_size, 0), menu_bar_rect.Max - vsize(window_border_size, 0), GetColorU32(HanaLovesMeCol_MenuBarBg), (flags & HanaLovesMeWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
				if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
					window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(HanaLovesMeCol_Border), style.FrameBorderSize);
			}

			// Scrollbars
			if (window->ScrollbarX)
				Scrollbar(HanaLovesMeAxis_X);
			if (window->ScrollbarY)
				Scrollbar(HanaLovesMeAxis_Y);

			// Render resize grips (after their input handling so we don't have a frame of latency)
			if (!(flags & HanaLovesMeWindowFlags_NoResize))
			{
				for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
				{
					const HanaLovesMeResizeGripDef& grip = resize_grip_def[resize_grip_n];
					const vsize corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(window_border_size, grip_draw_size) : vsize(grip_draw_size, window_border_size)));
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(grip_draw_size, window_border_size) : vsize(window_border_size, grip_draw_size)));
					window->DrawList->PathArcToFast(vsize(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
					window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
				}
			}

			// Borders
			RenderOuterBorders(window);
		}

		// Draw navigation selection/windowing rectangle border
		if (g.NavWindowingTargetAnim == window)
		{
			float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
			{
				bb.Expand(-g.FontSize - 1.0f);
				rounding = window->WindowRounding;
			}
			window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
		}

		// Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
		window->SizeFullAtLastBegin = window->SizeFull;

		// Update various regions. Variables they depends on are set above in this function.
		// FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
		window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
		window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
		window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
		window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
		window->DC.GroupOffset.x = 0.0f;
		window->DC.ColumnsOffset.x = 0.0f;
		window->DC.CursorStartPos = window->Pos + vsize(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
		window->DC.CursorPos = window->DC.CursorStartPos;
		window->DC.CursorPosPrevLine = window->DC.CursorPos;
		window->DC.CursorMaxPos = window->DC.CursorStartPos;
		window->DC.CurrentLineSize = window->DC.PrevLineSize = vsize(0.0f, 0.0f);
		window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
		window->DC.NavHideHighlightOneFrame = false;
		window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
		window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
		window->DC.NavLayerActiveMaskNext = 0x00;
		window->DC.MenuBarAppending = false;
		window->DC.ChildWindows.resize(0);
		window->DC.LayoutType = HanaLovesMeLayoutType_Vertical;
		window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : HanaLovesMeLayoutType_Vertical;
		window->DC.FocusCounterAll = window->DC.FocusCounterTab = -1;
		window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : HanaLovesMeItemFlags_Default_;
		window->DC.ItemWidth = window->ItemWidthDefault;
		window->DC.TextWrapPos = -1.0f; // disabled
		window->DC.ItemFlagsStack.resize(0);
		window->DC.ItemWidthStack.resize(0);
		window->DC.TextWrapPosStack.resize(0);
		window->DC.CurrentColumns = NULL;
		window->DC.TreeDepth = 0;
		window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
		window->DC.StateStohnly = &window->StateStohnly;
		window->DC.GroupStack.resize(0);
		window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
		{
			window->DC.ItemFlags = parent_window->DC.ItemFlags;
			window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
		}

		if (window->AutoFitFramesX > 0)
			window->AutoFitFramesX--;
		if (window->AutoFitFramesY > 0)
			window->AutoFitFramesY--;

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		if (want_focus)
		{
			FocusWindow(window);
			NavInitWindow(window, false);
		}

		// Title bar
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
		{
			// Close & collapse button are on layer 1 (same as menus) and don't default focus
			const HanaLovesMeItemFlags item_flags_backup = window->DC.ItemFlags;
			window->DC.ItemFlags |= HanaLovesMeItemFlags_NoNavDefaultFocus;
			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Menu;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Menu);

			// Collapse button
			if (!(flags & HanaLovesMeWindowFlags_NoCollapse))
				if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
					window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

			// Close button
			if (p_open != NULL)
			{
				const float rad = g.FontSize * 0.5f;
				if (CloseButton(window->GetID("#CLOSE"), vsize(window->Pos.x + window->Size.x - style.FramePadding.x - rad, window->Pos.y + style.FramePadding.y + rad), rad + 1))
					* p_open = false;
			}

			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Main;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Main);
			window->DC.ItemFlags = item_flags_backup;

			// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
			// FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
			const char* UNSAVED_DOCUMENT_MARKER = "*";
			float marker_size_x = (flags & HanaLovesMeWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
			vsize text_size = CalcTextSize(name, NULL, true) + vsize(marker_size_x, 0.0f);
			vsrect text_r = title_bar_rect;
			float pad_left = (flags & HanaLovesMeWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			float pad_right = (p_open == NULL) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			if (style.WindowTitleAlign.x > 0.0f)
				pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
			text_r.Min.x += pad_left;
			text_r.Max.x -= pad_right;
			vsrect clip_rect = text_r;
			clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
			RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
			if (flags & HanaLovesMeWindowFlags_UnsavedDocument)
			{
				vsize marker_pos = vsize(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + vsize(2 - marker_size_x, 0.0f);
				vsize off = vsize(0.0f, (float)(int)(-g.FontSize * 0.25f));
				RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, vsize(0, style.WindowTitleAlign.y), &clip_rect);
			}
		}

		// Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
		window->OuterRectClipped = window->Rect();
		window->OuterRectClipped.ClipWith(window->ClipRect);

		// Pressing CTRL+C while holding on a window copy its content to the clipboard
		// This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
		// Maybe we can support CTRL+C on every element?
		/*
		if (g.ActiveId == move_id)
			if (g.IO.KeyCtrl && IsKeyPressedMap(HanaLovesMeKey_C))
				LogToClipboard();
		*/

		// Inner rectangle
		// We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
		window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
		window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & HanaLovesMeWindowFlags_MenuBar) || !(flags & HanaLovesMeWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
		window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
		window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
		//window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

		// Inner clipping rectangle
		// Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
		window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

		// We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
		// This is useful to allow creating context menus on title bar only, etc.
		window->DC.LastItemId = window->MoveId;
		window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? HanaLovesMeItemStatusFlags_HoveredRect : 0;
		window->DC.LastItemRect = title_bar_rect;
#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
		if (!(window->Flags & HanaLovesMeWindowFlags_NoTitleBar))
			HanaLovesMe_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);
#endif
	}
	else
	{
		// Append
		SetCurrentWindow(window);
	}

	PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	if (first_begin_of_the_frame)
		window->WriteAccessed = false;

	window->BeginCount++;
	g.NextWindowData.Clear();

	if (flags & HanaLovesMeWindowFlags_ChildWindow)
	{
		// Child window can be out of sight and have "negative" clip windows.
		// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
		IM_ASSERT((flags & HanaLovesMeWindowFlags_NoTitleBar) != 0);
		if (!(flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
			if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
				window->HiddenFramesCanSkipItems = 1;

		// Completely hide along with parent or if parent is collapsed
		if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
			window->HiddenFramesCanSkipItems = 1;
	}

	// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
	if (style.Alpha <= 0.0f)
		window->HiddenFramesCanSkipItems = 1;

	// Update the Hidden flag
	window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);

	// Update the SkipItems flag, used to early out of all items functions (no layout required)
	bool skip_items = false;
	if (window->Collapsed || !window->Active || window->Hidden)
		if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
			skip_items = true;
	window->SkipItems = skip_items;

	return !skip_items;
}

bool HanaLovesMe::BeginComboBackground(const char* name, bool* p_open, HanaLovesMeWindowFlags flags)
{
	HanaLovesMeContext& g = *GHanaLovesMe;
	const HanaLovesMeStyle& style = g.Style;
	IM_ASSERT(name != NULL && name[0] != '\0');     // Window name required
	IM_ASSERT(g.FrameScopeActive);                  // Forgot to call HanaLovesMe::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called HanaLovesMe::Render() or HanaLovesMe::EndFrame() and haven't called HanaLovesMe::NewFrame() again yet

	// Find or create
	HanaLovesMeWindow * window = FindWindowByName(name);
	const bool window_just_created = (window == NULL);
	if (window_just_created)
	{
		vsize size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : vsize(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
		window = CreateNewWindow(name, size_on_first_use, flags);
	}

	// Automatically disable manual moving/resizing when NoInputs is set
	if ((flags & HanaLovesMeWindowFlags_NoInputs) == HanaLovesMeWindowFlags_NoInputs)
		flags |= HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoResize;

	if (flags & HanaLovesMeWindowFlags_NavFlattened)
		IM_ASSERT(flags & HanaLovesMeWindowFlags_ChildWindow);

	const int current_frame = g.FrameCount;
	const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);

	// Update the Appearing flag
	bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFramesCannotSkipItems > 0);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window);
	}
	window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, true);

	// Update Flags, LastFrameActive, BeginOrderXXX fields
	if (first_begin_of_the_frame)
	{
		window->Flags = (HanaLovesMeWindowFlags)flags;
		window->LastFrameActive = current_frame;
		window->BeginOrderWithinParent = 0;
		window->BeginOrderWithinContext = (short)(g.WindowsActiveCount++);
	}
	else
	{
		flags = window->Flags;
	}

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	HanaLovesMeWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
	HanaLovesMeWindow* parent_window = first_begin_of_the_frame ? ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
	IM_ASSERT(parent_window != NULL || !(flags & HanaLovesMeWindowFlags_ChildWindow));

	// Add to stack
	// We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
	g.CurrentWindowStack.push_back(window);
	g.CurrentWindow = NULL;
	CheckStacksSize(window, true);
	if (flags & HanaLovesMeWindowFlags_Popup)
	{
		HanaLovesMePopupRef& popup_ref = g.OpenPopupStack[g.BeginPopupStack.Size];
		popup_ref.Window = window;
		g.BeginPopupStack.push_back(popup_ref);
		window->PopupId = popup_ref.PopupId;
	}

	if (window_just_appearing_after_hidden_for_resize && !(flags & HanaLovesMeWindowFlags_ChildWindow))
		window->NavLastIds[0] = 0;

	// Process SetNextWindow***() calls
	bool window_pos_set_by_api = false;
	bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
	if (g.NextWindowData.PosCond)
	{
		window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
		if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
		{
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window->SetWindowPosVal = g.NextWindowData.PosVal;
			window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
			window->SetWindowPosAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);
		}
		else
		{
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
		}
	}
	if (g.NextWindowData.SizeCond)
	{
		window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
		window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
	}
	if (g.NextWindowData.ContentSizeCond)
	{
		// Adjust passed "client size" to become a "window size"
		window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
		if (window->SizeContentsExplicit.y != 0.0f)
			window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
	}
	else if (first_begin_of_the_frame)
	{
		window->SizeContentsExplicit = vsize(0.0f, 0.0f);
	}
	if (g.NextWindowData.CollapsedCond)
		SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
	if (g.NextWindowData.FocusCond)
		FocusWindow(window);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, HanaLovesMeCond_Appearing, false);

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if (first_begin_of_the_frame)
	{
		// Initialize
		const bool window_is_child_tooltip = (flags & HanaLovesMeWindowFlags_ChildWindow) && (flags & HanaLovesMeWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
		UpdateWindowParentAndRootLinks(window, flags, parent_window);

		window->Active = true;
		window->HasCloseButton = (p_open != NULL);
		window->ClipRect = xuifloatcolor(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
		window->IDStack.resize(1);

		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
		// The title bar always display the 'name' parameter, so we only update the string stohnly if it needs to be visible to the end-user elsewhere.
		bool window_title_visible_elsewhere = false;
		if (g.NavWindowingList != NULL && (window->Flags & HanaLovesMeWindowFlags_NoNavFocus) == 0)   // Window titles visible when using CTRL+TAB
			window_title_visible_elsewhere = true;
		if (window_title_visible_elsewhere && !window_just_created && strcmp(name, window->Name) != 0)
		{
			size_t buf_len = (size_t)window->NameBufLen;
			window->Name = ImStrdupcpy(window->Name, &buf_len, name);
			window->NameBufLen = (int)buf_len;
		}

		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

		// Update contents size from last frame for auto-fitting (or use explicit size)
		window->SizeContents = CalcSizeContents(window);
		if (window->HiddenFramesCanSkipItems > 0)
			window->HiddenFramesCanSkipItems--;
		if (window->HiddenFramesCannotSkipItems > 0)
			window->HiddenFramesCannotSkipItems--;

		// Hide new windows for one frame until they calculate their size
		if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
			window->HiddenFramesCannotSkipItems = 1;

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		// We reset Size/SizeContents for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
		if (window_just_activated_by_user && (flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) != 0)
		{
			window->HiddenFramesCannotSkipItems = 1;
			if (flags & HanaLovesMeWindowFlags_AlwaysAutoResize)
			{
				if (!window_size_x_set_by_api)
					window->Size.x = window->SizeFull.x = 0.f;
				if (!window_size_y_set_by_api)
					window->Size.y = window->SizeFull.y = 0.f;
				window->SizeContents = vsize(0.f, 0.f);
			}
		}

		SetCurrentWindow(window);

		// Lock border size and padding for the frame (so that altering them doesn't cause inconsistencies)
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
			window->WindowBorderSize = style.ChildBorderSize;
		else
			window->WindowBorderSize = ((flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Tooltip)) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
		window->WindowPadding = style.WindowPadding;
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & (HanaLovesMeWindowFlags_AlwaysUseWindowPadding | HanaLovesMeWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
			window->WindowPadding = vsize(0.0f, (flags & HanaLovesMeWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);
		window->DC.MenuBarOffset.x = ImMax(ImMax(window->WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
		window->DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar) && !(flags & HanaLovesMeWindowFlags_NoCollapse))
		{
			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed), so verify that we don't have items over the title bar.
			vsrect title_bar_rect = window->TitleBarRect();
			if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0])
				window->WantCollapseToggle = true;
			if (window->WantCollapseToggle)
			{
				window->Collapsed = !window->Collapsed;
				MarkIniSettingsDirty(window);
				FocusWindow(window);
			}
		}
		else
		{
			window->Collapsed = false;
		}
		window->WantCollapseToggle = false;

		// SIZE

		// Calculate auto-fit size, handle automatic resize
		const vsize size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
		vsize size_full_modified(FLT_MAX, FLT_MAX);
		if ((flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && !window->Collapsed)
		{
			// Using SetNextWindowSize() overrides HanaLovesMeWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if (!window_size_x_set_by_api)
				window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
			if (!window_size_y_set_by_api)
				window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
		}
		else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
		{
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor HanaLovesMeWindowFlags_AlwaysAutoResize when collapsed.
			if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
				window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
			if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
				window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
			if (!window->Collapsed)
				MarkIniSettingsDirty(window);
		}

		// Apply minimum/maximum window size constraints and final size
		window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
		window->Size = window->Collapsed && !(flags & HanaLovesMeWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

		// SCROLLBAR STATUS

		// Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
		if (!window->Collapsed)
		{
			// When reading the current size we need to read it after size constraints have been applied
			float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
			float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
			window->ScrollbarY = (flags & HanaLovesMeWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & HanaLovesMeWindowFlags_NoScrollbar));
			window->ScrollbarX = (flags & HanaLovesMeWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & HanaLovesMeWindowFlags_NoScrollbar) && (flags & HanaLovesMeWindowFlags_HorizontalScrollbar));
			if (window->ScrollbarX && !window->ScrollbarY)
				window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & HanaLovesMeWindowFlags_NoScrollbar);
			window->ScrollbarSizes = vsize(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
		}

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if (window_just_activated_by_user)
		{
			window->AutoPosLastDirection = HanaLovesMeDir_None;
			if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api)
				window->Pos = g.BeginPopupStack.back().OpenPopupPos;
		}

		// Position child window
		if (flags & HanaLovesMeWindowFlags_ChildWindow)
		{
			IM_ASSERT(parent_window && parent_window->Active);
			window->BeginOrderWithinParent = (short)parent_window->DC.ChildWindows.Size;
			parent_window->DC.ChildWindows.push_back(window);
			if (!(flags & HanaLovesMeWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
				window->Pos = parent_window->DC.CursorPos;
		}

		const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFramesCannotSkipItems == 0);
		if (window_pos_with_pivot)
			SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0); // Position given a pivot (e.g. for centering)
		else if ((flags & HanaLovesMeWindowFlags_ChildMenu) != 0)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
			window->Pos = FindBestWindowPosForPopup(window);
		else if ((flags & HanaLovesMeWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
			window->Pos = FindBestWindowPosForPopup(window);

		// Clamp position so it stays visible
		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
		vsrect viewport_rect(GetViewportRect());
		if (!window_pos_set_by_api && !(flags & HanaLovesMeWindowFlags_ChildWindow) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
		{
			if (g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
			{
				vsize clamp_padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
				ClampWindowRect(window, viewport_rect, clamp_padding);
			}
		}
		window->Pos = ImFloor(window->Pos);

		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
		window->WindowRounding = (flags & HanaLovesMeWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & HanaLovesMeWindowFlags_Popup) && !(flags & HanaLovesMeWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;

		// Apply scrolling
		window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window, true);
		window->ScrollTarget = vsize(FLT_MAX, FLT_MAX);

		// Apply window focus (new and reactivated windows are moved to front)
		bool want_focus = false;
		if (window_just_activated_by_user && !(flags & HanaLovesMeWindowFlags_NoFocusOnAppearing))
		{
			if (flags & HanaLovesMeWindowFlags_Popup)
				want_focus = true;
			else if ((flags & (HanaLovesMeWindowFlags_ChildWindow | HanaLovesMeWindowFlags_Tooltip)) == 0)
				want_focus = true;
		}

		// Handle manual resize: Resize Grips, Borders, Gamepad
		int border_held = -1;
		ImU32 resize_grip_col[4] = { 0 };
		const int resize_grip_count = g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // 4
		const float grip_draw_size = (float)(int)ImMax(9 * 1.0f, window->WindowRounding + 0.0f + g.FontSize * 0.f); // sedmapickamaterina
		if (!window->Collapsed)
			UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);
		window->ResizeBorderHeld = (signed char)border_held;

		// Default item width. Make it proportional to window size if window manually resizes
		if (window->Size.x > 0.0f && !(flags & HanaLovesMeWindowFlags_Tooltip) && !(flags & HanaLovesMeWindowFlags_AlwaysAutoResize))
			window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
		else
			window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

		// DRAWING

		// Setup draw list and outer clipping rectangle
		window->DrawList->Clear();
		window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
		window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && !(flags & HanaLovesMeWindowFlags_Popup) && !window_is_child_tooltip)
			PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
		else
			PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

		// Draw modal window background (darkens what is behind them, all viewports)
		const bool dim_bg_for_modal = (flags & HanaLovesMeWindowFlags_Modal) && window == GetFrontMostPopupModal() && window->HiddenFramesCannotSkipItems <= 0;
		const bool dim_bg_for_window_list = g.NavWindowingTargetAnim && (window == g.NavWindowingTargetAnim->RootWindow);
		if (dim_bg_for_modal || dim_bg_for_window_list)
		{
			const ImU32 dim_bg_col = GetColorU32(dim_bg_for_modal ? HanaLovesMeCol_ModalWindowDimBg : HanaLovesMeCol_NavWindowingDimBg, g.DimBgRatio);
			window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, dim_bg_col);
		}

		// Draw navigation selection/windowing rectangle background
		if (dim_bg_for_window_list && window == g.NavWindowingTargetAnim)
		{
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
				window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
		}

		// Draw window + handle manual resize
		// As we highlight the title bar when want_focus is set, multiple reappearing windows will have have their title bar highlighted on their reappearing frame.
		const float window_rounding = window->WindowRounding;
		const float window_border_size = window->WindowBorderSize;
		const HanaLovesMeWindow* window_to_highlight = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow;
		const bool title_bar_is_highlight = want_focus || (window_to_highlight && window->RootWindowForTitleBarHighlight == window_to_highlight->RootWindowForTitleBarHighlight);
		const vsrect title_bar_rect = window->TitleBarRect();
		if (window->Collapsed)
		{
			// Title bar only
			float backup_border_size = style.FrameBorderSize;
			g.Style.FrameBorderSize = window->WindowBorderSize;
			ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBgCollapsed);
			RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
			g.Style.FrameBorderSize = backup_border_size;
		}
		else
		{
			auto borderColor = xuicolor(10, 10, 10);
			auto backgroundColor = xuicolor(35, 35, 35);

			window->DrawList->AddRectFilledMultiColor(window->Pos + vsize(0, window->TitleBarHeight() + 2), window->Pos + window->Size, backgroundColor, backgroundColor, backgroundColor, backgroundColor);
			window->DrawList->AddRect(window->Pos + vsize(0, window->TitleBarHeight() + 1), window->Pos + window->Size, borderColor, 0, false, 0.4);

			// Title bar
			if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
			{
				ImU32 title_bar_col = GetColorU32(title_bar_is_highlight ? HanaLovesMeCol_TitleBgActive : HanaLovesMeCol_TitleBg);
				window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);
			}

			// Menu bar
			if (flags & HanaLovesMeWindowFlags_MenuBar)
			{
				vsrect menu_bar_rect = window->MenuBarRect();
				menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
				window->DrawList->AddRectFilled(menu_bar_rect.Min + vsize(window_border_size, 0), menu_bar_rect.Max - vsize(window_border_size, 0), GetColorU32(HanaLovesMeCol_MenuBarBg), (flags & HanaLovesMeWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
				if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
					window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(HanaLovesMeCol_Border), style.FrameBorderSize);
			}

			// Scrollbars
			if (window->ScrollbarX)
				Scrollbar(HanaLovesMeAxis_X);
			if (window->ScrollbarY)
				Scrollbar(HanaLovesMeAxis_Y);

			// Render resize grips (after their input handling so we don't have a frame of latency)
			if (!(flags & HanaLovesMeWindowFlags_NoResize))
			{
				for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
				{
					const HanaLovesMeResizeGripDef& grip = resize_grip_def[resize_grip_n];
					const vsize corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPosN);
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(window_border_size, grip_draw_size) : vsize(grip_draw_size, window_border_size)));
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? vsize(grip_draw_size, window_border_size) : vsize(window_border_size, grip_draw_size)));
					window->DrawList->PathArcToFast(vsize(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
					window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
				}
			}

			// Borders
			RenderOuterBorders(window);
		}

		// Draw navigation selection/windowing rectangle border
		if (g.NavWindowingTargetAnim == window)
		{
			float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
			vsrect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
			{
				bb.Expand(-g.FontSize - 1.0f);
				rounding = window->WindowRounding;
			}
			window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(HanaLovesMeCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
		}

		// Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
		window->SizeFullAtLastBegin = window->SizeFull;

		// Update various regions. Variables they depends on are set above in this function.
		// FIXME: window->ContentsRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
		window->ContentsRegionRect.Min.x = window->Pos.x - window->Scroll.x + window->WindowPadding.x;
		window->ContentsRegionRect.Min.y = window->Pos.y - window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
		window->ContentsRegionRect.Max.x = window->Pos.x - window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
		window->ContentsRegionRect.Max.y = window->Pos.y - window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window->DC.Indent.x = 0.0f + window->WindowPadding.x - window->Scroll.x;
		window->DC.GroupOffset.x = 0.0f;
		window->DC.ColumnsOffset.x = 0.0f;
		window->DC.CursorStartPos = window->Pos + vsize(window->DC.Indent.x + window->DC.ColumnsOffset.x, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
		window->DC.CursorPos = window->DC.CursorStartPos;
		window->DC.CursorPosPrevLine = window->DC.CursorPos;
		window->DC.CursorMaxPos = window->DC.CursorStartPos;
		window->DC.CurrentLineSize = window->DC.PrevLineSize = vsize(0.0f, 0.0f);
		window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
		window->DC.NavHideHighlightOneFrame = false;
		window->DC.NavHasScroll = (GetWindowScrollMaxY(window) > 0.0f);
		window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
		window->DC.NavLayerActiveMaskNext = 0x00;
		window->DC.MenuBarAppending = false;
		window->DC.ChildWindows.resize(0);
		window->DC.LayoutType = HanaLovesMeLayoutType_Vertical;
		window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : HanaLovesMeLayoutType_Vertical;
		window->DC.FocusCounterAll = window->DC.FocusCounterTab = -1;
		window->DC.ItemFlags = parent_window ? parent_window->DC.ItemFlags : HanaLovesMeItemFlags_Default_;
		window->DC.ItemWidth = window->ItemWidthDefault;
		window->DC.TextWrapPos = -1.0f; // disabled
		window->DC.ItemFlagsStack.resize(0);
		window->DC.ItemWidthStack.resize(0);
		window->DC.TextWrapPosStack.resize(0);
		window->DC.CurrentColumns = NULL;
		window->DC.TreeDepth = 0;
		window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
		window->DC.StateStohnly = &window->StateStohnly;
		window->DC.GroupStack.resize(0);
		window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

		if ((flags & HanaLovesMeWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
		{
			window->DC.ItemFlags = parent_window->DC.ItemFlags;
			window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
		}

		if (window->AutoFitFramesX > 0)
			window->AutoFitFramesX--;
		if (window->AutoFitFramesY > 0)
			window->AutoFitFramesY--;

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		if (want_focus)
		{
			FocusWindow(window);
			NavInitWindow(window, false);
		}

		// Title bar
		if (!(flags & HanaLovesMeWindowFlags_NoTitleBar))
		{
			// Close & collapse button are on layer 1 (same as menus) and don't default focus
			const HanaLovesMeItemFlags item_flags_backup = window->DC.ItemFlags;
			window->DC.ItemFlags |= HanaLovesMeItemFlags_NoNavDefaultFocus;
			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Menu;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Menu);

			// Collapse button
			if (!(flags & HanaLovesMeWindowFlags_NoCollapse))
				if (CollapseButton(window->GetID("#COLLAPSE"), window->Pos))
					window->WantCollapseToggle = true; // Defer collapsing to next frame as we are too far in the Begin() function

			// Close button
			if (p_open != NULL)
			{
				const float rad = g.FontSize * 0.5f;
				if (CloseButton(window->GetID("#CLOSE"), vsize(window->Pos.x + window->Size.x - style.FramePadding.x - rad, window->Pos.y + style.FramePadding.y + rad), rad + 1))
					* p_open = false;
			}

			window->DC.NavLayerCurrent = HanaLovesMeNavLayer_Main;
			window->DC.NavLayerCurrentMask = (1 << HanaLovesMeNavLayer_Main);
			window->DC.ItemFlags = item_flags_backup;

			// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
			// FIXME: Refactor text alignment facilities along with RenderText helpers, this is too much code..
			const char* UNSAVED_DOCUMENT_MARKER = "*";
			float marker_size_x = (flags & HanaLovesMeWindowFlags_UnsavedDocument) ? CalcTextSize(UNSAVED_DOCUMENT_MARKER, NULL, false).x : 0.0f;
			vsize text_size = CalcTextSize(name, NULL, true) + vsize(marker_size_x, 0.0f);
			vsrect text_r = title_bar_rect;
			float pad_left = (flags & HanaLovesMeWindowFlags_NoCollapse) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			float pad_right = (p_open == NULL) ? style.FramePadding.x : (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x);
			if (style.WindowTitleAlign.x > 0.0f)
				pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
			text_r.Min.x += pad_left;
			text_r.Max.x -= pad_right;
			vsrect clip_rect = text_r;
			clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
			RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
			if (flags & HanaLovesMeWindowFlags_UnsavedDocument)
			{
				vsize marker_pos = vsize(ImMax(text_r.Min.x, text_r.Min.x + (text_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x) + text_size.x, text_r.Min.y) + vsize(2 - marker_size_x, 0.0f);
				vsize off = vsize(0.0f, (float)(int)(-g.FontSize * 0.25f));
				RenderTextClipped(marker_pos + off, text_r.Max + off, UNSAVED_DOCUMENT_MARKER, NULL, NULL, vsize(0, style.WindowTitleAlign.y), &clip_rect);
			}
		}

		// Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
		window->OuterRectClipped = window->Rect();
		window->OuterRectClipped.ClipWith(window->ClipRect);

		// Pressing CTRL+C while holding on a window copy its content to the clipboard
		// This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
		// Maybe we can support CTRL+C on every element?
		/*
		if (g.ActiveId == move_id)
			if (g.IO.KeyCtrl && IsKeyPressedMap(HanaLovesMeKey_C))
				LogToClipboard();
		*/

		// Inner rectangle
		// We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
		window->InnerMainRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
		window->InnerMainRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & HanaLovesMeWindowFlags_MenuBar) || !(flags & HanaLovesMeWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
		window->InnerMainRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
		window->InnerMainRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
		//window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

		// Inner clipping rectangle
		// Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerMainRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerMainRect.Min.y);
		window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerMainRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerMainRect.Max.y);

		// We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
		// This is useful to allow creating context menus on title bar only, etc.
		window->DC.LastItemId = window->MoveId;
		window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? HanaLovesMeItemStatusFlags_HoveredRect : 0;
		window->DC.LastItemRect = title_bar_rect;
#ifdef HanaLovesMe_ENABLE_TEST_ENGINE
		if (!(window->Flags & HanaLovesMeWindowFlags_NoTitleBar))
			HanaLovesMe_TEST_ENGINE_ITEM_ADD(window->DC.LastItemRect, window->DC.LastItemId);
#endif
	}
	else
	{
		// Append
		SetCurrentWindow(window);
	}

	PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	if (first_begin_of_the_frame)
		window->WriteAccessed = false;

	window->BeginCount++;
	g.NextWindowData.Clear();

	if (flags & HanaLovesMeWindowFlags_ChildWindow)
	{
		// Child window can be out of sight and have "negative" clip windows.
		// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
		IM_ASSERT((flags & HanaLovesMeWindowFlags_NoTitleBar) != 0);
		if (!(flags & HanaLovesMeWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
			if (window->OuterRectClipped.Min.x >= window->OuterRectClipped.Max.x || window->OuterRectClipped.Min.y >= window->OuterRectClipped.Max.y)
				window->HiddenFramesCanSkipItems = 1;

		// Completely hide along with parent or if parent is collapsed
		if (parent_window && (parent_window->Collapsed || parent_window->Hidden))
			window->HiddenFramesCanSkipItems = 1;
	}

	// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
	if (style.Alpha <= 0.0f)
		window->HiddenFramesCanSkipItems = 1;

	// Update the Hidden flag
	window->Hidden = (window->HiddenFramesCanSkipItems > 0) || (window->HiddenFramesCannotSkipItems > 0);

	// Update the SkipItems flag, used to early out of all items functions (no layout required)
	bool skip_items = false;
	if (window->Collapsed || !window->Active || window->Hidden)
		if (window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && window->HiddenFramesCannotSkipItems <= 0)
			skip_items = true;
	window->SkipItems = skip_items;

	return !skip_items;
}

// Old Begin() API with 5 parameters, avoid calling this version directly! Use SetNextWindowSize()/SetNextWindowBgAlpha() + Begin() instead.
#ifndef HanaLovesMe_DISABLE_OBSOLETE_FUNCTIONS
bool HanaLovesMe::Begin(const char* name, bool* p_open, const vsize & size_first_use, float bg_alpha_override, HanaLovesMeWindowFlags flags)
{
    // Old API feature: we could pass the initial window size as a parameter. This was misleading because it only had an effect if the window didn't have data in the .ini file.
    if (size_first_use.x != 0.0f || size_first_use.y != 0.0f)
        SetNextWindowSize(size_first_use, HanaLovesMeCond_FirstUseEver);

    // Old API feature: override the window background alpha with a parameter.
    if (bg_alpha_override >= 0.0f)
        SetNextWindowBgAlpha(bg_alpha_override);

    return Begin(name, p_open, flags);
}
#endif // HanaLovesMe_DISABLE_OBSOLETE_FUNCTIONS

void HanaLovesMe::End()
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    if (g.CurrentWindowStack.Size <= 1 && g.FrameScopePushedImplicitWindow)
    {
        IM_ASSERT(g.CurrentWindowStack.Size > 1 && "Calling End() too many times!");
        return; // FIXME-ERRORHANDLING
    }
    IM_ASSERT(g.CurrentWindowStack.Size > 0);

    HanaLovesMeWindow* window = g.CurrentWindow;

    if (window->DC.CurrentColumns != NULL)
        EndColumns();
    PopClipRect();   // Inner window clip rectangle

    // Stop logging
    if (!(window->Flags & HanaLovesMeWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
        LogFinish();

    // Pop from window stack
    g.CurrentWindowStack.pop_back();
    if (window->Flags & HanaLovesMeWindowFlags_Popup)
        g.BeginPopupStack.pop_back();
    CheckStacksSize(window, false);
    SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());
}

void HanaLovesMe::BringWindowToFocusFront(HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.WindowsFocusOrder.back() == window)
        return;
    for (int i = g.WindowsFocusOrder.Size - 2; i >= 0; i--) // We can ignore the front most window
        if (g.WindowsFocusOrder[i] == window)
        {
            memmove(&g.WindowsFocusOrder[i], &g.WindowsFocusOrder[i + 1], (size_t)(g.WindowsFocusOrder.Size - i - 1) * sizeof(HanaLovesMeWindow*));
            g.WindowsFocusOrder[g.WindowsFocusOrder.Size - 1] = window;
            break;
        }
}

void HanaLovesMe::BringWindowToDisplayFront(HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* current_front_window = g.Windows.back();
    if (current_front_window == window || current_front_window->RootWindow == window)
        return;
    for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the front most window
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[i], &g.Windows[i + 1], (size_t)(g.Windows.Size - i - 1) * sizeof(HanaLovesMeWindow*));
            g.Windows[g.Windows.Size - 1] = window;
            break;
        }
}

void HanaLovesMe::BringWindowToDisplayBack(HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.Windows[0] == window)
        return;
    for (int i = 0; i < g.Windows.Size; i++)
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(HanaLovesMeWindow*));
            g.Windows[0] = window;
            break;
        }
}

// Moving window to front of display and set focus (which happens to be back of our sorted list)
void HanaLovesMe::FocusWindow(HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    if (g.NavWindow != window)
    {
        g.NavWindow = window;
        if (window && g.NavDisableMouseHover)
            g.NavMousePosDirty = true;
        g.NavInitRequest = false;
        g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
        g.NavIdIsAlive = false;
        g.NavLayer = HanaLovesMeNavLayer_Main;
        //HanaLovesMe_DEBUG_LOG("FocusWindow(\"%s\")\n", window ? window->Name : NULL);
    }

    // Passing NULL allow to disable keyboard focus
    if (!window)
        return;

    // Move the root window to the top of the pile
    if (window->RootWindow)
        window = window->RootWindow;

    // Steal focus on active widgets
    if (window->Flags & HanaLovesMeWindowFlags_Popup) // FIXME: This statement should be unnecessary. Need further testing before removing it..
        if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != window)
            ClearActiveID();

    // Bring to front
    BringWindowToFocusFront(window);
    if (!(window->Flags & HanaLovesMeWindowFlags_NoBringToFrontOnFocus))
        BringWindowToDisplayFront(window);
}

void HanaLovesMe::FocusPreviousWindowIgnoringOne(HanaLovesMeWindow * ignore_window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    for (int i = g.WindowsFocusOrder.Size - 1; i >= 0; i--)
    {
        // We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
        HanaLovesMeWindow* window = g.WindowsFocusOrder[i];
        if (window != ignore_window && window->WasActive && !(window->Flags & HanaLovesMeWindowFlags_ChildWindow))
            if ((window->Flags & (HanaLovesMeWindowFlags_NoMouseInputs | HanaLovesMeWindowFlags_NoNavInputs)) != (HanaLovesMeWindowFlags_NoMouseInputs | HanaLovesMeWindowFlags_NoNavInputs))
            {
                HanaLovesMeWindow* focus_window = NavRestoreLastChildNavWindow(window);
                FocusWindow(focus_window);
                return;
            }
    }
}

void HanaLovesMe::PushItemWidth(float item_width)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);
    window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);
}

void HanaLovesMe::PushMultiItemsWidths(int components, float w_full)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    const HanaLovesMeStyle& style = GHanaLovesMe->Style;
    if (w_full <= 0.0f)
        w_full = CalcItemWidth();
    const float w_item_one = ImMax(1.0f, (float)(int)((w_full - (style.ItemInnerSpacing.x) * (components - 1)) / (float)components));
    const float w_item_last = ImMax(1.0f, (float)(int)(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components - 1)));
    window->DC.ItemWidthStack.push_back(w_item_last);
    for (int i = 0; i < components - 1; i++)
        window->DC.ItemWidthStack.push_back(w_item_one);
    window->DC.ItemWidth = window->DC.ItemWidthStack.back();
}

void HanaLovesMe::PopItemWidth()
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DC.ItemWidthStack.pop_back();
    window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();
}

// Calculate default item width given value passed to PushItemWidth()
float HanaLovesMe::CalcItemWidth()
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    float w = window->DC.ItemWidth;
    if (w < 0.0f)
    {
        float region_max_x = GetContentRegionMaxScreen().x;
        w = ImMax(1.0f, region_max_x - window->DC.CursorPos.x + w);
    }
    w = (float)(int)w;
    return w;
}

// [Internal] Calculate full item size given user provided 'size' parameter and default width/height. Default width is often == CalcItemWidth().
// Those two functions CalcItemWidth vs CalcItemSize are awkwardly named because they are not fully symmetrical.
// Note that only CalcItemWidth() is publicly exposed.
// The 4.0f here may be changed to match CalcItemWidth() and/or BeginChild() (right now we have a mismatch which is harmless but undesirable)
vsize HanaLovesMe::CalcItemSize(vsize size, float default_w, float default_h)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;

    vsize region_max;
    if (size.x < 0.0f || size.y < 0.0f)
        region_max = GetContentRegionMaxScreen();

    if (size.x == 0.0f)
        size.x = default_w;
    else if (size.x < 0.0f)
        size.x = ImMax(4.0f, region_max.x - window->DC.CursorPos.x + size.x);

    if (size.y == 0.0f)
        size.y = default_h;
    else if (size.y < 0.0f)
        size.y = ImMax(4.0f, region_max.y - window->DC.CursorPos.y + size.y);

    return size;
}

void HanaLovesMe::SetCurrentFont(ImFont * font)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
    IM_ASSERT(font->Scale > 0.0f);
    g.Font = font;
    g.FontBaseSize = ImMax(1.0f, g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale);
    g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

    ImFontAtlas* atlas = g.Font->ContainerAtlas;
    g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
    g.DrawListSharedData.Font = g.Font;
    g.DrawListSharedData.FontSize = g.FontSize;
}

void HanaLovesMe::PushFont(ImFont * font)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (!font)
        font = GetDefaultFont();
    SetCurrentFont(font);
    g.FontStack.push_back(font);
    g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);
}

void  HanaLovesMe::PopFont()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.CurrentWindow->DrawList->PopTextureID();
    g.FontStack.pop_back();
    SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());
}

void HanaLovesMe::PushItemFlag(HanaLovesMeItemFlags option, bool enabled)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    if (enabled)
        window->DC.ItemFlags |= option;
    else
        window->DC.ItemFlags &= ~option;
    window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
}

void HanaLovesMe::PopItemFlag()
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DC.ItemFlagsStack.pop_back();
    window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? HanaLovesMeItemFlags_Default_ : window->DC.ItemFlagsStack.back();
}

// FIXME: Look into renaming this once we have settled the new Focus/Activation/TabStop system.
void HanaLovesMe::PushAllowKeyboardFocus(bool allow_keyboard_focus)
{
    PushItemFlag(HanaLovesMeItemFlags_NoTabStop, !allow_keyboard_focus);
}

void HanaLovesMe::PopAllowKeyboardFocus()
{
    PopItemFlag();
}

void HanaLovesMe::PushButtonRepeat(bool repeat)
{
    PushItemFlag(HanaLovesMeItemFlags_ButtonRepeat, repeat);
}

void HanaLovesMe::PopButtonRepeat()
{
    PopItemFlag();
}

void HanaLovesMe::PushTextWrapPos(float wrap_pos_x)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DC.TextWrapPos = wrap_pos_x;
    window->DC.TextWrapPosStack.push_back(wrap_pos_x);
}

void HanaLovesMe::PopTextWrapPos()
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DC.TextWrapPosStack.pop_back();
    window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();
}

// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
void HanaLovesMe::PushStyleColor(HanaLovesMeCol idx, ImU32 col)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorModifiers.push_back(backup);
    g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
}

void HanaLovesMe::PushStyleColor(HanaLovesMeCol idx, const xuifloatcolor & col)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeColorMod backup;
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    g.ColorModifiers.push_back(backup);
    g.Style.Colors[idx] = col;
}

void HanaLovesMe::PushColor(HanaLovesMeCol idx, HanaLovesMeCol idx2, const xuifloatcolor& col) {

	HanaLovesMeContext& g = *GHanaLovesMe;
	HanaLovesMeColorMod backup;
	backup.Col = idx;
	backup.BackupValue = g.Style.Colors[idx];
	g.ColorModifiers.push_back(backup);
	g.Style.Colors[idx] = g.Style.Colors[idx2];
}

void HanaLovesMe::PopStyleColor(int count)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    while (count > 0)
    {
        HanaLovesMeColorMod& backup = g.ColorModifiers.back();
        g.Style.Colors[backup.Col] = backup.BackupValue;
        g.ColorModifiers.pop_back();
        count--;
    }
}

struct HanaLovesMeStyleVarInfo
{
    HanaLovesMeDataType   Type;
    ImU32           Count;
    ImU32           Offset;
    void* GetVarPtr(HanaLovesMeStyle* style) const { return (void*)((unsigned char*)style + Offset); }
};

static const HanaLovesMeStyleVarInfo GStyleVarInfo[] =
{
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, Alpha) },               // HanaLovesMeStyleVar_Alpha
    { HanaLovesMeDataType_Float, 2, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, WindowPadding) },       // HanaLovesMeStyleVar_WindowPadding
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, WindowRounding) },      // HanaLovesMeStyleVar_WindowRounding
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, WindowBorderSize) },    // HanaLovesMeStyleVar_WindowBorderSize
    { HanaLovesMeDataType_Float, 2, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, WindowMinSize) },       // HanaLovesMeStyleVar_WindowMinSize
    { HanaLovesMeDataType_Float, 2, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, WindowTitleAlign) },    // HanaLovesMeStyleVar_WindowTitleAlign
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, ChildRounding) },       // HanaLovesMeStyleVar_ChildRounding
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, ChildBorderSize) },     // HanaLovesMeStyleVar_ChildBorderSize
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, PopupRounding) },       // HanaLovesMeStyleVar_PopupRounding
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, PopupBorderSize) },     // HanaLovesMeStyleVar_PopupBorderSize
    { HanaLovesMeDataType_Float, 2, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, FramePadding) },        // HanaLovesMeStyleVar_FramePadding
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, FrameRounding) },       // HanaLovesMeStyleVar_FrameRounding
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, FrameBorderSize) },     // HanaLovesMeStyleVar_FrameBorderSize
    { HanaLovesMeDataType_Float, 2, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, ItemSpacing) },         // HanaLovesMeStyleVar_ItemSpacing
    { HanaLovesMeDataType_Float, 2, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, ItemInnerSpacing) },    // HanaLovesMeStyleVar_ItemInnerSpacing
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, IndentSpacing) },       // HanaLovesMeStyleVar_IndentSpacing
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, ScrollbarSize) },       // HanaLovesMeStyleVar_ScrollbarSize
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, ScrollbarRounding) },   // HanaLovesMeStyleVar_ScrollbarRounding
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, GrabMinSize) },         // HanaLovesMeStyleVar_GrabMinSize
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, GrabRounding) },        // HanaLovesMeStyleVar_GrabRounding
    { HanaLovesMeDataType_Float, 1, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, TabRounding) },         // HanaLovesMeStyleVar_TabRounding
    { HanaLovesMeDataType_Float, 2, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, ButtonTextAlign) },     // HanaLovesMeStyleVar_ButtonTextAlign
    { HanaLovesMeDataType_Float, 2, (ImU32)IM_OFFSETOF(HanaLovesMeStyle, SelectableTextAlign) }, // HanaLovesMeStyleVar_SelectableTextAlign
};

static const HanaLovesMeStyleVarInfo* GetStyleVarInfo(HanaLovesMeStyleVar idx)
{
    IM_ASSERT(idx >= 0 && idx < HanaLovesMeStyleVar_COUNT);
    IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == HanaLovesMeStyleVar_COUNT);
    return &GStyleVarInfo[idx];
}

void HanaLovesMe::PushStyleVar(HanaLovesMeStyleVar idx, float val)
{
    const HanaLovesMeStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == HanaLovesMeDataType_Float && var_info->Count == 1)
    {
        HanaLovesMeContext& g = *GHanaLovesMe;
        float* pvar = (float*)var_info->GetVarPtr(&g.Style);
        g.StyleModifiers.push_back(HanaLovesMeStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0); // Called function with wrong-type? Variable is not a float.
}

void HanaLovesMe::PushStyleVar(HanaLovesMeStyleVar idx, const vsize & val)
{
    const HanaLovesMeStyleVarInfo* var_info = GetStyleVarInfo(idx);
    if (var_info->Type == HanaLovesMeDataType_Float && var_info->Count == 2)
    {
        HanaLovesMeContext& g = *GHanaLovesMe;
        vsize* pvar = (vsize*)var_info->GetVarPtr(&g.Style);
        g.StyleModifiers.push_back(HanaLovesMeStyleMod(idx, *pvar));
        *pvar = val;
        return;
    }
    IM_ASSERT(0); // Called function with wrong-type? Variable is not a vsize.
}

void HanaLovesMe::PopStyleVar(int count)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    while (count > 0)
    {
        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
        HanaLovesMeStyleMod& backup = g.StyleModifiers.back();
        const HanaLovesMeStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);
        void* data = info->GetVarPtr(&g.Style);
        if (info->Type == HanaLovesMeDataType_Float && info->Count == 1) { ((float*)data)[0] = backup.BackupFloat[0]; } else if (info->Type == HanaLovesMeDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
        g.StyleModifiers.pop_back();
        count--;
    }
}

const char* HanaLovesMe::GetStyleColorName(HanaLovesMeCol idx)
{
    // Create switch-case from enum with regexp: HanaLovesMeCol_{.*}, --> case HanaLovesMeCol_\1: return "\1";
    switch (idx)
    {
    case HanaLovesMeCol_Text: return "Text";
    case HanaLovesMeCol_TextDisabled: return "TextDisabled";
    case HanaLovesMeCol_WindowBg: return "WindowBg";
    case HanaLovesMeCol_ChildBg: return "ChildBg";
    case HanaLovesMeCol_PopupBg: return "PopupBg";
    case HanaLovesMeCol_Border: return "Border";
    case HanaLovesMeCol_BorderShadow: return "BorderShadow";
    case HanaLovesMeCol_FrameBg: return "FrameBg";
    case HanaLovesMeCol_FrameBgHovered: return "FrameBgHovered";
    case HanaLovesMeCol_FrameBgActive: return "FrameBgActive";
    case HanaLovesMeCol_TitleBg: return "TitleBg";
    case HanaLovesMeCol_TitleBgActive: return "TitleBgActive";
    case HanaLovesMeCol_TitleBgCollapsed: return "TitleBgCollapsed";
    case HanaLovesMeCol_MenuBarBg: return "MenuBarBg";
    case HanaLovesMeCol_ScrollbarBg: return "ScrollbarBg";
    case HanaLovesMeCol_ScrollbarGrab: return "ScrollbarGrab";
    case HanaLovesMeCol_ScrollbarGrabHovered: return "ScrollbarGrabHovered";
    case HanaLovesMeCol_ScrollbarGrabActive: return "ScrollbarGrabActive";
    case HanaLovesMeCol_CheckMark: return "CheckMark";
    case HanaLovesMeCol_SliderGrab: return "SliderGrab";
    case HanaLovesMeCol_SliderGrabActive: return "SliderGrabActive";
    case HanaLovesMeCol_Button: return "Button";
    case HanaLovesMeCol_ButtonHovered: return "ButtonHovered";
    case HanaLovesMeCol_ButtonActive: return "ButtonActive";
    case HanaLovesMeCol_Header: return "Header";
    case HanaLovesMeCol_HeaderHovered: return "HeaderHovered";
    case HanaLovesMeCol_HeaderActive: return "HeaderActive";
    case HanaLovesMeCol_Separator: return "Separator";
    case HanaLovesMeCol_SeparatorHovered: return "SeparatorHovered";
    case HanaLovesMeCol_SeparatorActive: return "SeparatorActive";
    case HanaLovesMeCol_ResizeGrip: return "ResizeGrip";
    case HanaLovesMeCol_ResizeGripHovered: return "ResizeGripHovered";
    case HanaLovesMeCol_ResizeGripActive: return "ResizeGripActive";
    case HanaLovesMeCol_Tab: return "Tab";
    case HanaLovesMeCol_TabHovered: return "TabHovered";
    case HanaLovesMeCol_TabActive: return "TabActive";
    case HanaLovesMeCol_TabUnfocused: return "TabUnfocused";
    case HanaLovesMeCol_TabUnfocusedActive: return "TabUnfocusedActive";
    case HanaLovesMeCol_PlotLines: return "PlotLines";
    case HanaLovesMeCol_PlotLinesHovered: return "PlotLinesHovered";
    case HanaLovesMeCol_PlotHistogram: return "PlotHistogram";
    case HanaLovesMeCol_PlotHistogramHovered: return "PlotHistogramHovered";
    case HanaLovesMeCol_TextSelectedBg: return "TextSelectedBg";
    case HanaLovesMeCol_DragDropTarget: return "DragDropTarget";
    case HanaLovesMeCol_NavHighlight: return "NavHighlight";
    case HanaLovesMeCol_NavWindowingHighlight: return "NavWindowingHighlight";
    case HanaLovesMeCol_NavWindowingDimBg: return "NavWindowingDimBg";
    case HanaLovesMeCol_ModalWindowDimBg: return "ModalWindowDimBg";
    }
    IM_ASSERT(0);
    return "Unknown";
}

bool HanaLovesMe::IsWindowChildOf(HanaLovesMeWindow * window, HanaLovesMeWindow * potential_parent)
{
    if (window->RootWindow == potential_parent)
        return true;
    while (window != NULL)
    {
        if (window == potential_parent)
            return true;
        window = window->ParentWindow;
    }
    return false;
}

bool HanaLovesMe::IsWindowHovered(HanaLovesMeHoveredFlags flags)
{
    IM_ASSERT((flags & HanaLovesMeHoveredFlags_AllowWhenOverlapped) == 0);   // Flags not supported by this function
    HanaLovesMeContext & g = *GHanaLovesMe;

    if (flags & HanaLovesMeHoveredFlags_AnyWindow)
    {
        if (g.HoveredWindow == NULL)
            return false;
    } else
    {
        switch (flags & (HanaLovesMeHoveredFlags_RootWindow | HanaLovesMeHoveredFlags_ChildWindows))
        {
        case HanaLovesMeHoveredFlags_RootWindow | HanaLovesMeHoveredFlags_ChildWindows:
            if (g.HoveredRootWindow != g.CurrentWindow->RootWindow)
                return false;
            break;
        case HanaLovesMeHoveredFlags_RootWindow:
            if (g.HoveredWindow != g.CurrentWindow->RootWindow)
                return false;
            break;
        case HanaLovesMeHoveredFlags_ChildWindows:
            if (g.HoveredWindow == NULL || !IsWindowChildOf(g.HoveredWindow, g.CurrentWindow))
                return false;
            break;
        default:
            if (g.HoveredWindow != g.CurrentWindow)
                return false;
            break;
        }
    }

    if (!IsWindowContentHoverable(g.HoveredWindow, flags))
        return false;
    if (!(flags & HanaLovesMeHoveredFlags_AllowWhenBlockedByActiveItem))
        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId)
            return false;
    return true;
}

bool HanaLovesMe::IsWindowFocused(HanaLovesMeFocusedFlags flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    if (flags & HanaLovesMeFocusedFlags_AnyWindow)
        return g.NavWindow != NULL;

    IM_ASSERT(g.CurrentWindow);     // Not inside a Begin()/End()
    switch (flags & (HanaLovesMeFocusedFlags_RootWindow | HanaLovesMeFocusedFlags_ChildWindows))
    {
    case HanaLovesMeFocusedFlags_RootWindow | HanaLovesMeFocusedFlags_ChildWindows:
        return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;
    case HanaLovesMeFocusedFlags_RootWindow:
        return g.NavWindow == g.CurrentWindow->RootWindow;
    case HanaLovesMeFocusedFlags_ChildWindows:
        return g.NavWindow&& IsWindowChildOf(g.NavWindow, g.CurrentWindow);
    default:
        return g.NavWindow == g.CurrentWindow;
    }
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmaticaly.
// If you want a window to never be focused, you may use the e.g. NoInputs flag.
bool HanaLovesMe::IsWindowNavFocusable(HanaLovesMeWindow * window)
{
    return window->Active&& window == window->RootWindow && !(window->Flags & HanaLovesMeWindowFlags_NoNavFocus);
}

float HanaLovesMe::GetWindowWidth()
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    return window->Size.x;
}

float HanaLovesMe::GetWindowHeight()
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    return window->Size.y;
}

vsize HanaLovesMe::GetWindowPos()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    return window->Pos;
}

void HanaLovesMe::SetWindowScrollX(HanaLovesMeWindow * window, float new_scroll_x)
{
    window->DC.CursorMaxPos.x += window->Scroll.x; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
    window->Scroll.x = new_scroll_x;
    window->DC.CursorMaxPos.x -= window->Scroll.x;
}

void HanaLovesMe::SetWindowScrollY(HanaLovesMeWindow * window, float new_scroll_y)
{
    window->DC.CursorMaxPos.y += window->Scroll.y; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
    window->Scroll.y = new_scroll_y;
    window->DC.CursorMaxPos.y -= window->Scroll.y;
}

void HanaLovesMe::SetWindowPos(HanaLovesMeWindow * window, const vsize & pos, HanaLovesMeCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowPosAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);
    window->SetWindowPosVal = vsize(FLT_MAX, FLT_MAX);

    // Set
    const vsize old_pos = window->Pos;
    window->Pos = ImFloor(pos);
    window->DC.CursorPos += (window->Pos - old_pos);    // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
    window->DC.CursorMaxPos += (window->Pos - old_pos); // And more importantly we need to adjust this so size calculation doesn't get affected.
}

void HanaLovesMe::SetWindowPos(const vsize & pos, HanaLovesMeCond cond)
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    SetWindowPos(window, pos, cond);
}

void HanaLovesMe::SetWindowPos(const char* name, const vsize & pos, HanaLovesMeCond cond)
{
    if (HanaLovesMeWindow * window = FindWindowByName(name))
        SetWindowPos(window, pos, cond);
}

vsize HanaLovesMe::GetWindowSize()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->Size;
}

void HanaLovesMe::SetWindowSize(HanaLovesMeWindow * window, const vsize & size, HanaLovesMeCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
        return;

    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window->SetWindowSizeAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);

    // Set
    if (size.x > 0.0f)
    {
        window->AutoFitFramesX = 0;
        window->SizeFull.x = ImFloor(size.x);
    } else
    {
        window->AutoFitFramesX = 2;
        window->AutoFitOnlyGrows = false;
    }
    if (size.y > 0.0f)
    {
        window->AutoFitFramesY = 0;
        window->SizeFull.y = ImFloor(size.y);
    } else
    {
        window->AutoFitFramesY = 2;
        window->AutoFitOnlyGrows = false;
    }
}

void HanaLovesMe::SetWindowSize(const vsize & size, HanaLovesMeCond cond)
{
    SetWindowSize(GHanaLovesMe->CurrentWindow, size, cond);
}

void HanaLovesMe::SetWindowSize(const char* name, const vsize & size, HanaLovesMeCond cond)
{
    if (HanaLovesMeWindow * window = FindWindowByName(name))
        SetWindowSize(window, size, cond);
}

void HanaLovesMe::SetWindowCollapsed(HanaLovesMeWindow * window, bool collapsed, HanaLovesMeCond cond)
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)
        return;
    window->SetWindowCollapsedAllowFlags &= ~(HanaLovesMeCond_Once | HanaLovesMeCond_FirstUseEver | HanaLovesMeCond_Appearing);

    // Set
    window->Collapsed = collapsed;
}

void HanaLovesMe::SetWindowCollapsed(bool collapsed, HanaLovesMeCond cond)
{
    SetWindowCollapsed(GHanaLovesMe->CurrentWindow, collapsed, cond);
}

bool HanaLovesMe::IsWindowCollapsed()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->Collapsed;
}

bool HanaLovesMe::IsWindowAppearing()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->Appearing;
}

void HanaLovesMe::SetWindowCollapsed(const char* name, bool collapsed, HanaLovesMeCond cond)
{
    if (HanaLovesMeWindow * window = FindWindowByName(name))
        SetWindowCollapsed(window, collapsed, cond);
}

void HanaLovesMe::SetWindowFocus()
{
    FocusWindow(GHanaLovesMe->CurrentWindow);
}

void HanaLovesMe::SetWindowFocus(const char* name)
{
    if (name)
    {
        if (HanaLovesMeWindow * window = FindWindowByName(name))
            FocusWindow(window);
    } else
    {
        FocusWindow(NULL);
    }
}

void HanaLovesMe::SetNextWindowPos(const vsize & pos, HanaLovesMeCond cond, const vsize & pivot)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.PosVal = pos;
    g.NextWindowData.PosPivotVal = pivot;
    g.NextWindowData.PosCond = cond ? cond : HanaLovesMeCond_Always;
}

void HanaLovesMe::SetNextWindowSize(const vsize & size, HanaLovesMeCond cond)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.SizeVal = size;
    g.NextWindowData.SizeCond = cond ? cond : HanaLovesMeCond_Always;
}

void HanaLovesMe::SetNextWindowSizeConstraints(const vsize & size_min, const vsize & size_max, HanaLovesMeSizeCallback custom_callback, void* custom_callback_user_data)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.NextWindowData.SizeConstraintCond = HanaLovesMeCond_Always;
    g.NextWindowData.SizeConstraintRect = vsrect(size_min, size_max);
    g.NextWindowData.SizeCallback = custom_callback;
    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}

void HanaLovesMe::SetNextWindowContentSize(const vsize & size)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.NextWindowData.ContentSizeVal = size;  // In Begin() we will add the size of window decorations (title bar, menu etc.) to that to form a SizeContents value.
    g.NextWindowData.ContentSizeCond = HanaLovesMeCond_Always;
}

void HanaLovesMe::SetNextWindowCollapsed(bool collapsed, HanaLovesMeCond cond)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.CollapsedVal = collapsed;
    g.NextWindowData.CollapsedCond = cond ? cond : HanaLovesMeCond_Always;
}

void HanaLovesMe::SetNextWindowFocus()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.NextWindowData.FocusCond = HanaLovesMeCond_Always;   // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

void HanaLovesMe::SetNextWindowBgAlpha(float alpha)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.NextWindowData.BgAlphaVal = alpha;
    g.NextWindowData.BgAlphaCond = HanaLovesMeCond_Always; // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

// FIXME: This is in window space (not screen space!)
vsize HanaLovesMe::GetContentRegionMax()
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    vsize mx = window->ContentsRegionRect.Max - window->Pos;
    if (window->DC.CurrentColumns)
        mx.x = GetColumnOffset(window->DC.CurrentColumns->Current + 1) - window->WindowPadding.x;
    return mx;
}

// [Internal] Absolute coordinate. Saner. This is not exposed until we finishing refactoring work rect features.
vsize HanaLovesMe::GetContentRegionMaxScreen()
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    vsize mx = window->ContentsRegionRect.Max;
    if (window->DC.CurrentColumns)
        mx.x = window->Pos.x + GetColumnOffset(window->DC.CurrentColumns->Current + 1) - window->WindowPadding.x;
    return mx;
}

vsize HanaLovesMe::GetContentRegionAvail()
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    return GetContentRegionMaxScreen() - window->DC.CursorPos;
}

float HanaLovesMe::GetContentRegionAvailWidth()
{
    return GetContentRegionAvail().x;
}

// In window space (not screen space!)
vsize HanaLovesMe::GetWindowContentRegionMin()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.Min - window->Pos;
}

vsize HanaLovesMe::GetWindowContentRegionMax()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.Max - window->Pos;
}

float HanaLovesMe::GetWindowContentRegionWidth()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->ContentsRegionRect.GetWidth();
}

float HanaLovesMe::GetTextLineHeight()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.FontSize;
}

float HanaLovesMe::GetTextLineHeightWithSpacing()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.FontSize + g.Style.ItemSpacing.y;
}

float HanaLovesMe::GetFrameHeight()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.FontSize + g.Style.FramePadding.y * 2.0f;
}

float HanaLovesMe::GetFrameHeightWithSpacing()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
}

ImDrawList* HanaLovesMe::GetWindowDrawList()
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    return window->DrawList;
}

ImFont* HanaLovesMe::GetFont()
{
    return GHanaLovesMe->Font;
}

float HanaLovesMe::GetFontSize()
{
    return GHanaLovesMe->FontSize;
}

vsize HanaLovesMe::GetFontTexUvWhitePixel()
{
    return GHanaLovesMe->DrawListSharedData.TexUvWhitePixel;
}

void HanaLovesMe::SetWindowFontScale(float scale)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->FontWindowScale = scale;
    g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
vsize HanaLovesMe::GetCursorPos()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos - window->Pos + window->Scroll;
}

float HanaLovesMe::GetCursorPosX()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
}

float HanaLovesMe::GetCursorPosY()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
}

void HanaLovesMe::SetCursorPos(const vsize & local_pos)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DC.CursorPos = window->Pos - window->Scroll + local_pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

void HanaLovesMe::SetCursorPosX(float x)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
    window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
}

void HanaLovesMe::SetCursorPosY(float y)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
    window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
}

vsize HanaLovesMe::GetCursorStartPos()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->DC.CursorStartPos - window->Pos;
}

vsize HanaLovesMe::GetCursorScreenPos()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->DC.CursorPos;
}

void HanaLovesMe::SetCursorScreenPos(const vsize & pos)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DC.CursorPos = pos;
    window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

float HanaLovesMe::GetScrollX()
{
    return GHanaLovesMe->CurrentWindow->Scroll.x;
}

float HanaLovesMe::GetScrollY()
{
    return GHanaLovesMe->CurrentWindow->Scroll.y;
}

float HanaLovesMe::GetScrollMaxX()
{
    return GetWindowScrollMaxX(GHanaLovesMe->CurrentWindow);
}

float HanaLovesMe::GetScrollMaxY()
{
    return GetWindowScrollMaxY(GHanaLovesMe->CurrentWindow);
}

void HanaLovesMe::SetScrollX(float scroll_x)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->ScrollTarget.x = scroll_x;
    window->ScrollTargetCenterRatio.x = 0.0f;
}

void HanaLovesMe::SetScrollY(float scroll_y)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->ScrollTarget.y = scroll_y + window->TitleBarHeight() + window->MenuBarHeight(); // title bar height canceled out when using ScrollTargetRelY
    window->ScrollTargetCenterRatio.y = 0.0f;
}

void HanaLovesMe::SetScrollFromPosY(float local_y, float center_y_ratio)
{
    // We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size
    HanaLovesMeWindow* window = GetCurrentWindow();
    IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
    window->ScrollTarget.y = (float)(int)(local_y + window->Scroll.y);
    window->ScrollTargetCenterRatio.y = center_y_ratio;
}

// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
void HanaLovesMe::SetScrollHereY(float center_y_ratio)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    float target_y = window->DC.CursorPosPrevLine.y - window->Pos.y; // Top of last item, in window space
    target_y += (window->DC.PrevLineSize.y * center_y_ratio) + (GHanaLovesMe->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.
    SetScrollFromPosY(target_y, center_y_ratio);
}

void HanaLovesMe::ActivateItem(HanaLovesMeID id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.NavNextActivateId = id;
}

void HanaLovesMe::SetKeyboardFocusHere(int offset)
{
    IM_ASSERT(offset >= -1);    // -1 is allowed but not below
    HanaLovesMeContext & g = *GHanaLovesMe;
    HanaLovesMeWindow * window = g.CurrentWindow;
    g.FocusRequestNextWindow = window;
    g.FocusRequestNextCounterAll = window->DC.FocusCounterAll + 1 + offset;
    g.FocusRequestNextCounterTab = INT_MAX;
}

void HanaLovesMe::SetItemDefaultFocus()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    if (!window->Appearing)
        return;
    if (g.NavWindow == window->RootWindowForNav && (g.NavInitRequest || g.NavInitResultId != 0) && g.NavLayer == g.NavWindow->DC.NavLayerCurrent)
    {
        g.NavInitRequest = false;
        g.NavInitResultId = g.NavWindow->DC.LastItemId;
        g.NavInitResultRectRel = vsrect(g.NavWindow->DC.LastItemRect.Min - g.NavWindow->Pos, g.NavWindow->DC.LastItemRect.Max - g.NavWindow->Pos);
        NavUpdateAnyRequestFlag();
        if (!IsItemVisible())
            SetScrollHereY();
    }
}

void HanaLovesMe::SetStateStohnly(HanaLovesMeStohnly * tree)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    window->DC.StateStohnly = tree ? tree : &window->StateStohnly;
}

HanaLovesMeStohnly* HanaLovesMe::GetStateStohnly()
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    return window->DC.StateStohnly;
}

void HanaLovesMe::PushID(const char* str_id)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id));
}

void HanaLovesMe::PushID(const char* str_id_begin, const char* str_id_end)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(str_id_begin, str_id_end));
}

void HanaLovesMe::PushID(const void* ptr_id)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));
}

void HanaLovesMe::PushID(int int_id)
{
    const void* ptr_id = (void*)(intptr_t)int_id;
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    window->IDStack.push_back(window->GetIDNoKeepAlive(ptr_id));
}

void HanaLovesMe::PopID()
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    window->IDStack.pop_back();
}

HanaLovesMeID HanaLovesMe::GetID(const char* str_id)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    return window->GetID(str_id);
}

HanaLovesMeID HanaLovesMe::GetID(const char* str_id_begin, const char* str_id_end)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    return window->GetID(str_id_begin, str_id_end);
}

HanaLovesMeID HanaLovesMe::GetID(const void* ptr_id)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    return window->GetID(ptr_id);
}

bool HanaLovesMe::IsRectVisible(const vsize & size)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    return window->ClipRect.Overlaps(vsrect(window->DC.CursorPos, window->DC.CursorPos + size));
}

bool HanaLovesMe::IsRectVisible(const vsize & rect_min, const vsize & rect_max)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    return window->ClipRect.Overlaps(vsrect(rect_min, rect_max));
}

// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
void HanaLovesMe::BeginGroup()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = GetCurrentWindow();

    window->DC.GroupStack.resize(window->DC.GroupStack.Size + 1);
    HanaLovesMeGroupData & group_data = window->DC.GroupStack.back();
    group_data.BackupCursorPos = window->DC.CursorPos;
    group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
    group_data.BackupIndent = window->DC.Indent;
    group_data.BackupGroupOffset = window->DC.GroupOffset;
    group_data.BackupCurrentLineSize = window->DC.CurrentLineSize;
    group_data.BackupCurrentLineTextBaseOffset = window->DC.CurrentLineTextBaseOffset;
    group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
    group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
    group_data.AdvanceCursor = true;

    window->DC.GroupOffset.x = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffset.x;
    window->DC.Indent = window->DC.GroupOffset;
    window->DC.CursorMaxPos = window->DC.CursorPos;
    window->DC.CurrentLineSize = vsize(0.0f, 0.0f);
    if (g.LogEnabled)
        g.LogLinePosY = -FLT_MAX; // To enforce Log carriage return
}

void HanaLovesMe::EndGroup()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = GetCurrentWindow();
    IM_ASSERT(!window->DC.GroupStack.empty());  // Mismatched BeginGroup()/EndGroup() calls

    HanaLovesMeGroupData& group_data = window->DC.GroupStack.back();

    vsrect group_bb(group_data.BackupCursorPos, window->DC.CursorMaxPos);
    group_bb.Max = ImMax(group_bb.Min, group_bb.Max);

    window->DC.CursorPos = group_data.BackupCursorPos;
    window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);
    window->DC.Indent = group_data.BackupIndent;
    window->DC.GroupOffset = group_data.BackupGroupOffset;
    window->DC.CurrentLineSize = group_data.BackupCurrentLineSize;
    window->DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;
    if (g.LogEnabled)
        g.LogLinePosY = -FLT_MAX; // To enforce Log carriage return

    if (group_data.AdvanceCursor)
    {
        window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrentLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
        ItemSize(group_bb.GetSize(), 0.0f);
        ItemAdd(group_bb, 0);
    }

    // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
    // It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
    // (and if you grep for LastItemId you'll notice it is only used in that context.
    if ((group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId) // && g.ActiveIdWindow->RootWindow == window->RootWindow)
        window->DC.LastItemId = g.ActiveId;
    else if (!group_data.BackupActiveIdPreviousFrameIsAlive && g.ActiveIdPreviousFrameIsAlive) // && g.ActiveIdPreviousFrameWindow->RootWindow == window->RootWindow)
        window->DC.LastItemId = g.ActiveIdPreviousFrame;
    window->DC.LastItemRect = group_bb;

    window->DC.GroupStack.pop_back();

    //window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
}

// Gets back to previous line and continue with horizontal layout
//      offset_from_start_x == 0 : follow right after previous item
//      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
//      spacing_w < 0            : use default spacing if pos_x == 0, no spacing if pos_x != 0
//      spacing_w >= 0           : enforce spacing amount
void HanaLovesMe::SameLine(float offset_from_start_x, float spacing_w)
{
    HanaLovesMeWindow* window = GetCurrentWindow();

    if (window->SkipItems)
        return;

    HanaLovesMeContext& g = *GHanaLovesMe;

    if (offset_from_start_x != 0.0f) {

        if (spacing_w < 0.0f)
			spacing_w = 0.0f;

        window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + offset_from_start_x + spacing_w + window->DC.GroupOffset.x + window->DC.ColumnsOffset.x;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }
	else {

        if (spacing_w < 0.0f)
			spacing_w = g.Style.ItemSpacing.x;

        window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
        window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
    }

    window->DC.CurrentLineSize = window->DC.PrevLineSize;
    window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
}

void HanaLovesMe::Indent(float indent_w)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DC.Indent.x += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

void HanaLovesMe::Unindent(float indent_w)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = GetCurrentWindow();
    window->DC.Indent.x -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
    window->DC.CursorPos.x = window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x;
}

//-----------------------------------------------------------------------------
// [SECTION] TOOLTIPS
//-----------------------------------------------------------------------------

void HanaLovesMe::BeginTooltip()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.DragDropWithinSourceOrTarget)
    {
        // The default tooltip position is a little offset to give space to see the context menu (it's also clamped within the current viewport/monitor)
        // In the context of a dragging tooltip we try to reduce that offset and we enforce following the cursor.
        // Whatever we do we want to call SetNextWindowPos() to enforce a tooltip position and disable clipping the tooltip without our display area, like regular tooltip do.
        //vsize tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
        vsize tooltip_pos = g.IO.MousePos + vsize(16 * g.Style.MouseCursorScale, 8 * g.Style.MouseCursorScale);
        SetNextWindowPos(tooltip_pos);
        SetNextWindowBgAlpha(g.Style.Colors[HanaLovesMeCol_PopupBg].w * 0.60f);
        //PushStyleVar(HanaLovesMeStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
        BeginTooltipEx(0, true);
    } else
    {
        BeginTooltipEx(0, false);
    }
}

// Not exposed publicly as BeginTooltip() because bool parameters are evil. Let's see if other needs arise first.
void HanaLovesMe::BeginTooltipEx(HanaLovesMeWindowFlags extra_flags, bool override_previous_tooltip)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
	vsize tooltip_pos = g.IO.MousePos + vsize(0 * g.Style.MouseCursorScale, -18 * g.Style.MouseCursorScale);
	SetNextWindowPos(tooltip_pos);
	SetNextWindowBgAlpha(0.8f);
	g.Style.WindowRounding = 4.f;
	g.Style.WindowPadding = vsize(0, 0.5);
    char window_name[16];
    ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", g.TooltipOverrideCount);

	if (override_previous_tooltip) {

		if (HanaLovesMeWindow * window = FindWindowByName(window_name)) {

			if (window->Active) {

				// Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.			
				window->Hidden = true;
				window->HiddenFramesCanSkipItems = 1;
				ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", ++g.TooltipOverrideCount);
			}
		}
	}
            
    HanaLovesMeWindowFlags flags = HanaLovesMeWindowFlags_Tooltip | HanaLovesMeWindowFlags_NoInputs | HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoResize | HanaLovesMeWindowFlags_NoSavedSettings | HanaLovesMeWindowFlags_AlwaysAutoResize;
    Begin(window_name, NULL, flags | extra_flags);
	g.Style.WindowPadding = vsize(4, 4);
	g.Style.WindowRounding = 0.f;
}

void HanaLovesMe::EndTooltip()
{
    IM_ASSERT(GetCurrentWindowRead()->Flags & HanaLovesMeWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
    End();
}

void HanaLovesMe::SetTooltipV(const char* fmt, va_list args)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.DragDropWithinSourceOrTarget)
        BeginTooltip();
    else
        BeginTooltipEx(0, true);
    TextV(fmt, args);
    EndTooltip();
}

void HanaLovesMe::SetTooltip(const char* fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    SetTooltipV(fmt, args);
    va_end(args);
}

//-----------------------------------------------------------------------------
// [SECTION] POPUPS
//-----------------------------------------------------------------------------

bool HanaLovesMe::IsPopupOpen(HanaLovesMeID id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.OpenPopupStack.Size > g.BeginPopupStack.Size&& g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
}

bool HanaLovesMe::IsPopupOpen(const char* str_id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.OpenPopupStack.Size > g.BeginPopupStack.Size&& g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == g.CurrentWindow->GetID(str_id);
}

HanaLovesMeWindow* HanaLovesMe::GetFrontMostPopupModal()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
        if (HanaLovesMeWindow * popup = g.OpenPopupStack.Data[n].Window)
            if (popup->Flags & HanaLovesMeWindowFlags_Modal)
                return popup;
    return NULL;
}

void HanaLovesMe::OpenPopup(const char* str_id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    OpenPopupEx(g.CurrentWindow->GetID(str_id));
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of HanaLovesMePopupRef to NULL)
void HanaLovesMe::OpenPopupEx(HanaLovesMeID id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* parent_window = g.CurrentWindow;
    int current_stack_size = g.BeginPopupStack.Size;
    HanaLovesMePopupRef popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
    popup_ref.PopupId = id;
    popup_ref.Window = NULL;
    popup_ref.ParentWindow = parent_window;
    popup_ref.OpenFrameCount = g.FrameCount;
    popup_ref.OpenParentId = parent_window->IDStack.back();
    popup_ref.OpenPopupPos = NavCalcPreferredRefPos();
    popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;

    //HanaLovesMe_DEBUG_LOG("OpenPopupEx(0x%08X)\n", g.FrameCount, id);
    if (g.OpenPopupStack.Size < current_stack_size + 1)
    {
        g.OpenPopupStack.push_back(popup_ref);
    } else
    {
        // Gently handle the user mistakenly calling OpenPopup() every frame. It is a programming mistake! However, if we were to run the regular code path, the ui
        // would become completely unusable because the popup will always be in hidden-while-calculating-size state _while_ claiming focus. Which would be a very confusing
        // situation for the programmer. Instead, we silently allow the popup to proceed, it will keep reappearing and the programming error will be more obvious to understand.
        if (g.OpenPopupStack[current_stack_size].PopupId == id && g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)
        {
            g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
        } else
        {
            // Close child popups if any, then flag popup for open/reopen
            g.OpenPopupStack.resize(current_stack_size + 1);
            g.OpenPopupStack[current_stack_size] = popup_ref;
        }

        // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
        // This is equivalent to what ClosePopupToLevel() does.
        //if (g.OpenPopupStack[current_stack_size].PopupId == id)
        //    FocusWindow(parent_window);
    }
}

bool HanaLovesMe::OpenPopupOnItemClick(const char* str_id, int mouse_button)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    if (IsMouseReleased(mouse_button) && IsItemHovered(HanaLovesMeHoveredFlags_AllowWhenBlockedByPopup))
    {
        HanaLovesMeID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
        IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
        OpenPopupEx(id);
        return true;
    }
    return false;
}

void HanaLovesMe::ClosePopupsOverWindow(HanaLovesMeWindow * ref_window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.OpenPopupStack.empty())
        return;

    // When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
    // Don't close our own child popup windows.
    int popup_count_to_keep = 0;
    if (ref_window)
    {
        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
        for (; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep++)
        {
            HanaLovesMePopupRef& popup = g.OpenPopupStack[popup_count_to_keep];
            if (!popup.Window)
                continue;
            IM_ASSERT((popup.Window->Flags & HanaLovesMeWindowFlags_Popup) != 0);
            if (popup.Window->Flags & HanaLovesMeWindowFlags_ChildWindow)
                continue;

            // Trim the stack if popups are not direct descendant of the reference window (which is often the NavWindow)
            bool popup_or_descendent_has_focus = false;
            for (int m = popup_count_to_keep; m < g.OpenPopupStack.Size && !popup_or_descendent_has_focus; m++)
                if (g.OpenPopupStack[m].Window && g.OpenPopupStack[m].Window->RootWindow == ref_window->RootWindow)
                    popup_or_descendent_has_focus = true;
            if (!popup_or_descendent_has_focus)
                break;
        }
    }
    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
    {
        //HanaLovesMe_DEBUG_LOG("ClosePopupsOverWindow(%s) -> ClosePopupToLevel(%d)\n", ref_window->Name, popup_count_to_keep);
        ClosePopupToLevel(popup_count_to_keep, false);
    }
}

void HanaLovesMe::ClosePopupToLevel(int remaining, bool apply_focus_to_window_under)
{
    IM_ASSERT(remaining >= 0);
    HanaLovesMeContext & g = *GHanaLovesMe;
    HanaLovesMeWindow * focus_window = (remaining > 0) ? g.OpenPopupStack[remaining - 1].Window : g.OpenPopupStack[0].ParentWindow;
    g.OpenPopupStack.resize(remaining);

    // FIXME: This code is faulty and we may want to eventually to replace or remove the 'apply_focus_to_window_under=true' path completely.
    // Instead of using g.OpenPopupStack[remaining-1].Window etc. we should find the highest root window that is behind the popups we are closing.
    // The current code will set focus to the parent of the popup window which is incorrect.
    // It rarely manifested until now because UpdateMouseMovingWindowNewFrame() would call FocusWindow() again on the clicked window,
    // leading to a chain of focusing A (clicked window) then B (parent window of the popup) then A again.
    // However if the clicked window has the _NoMove flag set we would be left with B focused.
    // For now, we have disabled this path when called from ClosePopupsOverWindow() because the users of ClosePopupsOverWindow() don't need to alter focus anyway,
    // but we should inspect and fix this properly.
    if (apply_focus_to_window_under)
    {
        if (g.NavLayer == 0)
            focus_window = NavRestoreLastChildNavWindow(focus_window);
        FocusWindow(focus_window);
    }
}

// Close the popup we have begin-ed into.
void HanaLovesMe::CloseCurrentPopup()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    int popup_idx = g.BeginPopupStack.Size - 1;
    if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)
        return;

    // Closing a menu closes its top-most parent popup (unless a modal)
    while (popup_idx > 0)
    {
        HanaLovesMeWindow* popup_window = g.OpenPopupStack[popup_idx].Window;
        HanaLovesMeWindow* parent_popup_window = g.OpenPopupStack[popup_idx - 1].Window;
        bool close_parent = false;
        if (popup_window && (popup_window->Flags & HanaLovesMeWindowFlags_ChildMenu))
            if (parent_popup_window == NULL || !(parent_popup_window->Flags & HanaLovesMeWindowFlags_Modal))
                close_parent = true;
        if (!close_parent)
            break;
        popup_idx--;
    }
    //HanaLovesMe_DEBUG_LOG("CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx);
    ClosePopupToLevel(popup_idx, true);

    // A common pattern is to close a popup when selecting a menu item/selectable that will open another window.
    // To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.
    // Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.
    if (HanaLovesMeWindow * window = g.NavWindow)
        window->DC.NavHideHighlightOneFrame = true;
}

bool HanaLovesMe::BeginPopupEx(HanaLovesMeID id, HanaLovesMeWindowFlags extra_flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (!IsPopupOpen(id))
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }

    char name[20];
    if (extra_flags & HanaLovesMeWindowFlags_ChildMenu)
        ImFormatString(name, IM_ARRAYSIZE(name), "##Menu_%02d", g.BeginPopupStack.Size); // Recycle windows based on depth
    else
        ImFormatString(name, IM_ARRAYSIZE(name), "##Popup_%08x", id); // Not recycling, so we can close/open during the same frame

    bool is_open = BeginColorPickerBackground(name, NULL, extra_flags | HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_NoMove);
    if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)
        EndPopup();

    return is_open;
}

bool HanaLovesMe::BeginPopup(const char* str_id, HanaLovesMeWindowFlags flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) // Early out for performance
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }
    flags |= HanaLovesMeWindowFlags_AlwaysAutoResize | HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoSavedSettings;
    return BeginPopupEx(g.CurrentWindow->GetID(str_id), flags);
}

// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.
// Note that popup visibility status is owned by HanaLovesMe (and manipulated with e.g. OpenPopup) so the actual value of *p_open is meaningless here.
bool HanaLovesMe::BeginPopupModal(const char* name, bool* p_open, HanaLovesMeWindowFlags flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    const HanaLovesMeID id = window->GetID(name);
    if (!IsPopupOpen(id))
    {
        g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
        return false;
    }

    // Center modal windows by default
    // FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
    if (g.NextWindowData.PosCond == 0)
        SetNextWindowPos(g.IO.DisplaySize * 0.5f, HanaLovesMeCond_Appearing, vsize(0.5f, 0.5f));

    flags |= HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_Modal | HanaLovesMeWindowFlags_NoCollapse | HanaLovesMeWindowFlags_NoSavedSettings;
    const bool is_open = Begin(name, p_open, flags);
    if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    {
        EndPopup();
        if (is_open)
            ClosePopupToLevel(g.BeginPopupStack.Size, true);
        return false;
    }
    return is_open;
}

void HanaLovesMe::EndPopup()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(g.CurrentWindow->Flags & HanaLovesMeWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls
    IM_ASSERT(g.BeginPopupStack.Size > 0);

    // Make all menus and popups wrap around for now, may need to expose that policy.
    NavMoveRequestTryWrapping(g.CurrentWindow, HanaLovesMeNavMoveFlags_LoopY);

    End();
}

// This is a helper to handle the simplest case of associating one named popup to one given widget.
// You may want to handle this on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
// You can pass a NULL str_id to use the identifier of the last item.
bool HanaLovesMe::BeginPopupContextItem(const char* str_id, int mouse_button)
{
    HanaLovesMeWindow* window = GHanaLovesMe->CurrentWindow;
    HanaLovesMeID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
    IM_ASSERT(id != 0);                                                  // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
    if (IsMouseReleased(mouse_button) && IsItemHovered(HanaLovesMeHoveredFlags_AllowWhenBlockedByPopup))
        OpenPopupEx(id);
    return BeginPopupEx(id, HanaLovesMeWindowFlags_AlwaysAutoResize | HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoSavedSettings);
}

bool HanaLovesMe::BeginPopupContextWindow(const char* str_id, int mouse_button, bool also_over_items)
{
    if (!str_id)
        str_id = "window_context";
    HanaLovesMeID id = GHanaLovesMe->CurrentWindow->GetID(str_id);
    if (IsMouseReleased(mouse_button) && IsWindowHovered(HanaLovesMeHoveredFlags_AllowWhenBlockedByPopup))
        if (also_over_items || !IsAnyItemHovered())
            OpenPopupEx(id);
    return BeginPopupEx(id, HanaLovesMeWindowFlags_AlwaysAutoResize | HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoSavedSettings);
}

bool HanaLovesMe::BeginPopupContextVoid(const char* str_id, int mouse_button)
{
    if (!str_id)
        str_id = "void_context";
    HanaLovesMeID id = GHanaLovesMe->CurrentWindow->GetID(str_id);
    if (IsMouseReleased(mouse_button) && !IsWindowHovered(HanaLovesMeHoveredFlags_AnyWindow))
        OpenPopupEx(id);
    return BeginPopupEx(id, HanaLovesMeWindowFlags_AlwaysAutoResize | HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoSavedSettings);
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
vsize HanaLovesMe::FindBestWindowPosForPopupEx(const vsize & ref_pos, const vsize & size, HanaLovesMeDir * last_dir, const vsrect & r_outer, const vsrect & r_avoid, HanaLovesMePopupPositionPolicy policy)
{
    vsize base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);
    //GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
    //GetForegroundDrawList()->AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

    // Combo Box policy (we want a connecting edge)
    if (policy == HanaLovesMePopupPositionPolicy_ComboBox)
    {
        const HanaLovesMeDir dir_prefered_order[HanaLovesMeDir_COUNT] = { HanaLovesMeDir_Down, HanaLovesMeDir_Right, HanaLovesMeDir_Left, HanaLovesMeDir_Up };
        for (int n = (*last_dir != HanaLovesMeDir_None) ? -1 : 0; n < HanaLovesMeDir_COUNT; n++)
        {
            const HanaLovesMeDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
            if (n != -1 && dir == *last_dir) // Already tried this direction?
                continue;
            vsize pos;
            if (dir == HanaLovesMeDir_Down)  pos = vsize(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)
            if (dir == HanaLovesMeDir_Right) pos = vsize(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right
            if (dir == HanaLovesMeDir_Left)  pos = vsize(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left
            if (dir == HanaLovesMeDir_Up)    pos = vsize(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left
            if (!r_outer.Contains(vsrect(pos, pos + size)))
                continue;
            *last_dir = dir;
            return pos;
        }
    }

    // Default popup policy
    const HanaLovesMeDir dir_prefered_order[HanaLovesMeDir_COUNT] = { HanaLovesMeDir_Right, HanaLovesMeDir_Down, HanaLovesMeDir_Up, HanaLovesMeDir_Left };
    for (int n = (*last_dir != HanaLovesMeDir_None) ? -1 : 0; n < HanaLovesMeDir_COUNT; n++)
    {
        const HanaLovesMeDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
        if (n != -1 && dir == *last_dir) // Already tried this direction?
            continue;
        float avail_w = (dir == HanaLovesMeDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == HanaLovesMeDir_Right ? r_avoid.Max.x : r_outer.Min.x);
        float avail_h = (dir == HanaLovesMeDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == HanaLovesMeDir_Down ? r_avoid.Max.y : r_outer.Min.y);
        if (avail_w < size.x || avail_h < size.y)
            continue;
        vsize pos;
        pos.x = (dir == HanaLovesMeDir_Left) ? r_avoid.Min.x - size.x : (dir == HanaLovesMeDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;
        pos.y = (dir == HanaLovesMeDir_Up) ? r_avoid.Min.y - size.y : (dir == HanaLovesMeDir_Down) ? r_avoid.Max.y : base_pos_clamped.y;
        *last_dir = dir;
        return pos;
    }

    // Fallback, try to keep within display
    *last_dir = HanaLovesMeDir_None;
    vsize pos = ref_pos;
    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
    return pos;
}

vsrect HanaLovesMe::GetWindowAllowedExtentRect(HanaLovesMeWindow * window)
{
    IM_UNUSED(window);
    vsize padding = GHanaLovesMe->Style.DisplaySafeAreaPadding;
    vsrect r_screen = GetViewportRect();
    r_screen.Expand(vsize((r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0f, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0f));
    return r_screen;
}

vsize HanaLovesMe::FindBestWindowPosForPopup(HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    vsrect r_outer = GetWindowAllowedExtentRect(window);
    if (window->Flags & HanaLovesMeWindowFlags_ChildMenu)
    {
        // Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
        // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
        IM_ASSERT(g.CurrentWindow == window);
        HanaLovesMeWindow * parent_window = g.CurrentWindowStack[g.CurrentWindowStack.Size - 2];
        float horizontal_overlap = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
        vsrect r_avoid;
        if (parent_window->DC.MenuBarAppending)
            r_avoid = vsrect(-FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight(), FLT_MAX, parent_window->Pos.y + parent_window->TitleBarHeight() + parent_window->MenuBarHeight());
        else
            r_avoid = vsrect(parent_window->Pos.x + horizontal_overlap, -FLT_MAX, parent_window->Pos.x + parent_window->Size.x - horizontal_overlap - parent_window->ScrollbarSizes.x, FLT_MAX);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
    }
    if (window->Flags & HanaLovesMeWindowFlags_Popup)
    {
        vsrect r_avoid = vsrect(window->Pos.x - 1, window->Pos.y - 1, window->Pos.x + 1, window->Pos.y + 1);
        return FindBestWindowPosForPopupEx(window->Pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
    }
    if (window->Flags & HanaLovesMeWindowFlags_Tooltip)
    {
        // Position tooltip (always follows mouse)
        float sc = g.Style.MouseCursorScale;
        vsize ref_pos = NavCalcPreferredRefPos();
        vsrect r_avoid;
        if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & HanaLovesMeConfigFlags_NavEnableSetMousePos))
            r_avoid = vsrect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
        else
            r_avoid = vsrect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
        vsize pos = FindBestWindowPosForPopupEx(ref_pos, window->Size, &window->AutoPosLastDirection, r_outer, r_avoid);
        if (window->AutoPosLastDirection == HanaLovesMeDir_None)
            pos = ref_pos + vsize(2, 2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
        return pos;
    }
    IM_ASSERT(0);
    return window->Pos;
}


//-----------------------------------------------------------------------------
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
//-----------------------------------------------------------------------------

HanaLovesMeDir ImGetDirQuadrantFromDelta(float dx, float dy)
{
    if (ImFabs(dx) > ImFabs(dy))
        return (dx > 0.0f) ? HanaLovesMeDir_Right : HanaLovesMeDir_Left;
    return (dy > 0.0f) ? HanaLovesMeDir_Down : HanaLovesMeDir_Up;
}

static float inline NavScoreItemDistInterval(float a0, float a1, float b0, float b1)
{
    if (a1 < b0)
        return a1 - b0;
    if (b1 < a0)
        return a0 - b1;
    return 0.0f;
}

static void inline NavClampRectToVisibleAreaForMoveDir(HanaLovesMeDir move_dir, vsrect & r, const vsrect & clip_rect)
{
    if (move_dir == HanaLovesMeDir_Left || move_dir == HanaLovesMeDir_Right)
    {
        r.Min.y = ImClamp(r.Min.y, clip_rect.Min.y, clip_rect.Max.y);
        r.Max.y = ImClamp(r.Max.y, clip_rect.Min.y, clip_rect.Max.y);
    } else
    {
        r.Min.x = ImClamp(r.Min.x, clip_rect.Min.x, clip_rect.Max.x);
        r.Max.x = ImClamp(r.Max.x, clip_rect.Min.x, clip_rect.Max.x);
    }
}

// Scoring function for directional navigation. Based on https://gist.github.com/rygorous/6981057
static bool NavScoreItem(HanaLovesMeNavMoveResult * result, vsrect cand)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    if (g.NavLayer != window->DC.NavLayerCurrent)
        return false;

    const vsrect & curr = g.NavScoringRectScreen; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
    g.NavScoringCount++;

    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
    if (window->ParentWindow == g.NavWindow)
    {
        IM_ASSERT((window->Flags | g.NavWindow->Flags) & HanaLovesMeWindowFlags_NavFlattened);
        if (!window->ClipRect.Contains(cand))
            return false;
        cand.ClipWithFull(window->ClipRect); // This allows the scored item to not overlap other candidates in the parent window
    }

    // We perform scoring on items bounding box clipped by the current clipping rectangle on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
    // For example, this ensure that items in one column are not reached when moving vertically from items in another column.
    NavClampRectToVisibleAreaForMoveDir(g.NavMoveClipDir, cand, window->ClipRect);

    // Compute distance between boxes
    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
    float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
    float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
    if (dby != 0.0f && dbx != 0.0f)
        dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
    float dist_box = ImFabs(dbx) + ImFabs(dby);

    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
    float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
    float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
    float dist_center = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)

    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
    HanaLovesMeDir quadrant;
    float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
    if (dbx != 0.0f || dby != 0.0f)
    {
        // For non-overlapping boxes, use distance between boxes
        dax = dbx;
        day = dby;
        dist_axial = dist_box;
        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
    } else if (dcx != 0.0f || dcy != 0.0f)
    {
        // For overlapping boxes with different centers, use distance between centers
        dax = dcx;
        day = dcy;
        dist_axial = dist_center;
        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
    } else
    {
        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
        quadrant = (window->DC.LastItemId < g.NavId) ? HanaLovesMeDir_Left : HanaLovesMeDir_Right;
    }

#if HanaLovesMe_DEBUG_NAV_SCORING
    char buf[128];
    if (HanaLovesMe::IsMouseHoveringRect(cand.Min, cand.Max))
    {
        ImFormatString(buf, IM_ARRAYSIZE(buf), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[g.NavMoveDir], "WENS"[quadrant]);
        ImDrawList* draw_list = HanaLovesMe::GetForegroundDrawList(window);
        draw_list->AddRect(curr.Min, curr.Max, IM_COL32(255, 200, 0, 100));
        draw_list->AddRect(cand.Min, cand.Max, IM_COL32(255, 255, 0, 200));
        draw_list->AddRectFilled(cand.Max - vsize(4, 4), cand.Max + HanaLovesMe::CalcTextSize(buf) + vsize(4, 4), IM_COL32(40, 0, 0, 150));
        draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Max, ~0U, buf);
    } else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.
    {
        if (HanaLovesMe::IsKeyPressedMap(HanaLovesMeKey_C)) { g.NavMoveDirLast = (HanaLovesMeDir)((g.NavMoveDirLast + 1) & 3); g.IO.KeysDownDuration[g.IO.KeyMap[HanaLovesMeKey_C]] = 0.01f; }
        if (quadrant == g.NavMoveDir)
        {
            ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
            ImDrawList* draw_list = HanaLovesMe::GetForegroundDrawList(window);
            draw_list->AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));
            draw_list->AddText(g.IO.FontDefault, 13.0f, cand.Min, IM_COL32(255, 255, 255, 255), buf);
        }
    }
#endif

    // Is it in the quadrant we're interesting in moving to?
    bool new_best = false;
    if (quadrant == g.NavMoveDir)
    {
        // Does it beat the current best candidate?
        if (dist_box < result->DistBox)
        {
            result->DistBox = dist_box;
            result->DistCenter = dist_center;
            return true;
        }
        if (dist_box == result->DistBox)
        {
            // Try using distance between center points to break ties
            if (dist_center < result->DistCenter)
            {
                result->DistCenter = dist_center;
                new_best = true;
            } else if (dist_center == result->DistCenter)
            {
                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
                if (((g.NavMoveDir == HanaLovesMeDir_Up || g.NavMoveDir == HanaLovesMeDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
                    new_best = true;
            }
        }
    }

    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
    if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
        if (g.NavLayer == 1 && !(g.NavWindow->Flags & HanaLovesMeWindowFlags_ChildMenu))
            if ((g.NavMoveDir == HanaLovesMeDir_Left && dax < 0.0f) || (g.NavMoveDir == HanaLovesMeDir_Right && dax > 0.0f) || (g.NavMoveDir == HanaLovesMeDir_Up && day < 0.0f) || (g.NavMoveDir == HanaLovesMeDir_Down && day > 0.0f))
            {
                result->DistAxial = dist_axial;
                new_best = true;
            }

    return new_best;
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
static void HanaLovesMe::NavProcessItem(HanaLovesMeWindow * window, const vsrect & nav_bb, const HanaLovesMeID id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    //if (!g.IO.NavActive)  // [2017/10/06] Removed this possibly redundant test but I am not sure of all the side-effects yet. Some of the feature here will need to work regardless of using a _NoNavInputs flag.
    //    return;

    const HanaLovesMeItemFlags item_flags = window->DC.ItemFlags;
    const vsrect nav_bb_rel(nav_bb.Min - window->Pos, nav_bb.Max - window->Pos);

    // Process Init Request
    if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent)
    {
        // Even if 'HanaLovesMeItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
        if (!(item_flags & HanaLovesMeItemFlags_NoNavDefaultFocus) || g.NavInitResultId == 0)
        {
            g.NavInitResultId = id;
            g.NavInitResultRectRel = nav_bb_rel;
        }
        if (!(item_flags & HanaLovesMeItemFlags_NoNavDefaultFocus))
        {
            g.NavInitRequest = false; // Found a match, clear request
            NavUpdateAnyRequestFlag();
        }
    }

    // Process Move Request (scoring for navigation)
    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRectScreen + scoring from a rect wrapped according to current wrapping policy)
    if ((g.NavId != id || (g.NavMoveRequestFlags & HanaLovesMeNavMoveFlags_AllowCurrentNavId)) && !(item_flags & (HanaLovesMeItemFlags_Disabled | HanaLovesMeItemFlags_NoNav)))
    {
        HanaLovesMeNavMoveResult* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
#if HanaLovesMe_DEBUG_NAV_SCORING
        // [DEBUG] Score all items in NavWindow at all times
        if (!g.NavMoveRequest)
            g.NavMoveDir = g.NavMoveDirLast;
        bool new_best = NavScoreItem(result, nav_bb) && g.NavMoveRequest;
#else
        bool new_best = g.NavMoveRequest && NavScoreItem(result, nav_bb);
#endif
        if (new_best)
        {
            result->ID = id;
            result->SelectScopeId = g.MultiSelectScopeId;
            result->Window = window;
            result->RectRel = nav_bb_rel;
        }

        const float VISIBLE_RATIO = 0.70f;
        if ((g.NavMoveRequestFlags & HanaLovesMeNavMoveFlags_AlsoScoreVisibleSet) && window->ClipRect.Overlaps(nav_bb))
            if (ImClamp(nav_bb.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO)
                if (NavScoreItem(&g.NavMoveResultLocalVisibleSet, nav_bb))
                {
                    result = &g.NavMoveResultLocalVisibleSet;
                    result->ID = id;
                    result->SelectScopeId = g.MultiSelectScopeId;
                    result->Window = window;
                    result->RectRel = nav_bb_rel;
                }
    }

    // Update window-relative bounding box of navigated item
    if (g.NavId == id)
    {
        g.NavWindow = window;                                           // Always refresh g.NavWindow, because some operations such as FocusItem() don't have a window.
        g.NavLayer = window->DC.NavLayerCurrent;
        g.NavIdIsAlive = true;
        g.NavIdTabCounter = window->DC.FocusCounterTab;
        window->NavRectRel[window->DC.NavLayerCurrent] = nav_bb_rel;    // Store item bounding box (relative to window position)
    }
}

bool HanaLovesMe::NavMoveRequestButNoResultYet()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.NavMoveRequest&& g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
}

void HanaLovesMe::NavMoveRequestCancel()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.NavMoveRequest = false;
    NavUpdateAnyRequestFlag();
}

void HanaLovesMe::NavMoveRequestForward(HanaLovesMeDir move_dir, HanaLovesMeDir clip_dir, const vsrect & bb_rel, HanaLovesMeNavMoveFlags move_flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(g.NavMoveRequestForward == HanaLovesMeNavForward_None);
    HanaLovesMe::NavMoveRequestCancel();
    g.NavMoveDir = move_dir;
    g.NavMoveClipDir = clip_dir;
    g.NavMoveRequestForward = HanaLovesMeNavForward_ForwardQueued;
    g.NavMoveRequestFlags = move_flags;
    g.NavWindow->NavRectRel[g.NavLayer] = bb_rel;
}

void HanaLovesMe::NavMoveRequestTryWrapping(HanaLovesMeWindow * window, HanaLovesMeNavMoveFlags move_flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.NavWindow != window || !NavMoveRequestButNoResultYet() || g.NavMoveRequestForward != HanaLovesMeNavForward_None || g.NavLayer != 0)
        return;
    IM_ASSERT(move_flags != 0); // No points calling this with no wrapping
    vsrect bb_rel = window->NavRectRel[0];

    HanaLovesMeDir clip_dir = g.NavMoveDir;
    if (g.NavMoveDir == HanaLovesMeDir_Left && (move_flags & (HanaLovesMeNavMoveFlags_WrapX | HanaLovesMeNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = ImMax(window->SizeFull.x, window->SizeContents.x) - window->Scroll.x;
        if (move_flags & HanaLovesMeNavMoveFlags_WrapX) { bb_rel.TranslateY(-bb_rel.GetHeight()); clip_dir = HanaLovesMeDir_Up; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == HanaLovesMeDir_Right && (move_flags & (HanaLovesMeNavMoveFlags_WrapX | HanaLovesMeNavMoveFlags_LoopX)))
    {
        bb_rel.Min.x = bb_rel.Max.x = -window->Scroll.x;
        if (move_flags & HanaLovesMeNavMoveFlags_WrapX) { bb_rel.TranslateY(+bb_rel.GetHeight()); clip_dir = HanaLovesMeDir_Down; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == HanaLovesMeDir_Up && (move_flags & (HanaLovesMeNavMoveFlags_WrapY | HanaLovesMeNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = ImMax(window->SizeFull.y, window->SizeContents.y) - window->Scroll.y;
        if (move_flags & HanaLovesMeNavMoveFlags_WrapY) { bb_rel.TranslateX(-bb_rel.GetWidth()); clip_dir = HanaLovesMeDir_Left; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
    if (g.NavMoveDir == HanaLovesMeDir_Down && (move_flags & (HanaLovesMeNavMoveFlags_WrapY | HanaLovesMeNavMoveFlags_LoopY)))
    {
        bb_rel.Min.y = bb_rel.Max.y = -window->Scroll.y;
        if (move_flags & HanaLovesMeNavMoveFlags_WrapY) { bb_rel.TranslateX(+bb_rel.GetWidth()); clip_dir = HanaLovesMeDir_Right; }
        NavMoveRequestForward(g.NavMoveDir, clip_dir, bb_rel, move_flags);
    }
}

// FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).
// This way we could find the last focused window among our children. It would be much less confusing this way?
static void HanaLovesMe::NavSaveLastChildNavWindowIntoParent(HanaLovesMeWindow * nav_window)
{
    HanaLovesMeWindow* parent_window = nav_window;
    while (parent_window && (parent_window->Flags & HanaLovesMeWindowFlags_ChildWindow) != 0 && (parent_window->Flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_ChildMenu)) == 0)
        parent_window = parent_window->ParentWindow;
    if (parent_window && parent_window != nav_window)
        parent_window->NavLastChildNavWindow = nav_window;
}

// Restore the last focused child.
// Call when we are expected to land on the Main Layer (0) after FocusWindow()
static HanaLovesMeWindow * HanaLovesMe::NavRestoreLastChildNavWindow(HanaLovesMeWindow * window)
{
    return window->NavLastChildNavWindow ? window->NavLastChildNavWindow : window;
}

static void NavRestoreLayer(HanaLovesMeNavLayer layer)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.NavLayer = layer;
    if (layer == 0)
        g.NavWindow = HanaLovesMe::NavRestoreLastChildNavWindow(g.NavWindow);
    if (layer == 0 && g.NavWindow->NavLastIds[0] != 0)
        HanaLovesMe::SetNavIDWithRectRel(g.NavWindow->NavLastIds[0], layer, g.NavWindow->NavRectRel[0]);
    else
        HanaLovesMe::NavInitWindow(g.NavWindow, true);
}

static inline void HanaLovesMe::NavUpdateAnyRequestFlag()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest || (HanaLovesMe_DEBUG_NAV_SCORING && g.NavWindow != NULL);
    if (g.NavAnyRequest)
        IM_ASSERT(g.NavWindow != NULL);
}

// This needs to be called before we submit any widget (aka in or before Begin)
void HanaLovesMe::NavInitWindow(HanaLovesMeWindow * window, bool force_reinit)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(window == g.NavWindow);
    bool init_for_nav = false;
    if (!(window->Flags & HanaLovesMeWindowFlags_NoNavInputs))
        if (!(window->Flags & HanaLovesMeWindowFlags_ChildWindow) || (window->Flags & HanaLovesMeWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
            init_for_nav = true;
    if (init_for_nav)
    {
        SetNavID(0, g.NavLayer);
        g.NavInitRequest = true;
        g.NavInitRequestFromMove = false;
        g.NavInitResultId = 0;
        g.NavInitResultRectRel = vsrect();
        NavUpdateAnyRequestFlag();
    } else
    {
        g.NavId = window->NavLastIds[0];
    }
}

static vsize HanaLovesMe::NavCalcPreferredRefPos()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.NavDisableHighlight || !g.NavDisableMouseHover || !g.NavWindow)
    {
        // Mouse (we need a fallback in case the mouse becomes invalid after being used)
        if (IsMousePosValid(&g.IO.MousePos))
            return g.IO.MousePos;
        return g.LastValidMousePos;
    } else
    {
        // When navigation is active and mouse is disabled, decide on an arbitrary position around the bottom left of the currently navigated item.
        const vsrect& rect_rel = g.NavWindow->NavRectRel[g.NavLayer];
        vsize pos = g.NavWindow->Pos + vsize(rect_rel.Min.x + ImMin(g.Style.FramePadding.x * 4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));
        vsrect visible_rect = GetViewportRect();
        return ImFloor(ImClamp(pos, visible_rect.Min, visible_rect.Max));   // ImFloor() is important because non-integer mouse position application in back-end might be lossy and result in undesirable non-zero delta.
    }
}

float HanaLovesMe::GetNavInputAmount(HanaLovesMeNavInput n, HanaLovesMeInputReadMode mode)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (mode == HanaLovesMeInputReadMode_Down)
        return g.IO.NavInputs[n];                         // Instant, read analog input (0.0f..1.0f, as provided by user)

    const float t = g.IO.NavInputsDownDuration[n];
    if (t < 0.0f && mode == HanaLovesMeInputReadMode_Released)  // Return 1.0f when just released, no repeat, ignore analog input.
        return (g.IO.NavInputsDownDurationPrev[n] >= 0.0f ? 1.0f : 0.0f);
    if (t < 0.0f)
        return 0.0f;
    if (mode == HanaLovesMeInputReadMode_Pressed)               // Return 1.0f when just pressed, no repeat, ignore analog input.
        return (t == 0.0f) ? 1.0f : 0.0f;
    if (mode == HanaLovesMeInputReadMode_Repeat)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.80f);
    if (mode == HanaLovesMeInputReadMode_RepeatSlow)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 1.00f, g.IO.KeyRepeatRate * 2.00f);
    if (mode == HanaLovesMeInputReadMode_RepeatFast)
        return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.30f);
    return 0.0f;
}

vsize HanaLovesMe::GetNavInputAmount2d(HanaLovesMeNavDirSourceFlags dir_sources, HanaLovesMeInputReadMode mode, float slow_factor, float fast_factor)
{
    vsize delta(0.0f, 0.0f);
    if (dir_sources & HanaLovesMeNavDirSourceFlags_Keyboard)
        delta += vsize(GetNavInputAmount(HanaLovesMeNavInput_KeyRight_, mode) - GetNavInputAmount(HanaLovesMeNavInput_KeyLeft_, mode), GetNavInputAmount(HanaLovesMeNavInput_KeyDown_, mode) - GetNavInputAmount(HanaLovesMeNavInput_KeyUp_, mode));
    if (dir_sources & HanaLovesMeNavDirSourceFlags_PadDPad)
        delta += vsize(GetNavInputAmount(HanaLovesMeNavInput_DpadRight, mode) - GetNavInputAmount(HanaLovesMeNavInput_DpadLeft, mode), GetNavInputAmount(HanaLovesMeNavInput_DpadDown, mode) - GetNavInputAmount(HanaLovesMeNavInput_DpadUp, mode));
    if (dir_sources & HanaLovesMeNavDirSourceFlags_PadLStick)
        delta += vsize(GetNavInputAmount(HanaLovesMeNavInput_LStickRight, mode) - GetNavInputAmount(HanaLovesMeNavInput_LStickLeft, mode), GetNavInputAmount(HanaLovesMeNavInput_LStickDown, mode) - GetNavInputAmount(HanaLovesMeNavInput_LStickUp, mode));
    if (slow_factor != 0.0f && IsNavInputDown(HanaLovesMeNavInput_TweakSlow))
        delta *= slow_factor;
    if (fast_factor != 0.0f && IsNavInputDown(HanaLovesMeNavInput_TweakFast))
        delta *= fast_factor;
    return delta;
}

// Scroll to keep newly navigated item fully into view
// NB: We modify rect_rel by the amount we scrolled for, so it is immediately updated.
static void NavScrollToBringItemIntoView(HanaLovesMeWindow * window, const vsrect & item_rect)
{
    vsrect window_rect(window->InnerMainRect.Min - vsize(1, 1), window->InnerMainRect.Max + vsize(1, 1));
    //GetForegroundDrawList(window)->AddRect(window_rect.Min, window_rect.Max, IM_COL32_WHITE); // [DEBUG]
    if (window_rect.Contains(item_rect))
        return;

    HanaLovesMeContext & g = *GHanaLovesMe;
    if (window->ScrollbarX && item_rect.Min.x < window_rect.Min.x)
    {
        window->ScrollTarget.x = item_rect.Min.x - window->Pos.x + window->Scroll.x - g.Style.ItemSpacing.x;
        window->ScrollTargetCenterRatio.x = 0.0f;
    } else if (window->ScrollbarX && item_rect.Max.x >= window_rect.Max.x)
    {
        window->ScrollTarget.x = item_rect.Max.x - window->Pos.x + window->Scroll.x + g.Style.ItemSpacing.x;
        window->ScrollTargetCenterRatio.x = 1.0f;
    }
    if (item_rect.Min.y < window_rect.Min.y)
    {
        window->ScrollTarget.y = item_rect.Min.y - window->Pos.y + window->Scroll.y - g.Style.ItemSpacing.y;
        window->ScrollTargetCenterRatio.y = 0.0f;
    } else if (item_rect.Max.y >= window_rect.Max.y)
    {
        window->ScrollTarget.y = item_rect.Max.y - window->Pos.y + window->Scroll.y + g.Style.ItemSpacing.y;
        window->ScrollTargetCenterRatio.y = 1.0f;
    }
}

static void HanaLovesMe::NavUpdate()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.IO.WantSetMousePos = false;
#if 0
    if (g.NavScoringCount > 0) HanaLovesMe_DEBUG_LOG("NavScoringCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.FrameCount, g.NavScoringCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
#endif

    // Set input source as Gamepad when buttons are pressed before we map Keyboard (some features differs when used with Gamepad vs Keyboard)
    bool nav_keyboard_active = (g.IO.ConfigFlags & HanaLovesMeConfigFlags_NavEnableKeyboard) != 0;
    bool nav_gamepad_active = (g.IO.ConfigFlags & HanaLovesMeConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & HanaLovesMeBackendFlags_HasGamepad) != 0;
    if (nav_gamepad_active)
        if (g.IO.NavInputs[HanaLovesMeNavInput_Activate] > 0.0f || g.IO.NavInputs[HanaLovesMeNavInput_Input] > 0.0f || g.IO.NavInputs[HanaLovesMeNavInput_Cancel] > 0.0f || g.IO.NavInputs[HanaLovesMeNavInput_Menu] > 0.0f)
            g.NavInputSource = HanaLovesMeInputSource_NavGamepad;

    // Update Keyboard->Nav inputs mapping
    if (nav_keyboard_active)
    {
#define NAV_MAP_KEY(_KEY, _NAV_INPUT) if (IsKeyDown(g.IO.KeyMap[_KEY])) { g.IO.NavInputs[_NAV_INPUT] = 1.0f; g.NavInputSource = HanaLovesMeInputSource_NavKeyboard; }
        NAV_MAP_KEY(HanaLovesMeKey_Space, HanaLovesMeNavInput_Activate);
        NAV_MAP_KEY(HanaLovesMeKey_Enter, HanaLovesMeNavInput_Input);
        NAV_MAP_KEY(HanaLovesMeKey_Escape, HanaLovesMeNavInput_Cancel);
        NAV_MAP_KEY(HanaLovesMeKey_LeftArrow, HanaLovesMeNavInput_KeyLeft_);
        NAV_MAP_KEY(HanaLovesMeKey_RightArrow, HanaLovesMeNavInput_KeyRight_);
        NAV_MAP_KEY(HanaLovesMeKey_UpArrow, HanaLovesMeNavInput_KeyUp_);
        NAV_MAP_KEY(HanaLovesMeKey_DownArrow, HanaLovesMeNavInput_KeyDown_);
        NAV_MAP_KEY(HanaLovesMeKey_Tab, HanaLovesMeNavInput_KeyTab_);
        if (g.IO.KeyCtrl)
            g.IO.NavInputs[HanaLovesMeNavInput_TweakSlow] = 1.0f;
        if (g.IO.KeyShift)
            g.IO.NavInputs[HanaLovesMeNavInput_TweakFast] = 1.0f;
        if (g.IO.KeyAlt && !g.IO.KeyCtrl) // AltGR is Alt+Ctrl, also even on keyboards without AltGR we don't want Alt+Ctrl to open menu.
            g.IO.NavInputs[HanaLovesMeNavInput_KeyMenu_] = 1.0f;
#undef NAV_MAP_KEY
    }
    memcpy(g.IO.NavInputsDownDurationPrev, g.IO.NavInputsDownDuration, sizeof(g.IO.NavInputsDownDuration));
    for (int i = 0; i < IM_ARRAYSIZE(g.IO.NavInputs); i++)
        g.IO.NavInputsDownDuration[i] = (g.IO.NavInputs[i] > 0.0f) ? (g.IO.NavInputsDownDuration[i] < 0.0f ? 0.0f : g.IO.NavInputsDownDuration[i] + g.IO.DeltaTime) : -1.0f;

    // Process navigation init request (select first/default focus)
    if (g.NavInitResultId != 0 && (!g.NavDisableHighlight || g.NavInitRequestFromMove))
    {
        // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
        IM_ASSERT(g.NavWindow);
        if (g.NavInitRequestFromMove)
            SetNavIDWithRectRel(g.NavInitResultId, g.NavLayer, g.NavInitResultRectRel);
        else
            SetNavID(g.NavInitResultId, g.NavLayer);
        g.NavWindow->NavRectRel[g.NavLayer] = g.NavInitResultRectRel;
    }
    g.NavInitRequest = false;
    g.NavInitRequestFromMove = false;
    g.NavInitResultId = 0;
    g.NavJustMovedToId = 0;

    // Process navigation move request
    if (g.NavMoveRequest)
        NavUpdateMoveResult();

    // When a forwarded move request failed, we restore the highlight that we disabled during the forward frame
    if (g.NavMoveRequestForward == HanaLovesMeNavForward_ForwardActive)
    {
        IM_ASSERT(g.NavMoveRequest);
        if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
            g.NavDisableHighlight = false;
        g.NavMoveRequestForward = HanaLovesMeNavForward_None;
    }

    // Apply application mouse position movement, after we had a chance to process move request result.
    if (g.NavMousePosDirty && g.NavIdIsAlive)
    {
        // Set mouse position given our knowledge of the navigated item position from last frame
        if ((g.IO.ConfigFlags & HanaLovesMeConfigFlags_NavEnableSetMousePos) && (g.IO.BackendFlags & HanaLovesMeBackendFlags_HasSetMousePos))
        {
            if (!g.NavDisableHighlight && g.NavDisableMouseHover && g.NavWindow)
            {
                g.IO.MousePos = g.IO.MousePosPrev = NavCalcPreferredRefPos();
                g.IO.WantSetMousePos = true;
            }
        }
        g.NavMousePosDirty = false;
    }
    g.NavIdIsAlive = false;
    g.NavJustTabbedId = 0;
    IM_ASSERT(g.NavLayer == 0 || g.NavLayer == 1);

    // Store our return window (for returning from Layer 1 to Layer 0) and clear it as soon as we step back in our own Layer 0
    if (g.NavWindow)
        NavSaveLastChildNavWindowIntoParent(g.NavWindow);
    if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == 0)
        g.NavWindow->NavLastChildNavWindow = NULL;

    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
    NavUpdateWindowing();

    // Set output flags for user application
    g.IO.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & HanaLovesMeWindowFlags_NoNavInputs);
    g.IO.NavVisible = (g.IO.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL);

    // Process NavCancel input (to close a popup, get back to parent, clear focus)
    if (IsNavInputPressed(HanaLovesMeNavInput_Cancel, HanaLovesMeInputReadMode_Pressed))
    {
        if (g.ActiveId != 0)
        {
            if (!(g.ActiveIdBlockNavInputFlags & (1 << HanaLovesMeNavInput_Cancel)))
                ClearActiveID();
        } else if (g.NavWindow && (g.NavWindow->Flags & HanaLovesMeWindowFlags_ChildWindow) && !(g.NavWindow->Flags & HanaLovesMeWindowFlags_Popup) && g.NavWindow->ParentWindow)
        {
            // Exit child window
            HanaLovesMeWindow* child_window = g.NavWindow;
            HanaLovesMeWindow* parent_window = g.NavWindow->ParentWindow;
            IM_ASSERT(child_window->ChildId != 0);
            FocusWindow(parent_window);
            SetNavID(child_window->ChildId, 0);
            g.NavIdIsAlive = false;
            if (g.NavDisableMouseHover)
                g.NavMousePosDirty = true;
        } else if (g.OpenPopupStack.Size > 0)
        {
            // Close open popup/menu
            if (!(g.OpenPopupStack.back().Window->Flags & HanaLovesMeWindowFlags_Modal))
                ClosePopupToLevel(g.OpenPopupStack.Size - 1, true);
        } else if (g.NavLayer != 0)
        {
            // Leave the "menu" layer
            NavRestoreLayer(HanaLovesMeNavLayer_Main);
        } else
        {
            // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
            if (g.NavWindow && ((g.NavWindow->Flags & HanaLovesMeWindowFlags_Popup) || !(g.NavWindow->Flags & HanaLovesMeWindowFlags_ChildWindow)))
                g.NavWindow->NavLastIds[0] = 0;
            g.NavId = 0;
        }
    }

    // Process manual activation request
    g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = 0;
    if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & HanaLovesMeWindowFlags_NoNavInputs))
    {
        bool activate_down = IsNavInputDown(HanaLovesMeNavInput_Activate);
        bool activate_pressed = activate_down && IsNavInputPressed(HanaLovesMeNavInput_Activate, HanaLovesMeInputReadMode_Pressed);
        if (g.ActiveId == 0 && activate_pressed)
            g.NavActivateId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)
            g.NavActivateDownId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)
            g.NavActivatePressedId = g.NavId;
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && IsNavInputPressed(HanaLovesMeNavInput_Input, HanaLovesMeInputReadMode_Pressed))
            g.NavInputId = g.NavId;
    }
    if (g.NavWindow && (g.NavWindow->Flags & HanaLovesMeWindowFlags_NoNavInputs))
        g.NavDisableHighlight = true;
    if (g.NavActivateId != 0)
        IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
    g.NavMoveRequest = false;

    // Process programmatic activation request
    if (g.NavNextActivateId != 0)
        g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;
    g.NavNextActivateId = 0;

    // Initiate directional inputs request
    const int allowed_dir_flags = (g.ActiveId == 0) ? ~0 : g.ActiveIdAllowNavDirFlags;
    if (g.NavMoveRequestForward == HanaLovesMeNavForward_None)
    {
        g.NavMoveDir = HanaLovesMeDir_None;
        g.NavMoveRequestFlags = HanaLovesMeNavMoveFlags_None;
        if (g.NavWindow && !g.NavWindowingTarget && allowed_dir_flags && !(g.NavWindow->Flags & HanaLovesMeWindowFlags_NoNavInputs))
        {
            if ((allowed_dir_flags & (1 << HanaLovesMeDir_Left)) && IsNavInputPressedAnyOfTwo(HanaLovesMeNavInput_DpadLeft, HanaLovesMeNavInput_KeyLeft_, HanaLovesMeInputReadMode_Repeat)) g.NavMoveDir = HanaLovesMeDir_Left;
            if ((allowed_dir_flags & (1 << HanaLovesMeDir_Right)) && IsNavInputPressedAnyOfTwo(HanaLovesMeNavInput_DpadRight, HanaLovesMeNavInput_KeyRight_, HanaLovesMeInputReadMode_Repeat)) g.NavMoveDir = HanaLovesMeDir_Right;
            if ((allowed_dir_flags & (1 << HanaLovesMeDir_Up)) && IsNavInputPressedAnyOfTwo(HanaLovesMeNavInput_DpadUp, HanaLovesMeNavInput_KeyUp_, HanaLovesMeInputReadMode_Repeat)) g.NavMoveDir = HanaLovesMeDir_Up;
            if ((allowed_dir_flags & (1 << HanaLovesMeDir_Down)) && IsNavInputPressedAnyOfTwo(HanaLovesMeNavInput_DpadDown, HanaLovesMeNavInput_KeyDown_, HanaLovesMeInputReadMode_Repeat)) g.NavMoveDir = HanaLovesMeDir_Down;
        }
        g.NavMoveClipDir = g.NavMoveDir;
    } else
    {
        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
        // (Preserve g.NavMoveRequestFlags, g.NavMoveClipDir which were set by the NavMoveRequestForward() function)
        IM_ASSERT(g.NavMoveDir != HanaLovesMeDir_None && g.NavMoveClipDir != HanaLovesMeDir_None);
        IM_ASSERT(g.NavMoveRequestForward == HanaLovesMeNavForward_ForwardQueued);
        g.NavMoveRequestForward = HanaLovesMeNavForward_ForwardActive;
    }

    // Update PageUp/PageDown scroll
    float nav_scoring_rect_offset_y = 0.0f;
    if (nav_keyboard_active)
        nav_scoring_rect_offset_y = NavUpdatePageUpPageDown(allowed_dir_flags);

    // If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match
    if (g.NavMoveDir != HanaLovesMeDir_None)
    {
        g.NavMoveRequest = true;
        g.NavMoveDirLast = g.NavMoveDir;
    }
    if (g.NavMoveRequest && g.NavId == 0)
    {
        g.NavInitRequest = g.NavInitRequestFromMove = true;
        g.NavInitResultId = 0;
        g.NavDisableHighlight = false;
    }
    NavUpdateAnyRequestFlag();

    // Scrolling
    if (g.NavWindow && !(g.NavWindow->Flags & HanaLovesMeWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
    {
        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
        HanaLovesMeWindow* window = g.NavWindow;
        const float scroll_speed = ImFloor(window->CalcFontSize() * 100 * g.IO.DeltaTime + 0.5f); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
        if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll && g.NavMoveRequest)
        {
            if (g.NavMoveDir == HanaLovesMeDir_Left || g.NavMoveDir == HanaLovesMeDir_Right)
                SetWindowScrollX(window, ImFloor(window->Scroll.x + ((g.NavMoveDir == HanaLovesMeDir_Left) ? -1.0f : +1.0f) * scroll_speed));
            if (g.NavMoveDir == HanaLovesMeDir_Up || g.NavMoveDir == HanaLovesMeDir_Down)
                SetWindowScrollY(window, ImFloor(window->Scroll.y + ((g.NavMoveDir == HanaLovesMeDir_Up) ? -1.0f : +1.0f) * scroll_speed));
        }

        // *Normal* Manual scroll with NavScrollXXX keys
        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
        vsize scroll_dir = GetNavInputAmount2d(HanaLovesMeNavDirSourceFlags_PadLStick, HanaLovesMeInputReadMode_Down, 1.0f / 10.0f, 10.0f);
        if (scroll_dir.x != 0.0f && window->ScrollbarX)
        {
            SetWindowScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed));
            g.NavMoveFromClampedRefRect = true;
        }
        if (scroll_dir.y != 0.0f)
        {
            SetWindowScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed));
            g.NavMoveFromClampedRefRect = true;
        }
    }

    // Reset search results
    g.NavMoveResultLocal.Clear();
    g.NavMoveResultLocalVisibleSet.Clear();
    g.NavMoveResultOther.Clear();

    // When we have manually scrolled (without using navigation) and NavId becomes out of bounds, we project its bounding box to the visible area to restart navigation within visible items
    if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)
    {
        HanaLovesMeWindow* window = g.NavWindow;
        vsrect window_rect_rel(window->InnerMainRect.Min - window->Pos - vsize(1, 1), window->InnerMainRect.Max - window->Pos + vsize(1, 1));
        if (!window_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
        {
            float pad = window->CalcFontSize() * 0.5f;
            window_rect_rel.Expand(vsize(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intent of starting navigation from first fully visible item
            window->NavRectRel[g.NavLayer].ClipWith(window_rect_rel);
            g.NavId = 0;
        }
        g.NavMoveFromClampedRefRect = false;
    }

    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
    vsrect nav_rect_rel = (g.NavWindow && !g.NavWindow->NavRectRel[g.NavLayer].IsInverted()) ? g.NavWindow->NavRectRel[g.NavLayer] : vsrect(0, 0, 0, 0);
    g.NavScoringRectScreen = g.NavWindow ? vsrect(g.NavWindow->Pos + nav_rect_rel.Min, g.NavWindow->Pos + nav_rect_rel.Max) : GetViewportRect();
    g.NavScoringRectScreen.TranslateY(nav_scoring_rect_offset_y);
    g.NavScoringRectScreen.Min.x = ImMin(g.NavScoringRectScreen.Min.x + 1.0f, g.NavScoringRectScreen.Max.x);
    g.NavScoringRectScreen.Max.x = g.NavScoringRectScreen.Min.x;
    IM_ASSERT(!g.NavScoringRectScreen.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allows us to remove extraneous ImFabs() calls in NavScoreItem().
    //GetForegroundDrawList()->AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]
    g.NavScoringCount = 0;
#if HanaLovesMe_DEBUG_NAV_RECTS
    if (g.NavWindow)
    {
        ImDrawList* draw_list = GetForegroundDrawList(g.NavWindow);
        if (1) { for (int layer = 0; layer < 2; layer++) draw_list->AddRect(g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Min, g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
        if (1) { ImU32 col = (!g.NavWindow->Hidden) ? IM_COL32(255, 0, 255, 255) : IM_COL32(255, 0, 0, 255); vsize p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + vsize(8, -4), col, buf); }
    }
#endif
}

// Apply result from previous frame navigation directional move request
static void HanaLovesMe::NavUpdateMoveResult()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
    {
        // In a situation when there is no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
        if (g.NavId != 0)
        {
            g.NavDisableHighlight = false;
            g.NavDisableMouseHover = true;
        }
        return;
    }

    // Select which result to use
    HanaLovesMeNavMoveResult* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;

    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
    if (g.NavMoveRequestFlags & HanaLovesMeNavMoveFlags_AlsoScoreVisibleSet)
        if (g.NavMoveResultLocalVisibleSet.ID != 0 && g.NavMoveResultLocalVisibleSet.ID != g.NavId)
            result = &g.NavMoveResultLocalVisibleSet;

    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow)
        if ((g.NavMoveResultOther.DistBox < result->DistBox) || (g.NavMoveResultOther.DistBox == result->DistBox && g.NavMoveResultOther.DistCenter < result->DistCenter))
            result = &g.NavMoveResultOther;
    IM_ASSERT(g.NavWindow && result->Window);

    // Scroll to keep newly navigated item fully into view.
    if (g.NavLayer == 0)
    {
        vsrect rect_abs = vsrect(result->RectRel.Min + result->Window->Pos, result->RectRel.Max + result->Window->Pos);
        NavScrollToBringItemIntoView(result->Window, rect_abs);

        // Estimate upcoming scroll so we can offset our result position so mouse position can be applied immediately after in NavUpdate()
        vsize next_scroll = CalcNextScrollFromScrollTargetAndClamp(result->Window, false);
        vsize delta_scroll = result->Window->Scroll - next_scroll;
        result->RectRel.Translate(delta_scroll);

        // Also scroll parent window to keep us into view if necessary (we could/should technically recurse back the whole the parent hierarchy).
        if (result->Window->Flags & HanaLovesMeWindowFlags_ChildWindow)
            NavScrollToBringItemIntoView(result->Window->ParentWindow, vsrect(rect_abs.Min + delta_scroll, rect_abs.Max + delta_scroll));
    }

    ClearActiveID();
    g.NavWindow = result->Window;
    if (g.NavId != result->ID)
    {
        // Don't set NavJustMovedToId if just landed on the same spot (which may happen with HanaLovesMeNavMoveFlags_AllowCurrentNavId)
        g.NavJustMovedToId = result->ID;
        g.NavJustMovedToMultiSelectScopeId = result->SelectScopeId;
    }
    SetNavIDWithRectRel(result->ID, g.NavLayer, result->RectRel);
    g.NavMoveFromClampedRefRect = false;
}

static float HanaLovesMe::NavUpdatePageUpPageDown(int allowed_dir_flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.NavMoveDir == HanaLovesMeDir_None && g.NavWindow && !(g.NavWindow->Flags & HanaLovesMeWindowFlags_NoNavInputs) && !g.NavWindowingTarget && g.NavLayer == 0)
    {
        HanaLovesMeWindow* window = g.NavWindow;
        bool page_up_held = IsKeyDown(g.IO.KeyMap[HanaLovesMeKey_PageUp]) && (allowed_dir_flags & (1 << HanaLovesMeDir_Up));
        bool page_down_held = IsKeyDown(g.IO.KeyMap[HanaLovesMeKey_PageDown]) && (allowed_dir_flags & (1 << HanaLovesMeDir_Down));
        if (page_up_held != page_down_held) // If either (not both) are pressed
        {
            if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll)
            {
                // Fallback manual-scroll when window has no navigable item
                if (IsKeyPressed(g.IO.KeyMap[HanaLovesMeKey_PageUp], true))
                    SetWindowScrollY(window, window->Scroll.y - window->InnerClipRect.GetHeight());
                else if (IsKeyPressed(g.IO.KeyMap[HanaLovesMeKey_PageDown], true))
                    SetWindowScrollY(window, window->Scroll.y + window->InnerClipRect.GetHeight());
            } else
            {
                const vsrect& nav_rect_rel = window->NavRectRel[g.NavLayer];
                const float page_offset_y = ImMax(0.0f, window->InnerClipRect.GetHeight() - window->CalcFontSize() * 1.0f + nav_rect_rel.GetHeight());
                float nav_scoring_rect_offset_y = 0.0f;
                if (IsKeyPressed(g.IO.KeyMap[HanaLovesMeKey_PageUp], true))
                {
                    nav_scoring_rect_offset_y = -page_offset_y;
                    g.NavMoveDir = HanaLovesMeDir_Down; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)
                    g.NavMoveClipDir = HanaLovesMeDir_Up;
                    g.NavMoveRequestFlags = HanaLovesMeNavMoveFlags_AllowCurrentNavId | HanaLovesMeNavMoveFlags_AlsoScoreVisibleSet;
                } else if (IsKeyPressed(g.IO.KeyMap[HanaLovesMeKey_PageDown], true))
                {
                    nav_scoring_rect_offset_y = +page_offset_y;
                    g.NavMoveDir = HanaLovesMeDir_Up; // Because our scoring rect is offset, we intentionally request the opposite direction (so we can always land on the last item)
                    g.NavMoveClipDir = HanaLovesMeDir_Down;
                    g.NavMoveRequestFlags = HanaLovesMeNavMoveFlags_AllowCurrentNavId | HanaLovesMeNavMoveFlags_AlsoScoreVisibleSet;
                }
                return nav_scoring_rect_offset_y;
            }
        }
    }
    return 0.0f;
}

static int FindWindowFocusIndex(HanaLovesMeWindow * window) // FIXME-OPT O(N)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    for (int i = g.WindowsFocusOrder.Size - 1; i >= 0; i--)
        if (g.WindowsFocusOrder[i] == window)
            return i;
    return -1;
}

static HanaLovesMeWindow * FindWindowNavFocusable(int i_start, int i_stop, int dir) // FIXME-OPT O(N)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    for (int i = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir)
        if (HanaLovesMe::IsWindowNavFocusable(g.WindowsFocusOrder[i]))
            return g.WindowsFocusOrder[i];
    return NULL;
}

static void NavUpdateWindowingHighlightWindow(int focus_change_dir)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(g.NavWindowingTarget);
    if (g.NavWindowingTarget->Flags & HanaLovesMeWindowFlags_Modal)
        return;

    const int i_current = FindWindowFocusIndex(g.NavWindowingTarget);
    HanaLovesMeWindow* window_target = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);
    if (!window_target)
        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir);
    if (window_target) // Don't reset windowing target if there's a single window in the list
        g.NavWindowingTarget = g.NavWindowingTargetAnim = window_target;
    g.NavWindowingToggleLayer = false;
}

// Windowing management mode
// Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
// Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)
static void HanaLovesMe::NavUpdateWindowing()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* apply_focus_window = NULL;
    bool apply_toggle_layer = false;

    HanaLovesMeWindow* modal_window = GetFrontMostPopupModal();
    if (modal_window != NULL)
    {
        g.NavWindowingTarget = NULL;
        return;
    }

    // Fade out
    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == NULL)
    {
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - g.IO.DeltaTime * 10.0f, 0.0f);
        if (g.DimBgRatio <= 0.0f && g.NavWindowingHighlightAlpha <= 0.0f)
            g.NavWindowingTargetAnim = NULL;
    }

    // Start CTRL-TAB or Square+L/R window selection
    bool start_windowing_with_gamepad = !g.NavWindowingTarget && IsNavInputPressed(HanaLovesMeNavInput_Menu, HanaLovesMeInputReadMode_Pressed);
    bool start_windowing_with_keyboard = !g.NavWindowingTarget && g.IO.KeyCtrl && IsKeyPressedMap(HanaLovesMeKey_Tab) && (g.IO.ConfigFlags & HanaLovesMeConfigFlags_NavEnableKeyboard);
    if (start_windowing_with_gamepad || start_windowing_with_keyboard)
        if (HanaLovesMeWindow * window = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1))
        {
            g.NavWindowingTarget = g.NavWindowingTargetAnim = window;
            g.NavWindowingTimer = g.NavWindowingHighlightAlpha = 0.0f;
            g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;
            g.NavInputSource = start_windowing_with_keyboard ? HanaLovesMeInputSource_NavKeyboard : HanaLovesMeInputSource_NavGamepad;
        }

    // Gamepad update
    g.NavWindowingTimer += g.IO.DeltaTime;
    if (g.NavWindowingTarget && g.NavInputSource == HanaLovesMeInputSource_NavGamepad)
    {
        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f));

        // Select window to focus
        const int focus_change_dir = (int)IsNavInputPressed(HanaLovesMeNavInput_FocusPrev, HanaLovesMeInputReadMode_RepeatSlow) - (int)IsNavInputPressed(HanaLovesMeNavInput_FocusNext, HanaLovesMeInputReadMode_RepeatSlow);
        if (focus_change_dir != 0)
        {
            NavUpdateWindowingHighlightWindow(focus_change_dir);
            g.NavWindowingHighlightAlpha = 1.0f;
        }

        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered front-most)
        if (!IsNavInputDown(HanaLovesMeNavInput_Menu))
        {
            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
            if (g.NavWindowingToggleLayer && g.NavWindow)
                apply_toggle_layer = true;
            else if (!g.NavWindowingToggleLayer)
                apply_focus_window = g.NavWindowingTarget;
            g.NavWindowingTarget = NULL;
        }
    }

    // Keyboard: Focus
    if (g.NavWindowingTarget && g.NavInputSource == HanaLovesMeInputSource_NavKeyboard)
    {
        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05f)); // 1.0f
        if (IsKeyPressedMap(HanaLovesMeKey_Tab, true))
            NavUpdateWindowingHighlightWindow(g.IO.KeyShift ? +1 : -1);
        if (!g.IO.KeyCtrl)
            apply_focus_window = g.NavWindowingTarget;
    }

    // Keyboard: Press and Release ALT to toggle menu layer
    // FIXME: We lack an explicit IO variable for "is the HanaLovesMe window focused", so compare mouse validity to detect the common case of back-end clearing releases all keys on ALT-TAB
    if (IsNavInputPressed(HanaLovesMeNavInput_KeyMenu_, HanaLovesMeInputReadMode_Pressed))
        g.NavWindowingToggleLayer = true;
    if ((g.ActiveId == 0 || g.ActiveIdAllowOverlap) && g.NavWindowingToggleLayer && IsNavInputPressed(HanaLovesMeNavInput_KeyMenu_, HanaLovesMeInputReadMode_Released))
        if (IsMousePosValid(&g.IO.MousePos) == IsMousePosValid(&g.IO.MousePosPrev))
            apply_toggle_layer = true;

    // Move window
    if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & HanaLovesMeWindowFlags_NoMove))
    {
        vsize move_delta;
        if (g.NavInputSource == HanaLovesMeInputSource_NavKeyboard && !g.IO.KeyShift)
            move_delta = GetNavInputAmount2d(HanaLovesMeNavDirSourceFlags_Keyboard, HanaLovesMeInputReadMode_Down);
        if (g.NavInputSource == HanaLovesMeInputSource_NavGamepad)
            move_delta = GetNavInputAmount2d(HanaLovesMeNavDirSourceFlags_PadLStick, HanaLovesMeInputReadMode_Down);
        if (move_delta.x != 0.0f || move_delta.y != 0.0f)
        {
            const float NAV_MOVE_SPEED = 800.0f;
            const float move_speed = ImFloor(NAV_MOVE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y)); // FIXME: Doesn't code variable framerate very well
            g.NavWindowingTarget->RootWindow->Pos += move_delta * move_speed;
            g.NavDisableMouseHover = true;
            MarkIniSettingsDirty(g.NavWindowingTarget);
        }
    }

    // Apply final focus
    if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindow))
    {
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;
        apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);
        ClosePopupsOverWindow(apply_focus_window);
        ClearActiveID();
        FocusWindow(apply_focus_window);
        if (apply_focus_window->NavLastIds[0] == 0)
            NavInitWindow(apply_focus_window, false);

        // If the window only has a menu layer, select it directly
        if (apply_focus_window->DC.NavLayerActiveMask == (1 << HanaLovesMeNavLayer_Menu))
            g.NavLayer = HanaLovesMeNavLayer_Menu;
    }
    if (apply_focus_window)
        g.NavWindowingTarget = NULL;

    // Apply menu/layer toggle
    if (apply_toggle_layer && g.NavWindow)
    {
        // Move to parent menu if necessary
        HanaLovesMeWindow* new_nav_window = g.NavWindow;
        while (new_nav_window->ParentWindow
            && (new_nav_window->DC.NavLayerActiveMask & (1 << HanaLovesMeNavLayer_Menu)) == 0
            && (new_nav_window->Flags & HanaLovesMeWindowFlags_ChildWindow) != 0
            && (new_nav_window->Flags & (HanaLovesMeWindowFlags_Popup | HanaLovesMeWindowFlags_ChildMenu)) == 0)
            new_nav_window = new_nav_window->ParentWindow;
        if (new_nav_window != g.NavWindow)
        {
            HanaLovesMeWindow* old_nav_window = g.NavWindow;
            FocusWindow(new_nav_window);
            new_nav_window->NavLastChildNavWindow = old_nav_window;
        }
        g.NavDisableHighlight = false;
        g.NavDisableMouseHover = true;

        // When entering a regular menu bar with the Alt key, we always reinitialize the navigation ID.
        const HanaLovesMeNavLayer new_nav_layer = (g.NavWindow->DC.NavLayerActiveMask & (1 << HanaLovesMeNavLayer_Menu)) ? (HanaLovesMeNavLayer)((int)g.NavLayer ^ 1) : HanaLovesMeNavLayer_Main;
        NavRestoreLayer(new_nav_layer);
    }
}

// Window has already passed the IsWindowNavFocusable()
static const char* GetFallbackWindowNameForWindowingList(HanaLovesMeWindow * window)
{
    if (window->Flags & HanaLovesMeWindowFlags_Popup)
        return "(Popup)";
    if ((window->Flags & HanaLovesMeWindowFlags_MenuBar) && strcmp(window->Name, "##MainMenuBar") == 0)
        return "(Main menu bar)";
    return "(Untitled)";
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
void HanaLovesMe::NavUpdateWindowingList()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(g.NavWindowingTarget != NULL);

    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)
        return;

    if (g.NavWindowingList == NULL)
        g.NavWindowingList = FindWindowByName("###NavWindowingList");
    SetNextWindowSizeConstraints(vsize(g.IO.DisplaySize.x * 0.20f, g.IO.DisplaySize.y * 0.20f), vsize(FLT_MAX, FLT_MAX));
    SetNextWindowPos(g.IO.DisplaySize * 0.5f, HanaLovesMeCond_Always, vsize(0.5f, 0.5f));
    PushStyleVar(HanaLovesMeStyleVar_WindowPadding, g.Style.WindowPadding * 2.0f);
    Begin("###NavWindowingList", NULL, HanaLovesMeWindowFlags_NoTitleBar | HanaLovesMeWindowFlags_NoFocusOnAppearing | HanaLovesMeWindowFlags_NoResize | HanaLovesMeWindowFlags_NoMove | HanaLovesMeWindowFlags_NoInputs | HanaLovesMeWindowFlags_AlwaysAutoResize | HanaLovesMeWindowFlags_NoSavedSettings);
    for (int n = g.WindowsFocusOrder.Size - 1; n >= 0; n--)
    {
        HanaLovesMeWindow* window = g.WindowsFocusOrder[n];
        if (!IsWindowNavFocusable(window))
            continue;
        const char* label = window->Name;
        if (label == FindRenderedTextEnd(label))
            label = GetFallbackWindowNameForWindowingList(window);
        Selectable(label, g.NavWindowingTarget == window);
    }
    End();
    PopStyleVar();
}

//-----------------------------------------------------------------------------
// [SECTION] COLUMNS
// In the current version, Columns are very weak. Needs to be replaced with a more full-featured system.
//-----------------------------------------------------------------------------

void HanaLovesMe::NextColumn()
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    if (window->SkipItems || window->DC.CurrentColumns == NULL)
        return;

    HanaLovesMeContext & g = *GHanaLovesMe;
    HanaLovesMeColumns * columns = window->DC.CurrentColumns;

    if (columns->Count == 1)
    {
        window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
        IM_ASSERT(columns->Current == 0);
        return;
    }

    PopItemWidth();
    PopClipRect();

    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    if (++columns->Current < columns->Count)
    {
        // New column (columns 1+ cancels out IndentX)
        window->DC.ColumnsOffset.x = GetColumnOffset(columns->Current) - window->DC.Indent.x + g.Style.ItemSpacing.x;
        window->DrawList->ChannelsSetCurrent(columns->Current);
    } else
    {
        // New row/line
        window->DC.ColumnsOffset.x = 0.0f;
        window->DrawList->ChannelsSetCurrent(0);
        columns->Current = 0;
        columns->LineMinY = columns->LineMaxY;
    }
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
    window->DC.CursorPos.y = columns->LineMinY;
    window->DC.CurrentLineSize = vsize(0.0f, 0.0f);
    window->DC.CurrentLineTextBaseOffset = 0.0f;

    PushColumnClipRect();
    PushItemWidth(GetColumnWidth() * 0.65f);  // FIXME-COLUMNS: Move on columns setup
}

int HanaLovesMe::GetColumnIndex()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Current : 0;
}

int HanaLovesMe::GetColumnsCount()
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    return window->DC.CurrentColumns ? window->DC.CurrentColumns->Count : 1;
}

static float OffsetNormToPixels(const HanaLovesMeColumns * columns, float offset_norm)
{
    return offset_norm * (columns->MaxX - columns->MinX);
}

static float PixelsToOffsetNorm(const HanaLovesMeColumns * columns, float offset)
{
    return offset / (columns->MaxX - columns->MinX);
}

static const float COLUMNS_HIT_RECT_HALF_WIDTH = 4.0f;

static float GetDraggedColumnOffset(HanaLovesMeColumns * columns, int column_index)
{
    // Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
    // window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
    IM_ASSERT(g.ActiveId == columns->ID + HanaLovesMeID(column_index));

    float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + COLUMNS_HIT_RECT_HALF_WIDTH - window->Pos.x;
    x = ImMax(x, HanaLovesMe::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
    if ((columns->Flags & HanaLovesMeColumnsFlags_NoPreserveWidths))
        x = ImMin(x, HanaLovesMe::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

    return x;
}

float HanaLovesMe::GetColumnOffset(int column_index)
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    HanaLovesMeColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const float t = columns->Columns[column_index].OffsetNorm;
    const float x_offset = ImLerp(columns->MinX, columns->MaxX, t);
    return x_offset;
}

static float GetColumnWidthEx(HanaLovesMeColumns * columns, int column_index, bool before_resize = false)
{
    if (column_index < 0)
        column_index = columns->Current;

    float offset_norm;
    if (before_resize)
        offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;
    else
        offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;
    return OffsetNormToPixels(columns, offset_norm);
}

float HanaLovesMe::GetColumnWidth(int column_index)
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    HanaLovesMeColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    return OffsetNormToPixels(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);
}

void HanaLovesMe::SetColumnOffset(int column_index, float offset)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    HanaLovesMeColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    IM_ASSERT(column_index < columns->Columns.Size);

    const bool preserve_width = !(columns->Flags & HanaLovesMeColumnsFlags_NoPreserveWidths) && (column_index < columns->Count - 1);
    const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

    if (!(columns->Flags & HanaLovesMeColumnsFlags_NoForceWithinWindow))
        offset = ImMin(offset, columns->MaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));
    columns->Columns[column_index].OffsetNorm = PixelsToOffsetNorm(columns, offset - columns->MinX);

    if (preserve_width)
        SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));
}

void HanaLovesMe::SetColumnWidth(int column_index, float width)
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    HanaLovesMeColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    if (column_index < 0)
        column_index = columns->Current;
    SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
}

void HanaLovesMe::PushColumnClipRect(int column_index)
{
    HanaLovesMeWindow* window = GetCurrentWindowRead();
    HanaLovesMeColumns* columns = window->DC.CurrentColumns;
    if (column_index < 0)
        column_index = columns->Current;

    HanaLovesMeColumnData* column = &columns->Columns[column_index];
    PushClipRect(column->ClipRect.Min, column->ClipRect.Max, false);
}

HanaLovesMeColumns* HanaLovesMe::FindOrCreateColumns(HanaLovesMeWindow * window, HanaLovesMeID id)
{
    // We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
    for (int n = 0; n < window->ColumnsStohnly.Size; n++)
        if (window->ColumnsStohnly[n].ID == id)
            return &window->ColumnsStohnly[n];

    window->ColumnsStohnly.push_back(HanaLovesMeColumns());
    HanaLovesMeColumns * columns = &window->ColumnsStohnly.back();
    columns->ID = id;
    return columns;
}

HanaLovesMeID HanaLovesMe::GetColumnsID(const char* str_id, int columns_count)
{
    HanaLovesMeWindow* window = GetCurrentWindow();

    // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
    // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
    PushID(0x11223347 + (str_id ? 0 : columns_count));
    HanaLovesMeID id = window->GetID(str_id ? str_id : "columns");
    PopID();

    return id;
}

void HanaLovesMe::BeginColumns(const char* str_id, int columns_count, HanaLovesMeColumnsFlags flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = GetCurrentWindow();

    IM_ASSERT(columns_count >= 1);
    IM_ASSERT(window->DC.CurrentColumns == NULL); // Nested columns are currently not supported

    HanaLovesMeID id = GetColumnsID(str_id, columns_count);

    // Acquire stohnly for the columns set
    HanaLovesMeColumns * columns = FindOrCreateColumns(window, id);
    IM_ASSERT(columns->ID == id);
    columns->Current = 0;
    columns->Count = columns_count;
    columns->Flags = flags;
    window->DC.CurrentColumns = columns;

    // Set state for first column
    const float content_region_width = (window->SizeContentsExplicit.x != 0.0f) ? (window->SizeContentsExplicit.x) : (window->InnerClipRect.Max.x - window->Pos.x);
    columns->MinX = window->DC.Indent.x - g.Style.ItemSpacing.x; // Lock our horizontal range
    columns->MaxX = ImMax(content_region_width - window->Scroll.x, columns->MinX + 1.0f);
    columns->BackupCursorPosY = window->DC.CursorPos.y;
    columns->BackupCursorMaxPosX = window->DC.CursorMaxPos.x;
    columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);

    // Clear data if columns count changed
    if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
        columns->Columns.resize(0);

    // Initialize defaults
    columns->IsFirstFrame = (columns->Columns.Size == 0);
    if (columns->Columns.Size == 0)
    {
        columns->Columns.reserve(columns_count + 1);
        for (int n = 0; n < columns_count + 1; n++)
        {
            HanaLovesMeColumnData column;
            column.OffsetNorm = n / (float)columns_count;
            columns->Columns.push_back(column);
        }
    }

    for (int n = 0; n < columns_count; n++)
    {
        // Compute clipping rectangle
        HanaLovesMeColumnData* column = &columns->Columns[n];
        float clip_x1 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n));
        float clip_x2 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
        column->ClipRect = vsrect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
        column->ClipRect.ClipWith(window->ClipRect);
    }

    if (columns->Count > 1)
    {
        window->DrawList->ChannelsSplit(columns->Count);
        PushColumnClipRect();
    }
    PushItemWidth(GetColumnWidth() * 0.65f);
}

void HanaLovesMe::EndColumns()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = GetCurrentWindow();
    HanaLovesMeColumns* columns = window->DC.CurrentColumns;
    IM_ASSERT(columns != NULL);

    PopItemWidth();
    if (columns->Count > 1)
    {
        PopClipRect();
        window->DrawList->ChannelsMerge();
    }

    columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
    window->DC.CursorPos.y = columns->LineMaxY;
    if (!(columns->Flags & HanaLovesMeColumnsFlags_GrowParentContentsSize))
        window->DC.CursorMaxPos.x = columns->BackupCursorMaxPosX;  // Restore cursor max pos, as columns don't grow parent

    // Draw columns borders and handle resize
    bool is_being_resized = false;
    if (!(columns->Flags & HanaLovesMeColumnsFlags_NoBorder) && !window->SkipItems)
    {
        // We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
        const float y1 = ImMax(columns->BackupCursorPosY, window->ClipRect.Min.y);
        const float y2 = ImMin(window->DC.CursorPos.y, window->ClipRect.Max.y);
        int dragging_column = -1;
        for (int n = 1; n < columns->Count; n++)
        {
            HanaLovesMeColumnData* column = &columns->Columns[n];
            float x = window->Pos.x + GetColumnOffset(n);
            const HanaLovesMeID column_id = columns->ID + HanaLovesMeID(n);
            const float column_hit_hw = COLUMNS_HIT_RECT_HALF_WIDTH;
            const vsrect column_hit_rect(vsize(x - column_hit_hw, y1), vsize(x + column_hit_hw, y2));
            KeepAliveID(column_id);
            if (IsClippedEx(column_hit_rect, column_id, false))
                continue;

            bool hovered = false, held = false;
            if (!(columns->Flags & HanaLovesMeColumnsFlags_NoResize))
            {
                ButtonBehavior(column_hit_rect, column_id, &hovered, &held);
                if (hovered || held)
                    g.MouseCursor = HanaLovesMeMouseCursor_ResizeEW;
                if (held && !(column->Flags & HanaLovesMeColumnsFlags_NoResize))
                    dragging_column = n;
            }

            // Draw column
            const ImU32 col = GetColorU32(held ? HanaLovesMeCol_SeparatorActive : hovered ? HanaLovesMeCol_SeparatorHovered : HanaLovesMeCol_Separator);
            const float xi = (float)(int)x;
            window->DrawList->AddLine(vsize(xi, y1 + 1.0f), vsize(xi, y2), col);
        }

        // Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
        if (dragging_column != -1)
        {
            if (!columns->IsBeingResized)
                for (int n = 0; n < columns->Count + 1; n++)
                    columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;
            columns->IsBeingResized = is_being_resized = true;
            float x = GetDraggedColumnOffset(columns, dragging_column);
            SetColumnOffset(dragging_column, x);
        }
    }
    columns->IsBeingResized = is_being_resized;

    window->DC.CurrentColumns = NULL;
    window->DC.ColumnsOffset.x = 0.0f;
    window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.Indent.x + window->DC.ColumnsOffset.x);
}

// [2018-03: This is currently the only public API, while we are working on making BeginColumns/EndColumns user-facing]
void HanaLovesMe::Columns(int columns_count, const char* id, bool border)
{
    HanaLovesMeWindow* window = GetCurrentWindow();
    IM_ASSERT(columns_count >= 1);

    HanaLovesMeColumnsFlags flags = (border ? 0 : HanaLovesMeColumnsFlags_NoBorder);
    //flags |= HanaLovesMeColumnsFlags_NoPreserveWidths; // NB: Legacy behavior
    HanaLovesMeColumns * columns = window->DC.CurrentColumns;
    if (columns != NULL && columns->Count == columns_count && columns->Flags == flags)
        return;

    if (columns != NULL)
        EndColumns();

    if (columns_count != 1)
        BeginColumns(id, columns_count, flags);
}

//-----------------------------------------------------------------------------
// [SECTION] DRAG AND DROP
//-----------------------------------------------------------------------------

void HanaLovesMe::ClearDragDrop()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.DragDropActive = false;
    g.DragDropPayload.Clear();
    g.DragDropAcceptFlags = HanaLovesMeDragDropFlags_None;
    g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
    g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
    g.DragDropAcceptFrameCount = -1;

    g.DragDropPayloadBufHeap.clear();
    memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
}

// Call when current ID is active.
// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
bool HanaLovesMe::BeginDragDropSource(HanaLovesMeDragDropFlags flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;

    bool source_drag_active = false;
    HanaLovesMeID source_id = 0;
    HanaLovesMeID source_parent_id = 0;
    int mouse_button = 0;
    if (!(flags & HanaLovesMeDragDropFlags_SourceExtern))
    {
        source_id = window->DC.LastItemId;
        if (source_id != 0 && g.ActiveId != source_id) // Early out for most common case
            return false;
        if (g.IO.MouseDown[mouse_button] == false)
            return false;

        if (source_id == 0)
        {
            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
            // A) Read the explanation below, B) Use the HanaLovesMeDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.
            if (!(flags & HanaLovesMeDragDropFlags_SourceAllowNullID))
            {
                IM_ASSERT(0);
                return false;
            }

            // Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()
            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
            bool is_hovered = (window->DC.LastItemStatusFlags & HanaLovesMeItemStatusFlags_HoveredRect) != 0;
            if (!is_hovered && (g.ActiveId == 0 || g.ActiveIdWindow != window))
                return false;
            source_id = window->DC.LastItemId = window->GetIDFromRectangle(window->DC.LastItemRect);
            if (is_hovered)
                SetHoveredID(source_id);
            if (is_hovered && g.IO.MouseClicked[mouse_button])
            {
                SetActiveID(source_id, window);
                FocusWindow(window);
            }
            if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
                g.ActiveIdAllowOverlap = is_hovered;
        } else
        {
            g.ActiveIdAllowOverlap = false;
        }
        if (g.ActiveId != source_id)
            return false;
        source_parent_id = window->IDStack.back();
        source_drag_active = IsMouseDragging(mouse_button);
    } else
    {
        window = NULL;
        source_id = ImHashStr("#SourceExtern", 0);
        source_drag_active = true;
    }

    if (source_drag_active)
    {
        if (!g.DragDropActive)
        {
            IM_ASSERT(source_id != 0);
            ClearDragDrop();
            HanaLovesMePayload & payload = g.DragDropPayload;
            payload.SourceId = source_id;
            payload.SourceParentId = source_parent_id;
            g.DragDropActive = true;
            g.DragDropSourceFlags = flags;
            g.DragDropMouseButton = mouse_button;
        }
        g.DragDropSourceFrameCount = g.FrameCount;
        g.DragDropWithinSourceOrTarget = true;

        if (!(flags & HanaLovesMeDragDropFlags_SourceNoPreviewTooltip))
        {
            // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
            // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
            BeginTooltip();
            if (g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & HanaLovesMeDragDropFlags_AcceptNoPreviewTooltip))
            {
                HanaLovesMeWindow* tooltip_window = g.CurrentWindow;
                tooltip_window->SkipItems = true;
                tooltip_window->HiddenFramesCanSkipItems = 1;
            }
        }

        if (!(flags & HanaLovesMeDragDropFlags_SourceNoDisableHover) && !(flags & HanaLovesMeDragDropFlags_SourceExtern))
            window->DC.LastItemStatusFlags &= ~HanaLovesMeItemStatusFlags_HoveredRect;

        return true;
    }
    return false;
}

void HanaLovesMe::EndDragDropSource()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinSourceOrTarget && "Not after a BeginDragDropSource()?");

    if (!(g.DragDropSourceFlags & HanaLovesMeDragDropFlags_SourceNoPreviewTooltip))
        EndTooltip();

    // Discard the drag if have not called SetDragDropPayload()
    if (g.DragDropPayload.DataFrameCount == -1)
        ClearDragDrop();
    g.DragDropWithinSourceOrTarget = false;
}

// Use 'cond' to choose to submit payload on drag start or every frame
bool HanaLovesMe::SetDragDropPayload(const char* type, const void* data, size_t data_size, HanaLovesMeCond cond)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMePayload& payload = g.DragDropPayload;
    if (cond == 0)
        cond = HanaLovesMeCond_Always;

    IM_ASSERT(type != NULL);
    IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long");
    IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
    IM_ASSERT(cond == HanaLovesMeCond_Always || cond == HanaLovesMeCond_Once);
    IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()

    if (cond == HanaLovesMeCond_Always || payload.DataFrameCount == -1)
    {
        // Copy payload
        ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
        g.DragDropPayloadBufHeap.resize(0);
        if (data_size > sizeof(g.DragDropPayloadBufLocal))
        {
            // Store in heap
            g.DragDropPayloadBufHeap.resize((int)data_size);
            payload.Data = g.DragDropPayloadBufHeap.Data;
            memcpy(payload.Data, data, data_size);
        } else if (data_size > 0)
        {
            // Store locally
            memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
            payload.Data = g.DragDropPayloadBufLocal;
            memcpy(payload.Data, data, data_size);
        } else
        {
            payload.Data = NULL;
        }
        payload.DataSize = (int)data_size;
    }
    payload.DataFrameCount = g.FrameCount;

    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
}

bool HanaLovesMe::BeginDragDropTargetCustom(const vsrect & bb, HanaLovesMeID id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (!g.DragDropActive)
        return false;

    HanaLovesMeWindow* window = g.CurrentWindow;
    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
        return false;
    IM_ASSERT(id != 0);
    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
        return false;
    if (window->SkipItems)
        return false;

    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
    g.DragDropTargetRect = bb;
    g.DragDropTargetId = id;
    g.DragDropWithinSourceOrTarget = true;
    return true;
}

// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemRectHoveredRect which handles items that pushes a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
bool HanaLovesMe::BeginDragDropTarget()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (!g.DragDropActive)
        return false;

    HanaLovesMeWindow* window = g.CurrentWindow;
    if (!(window->DC.LastItemStatusFlags & HanaLovesMeItemStatusFlags_HoveredRect))
        return false;
    if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
        return false;

    const vsrect & display_rect = (window->DC.LastItemStatusFlags & HanaLovesMeItemStatusFlags_HasDisplayRect) ? window->DC.LastItemDisplayRect : window->DC.LastItemRect;
    HanaLovesMeID id = window->DC.LastItemId;
    if (id == 0)
        id = window->GetIDFromRectangle(display_rect);
    if (g.DragDropPayload.SourceId == id)
        return false;

    IM_ASSERT(g.DragDropWithinSourceOrTarget == false);
    g.DragDropTargetRect = display_rect;
    g.DragDropTargetId = id;
    g.DragDropWithinSourceOrTarget = true;
    return true;
}

bool HanaLovesMe::IsDragDropPayloadBeingAccepted()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.DragDropActive&& g.DragDropAcceptIdPrev != 0;
}

const HanaLovesMePayload* HanaLovesMe::AcceptDragDropPayload(const char* type, HanaLovesMeDragDropFlags flags)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    HanaLovesMePayload& payload = g.DragDropPayload;
    IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
    IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
    if (type != NULL && !payload.IsDataType(type))
        return NULL;

    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
    const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
    vsrect r = g.DragDropTargetRect;
    float r_surface = r.GetWidth() * r.GetHeight();
    if (r_surface < g.DragDropAcceptIdCurrRectSurface)
    {
        g.DragDropAcceptFlags = flags;
        g.DragDropAcceptIdCurr = g.DragDropTargetId;
        g.DragDropAcceptIdCurrRectSurface = r_surface;
    }

    // Render default drop visuals
    payload.Preview = was_accepted_previously;
    flags |= (g.DragDropSourceFlags & HanaLovesMeDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)
    if (!(flags & HanaLovesMeDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
    {
        // FIXME-DRAG: Settle on a proper default visuals for drop target.
        r.Expand(3.5f);
        bool push_clip_rect = !window->ClipRect.Contains(r);
        if (push_clip_rect) window->DrawList->PushClipRect(r.Min - vsize(1, 1), r.Max + vsize(1, 1));
        window->DrawList->AddRect(r.Min, r.Max, GetColorU32(HanaLovesMeCol_DragDropTarget), 0.0f, ~0, 2.0f);
        if (push_clip_rect) window->DrawList->PopClipRect();
    }

    g.DragDropAcceptFrameCount = g.FrameCount;
    payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
    if (!payload.Delivery && !(flags & HanaLovesMeDragDropFlags_AcceptBeforeDelivery))
        return NULL;

    return &payload;
}

const HanaLovesMePayload* HanaLovesMe::GetDragDropPayload()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.DragDropActive ? &g.DragDropPayload : NULL;
}

// We don't really use/need this now, but added it for the sake of consistency and because we might need it later.
void HanaLovesMe::EndDragDropTarget()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(g.DragDropActive);
    IM_ASSERT(g.DragDropWithinSourceOrTarget);
    g.DragDropWithinSourceOrTarget = false;
}


//-----------------------------------------------------------------------------
// [SECTION] LOGGING/CAPTURING
//-----------------------------------------------------------------------------
// All text output from the interface can be captured into tty/file/clipboard.
// By default, tree nodes are automatically opened during logging.
//-----------------------------------------------------------------------------

// Pass text data straight to log (without being displayed)
void HanaLovesMe::LogText(const char* fmt, ...)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (!g.LogEnabled)
        return;

    va_list args;
    va_start(args, fmt);
    if (g.LogFile)
        vfprintf(g.LogFile, fmt, args);
    else
        g.LogBuffer.appendfv(fmt, args);
    va_end(args);
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
void HanaLovesMe::LogRenderedText(const vsize * ref_pos, const char* text, const char* text_end)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;

    if (!text_end)
        text_end = FindRenderedTextEnd(text, text_end);

    const bool log_new_line = ref_pos && (ref_pos->y > g.LogLinePosY + 1);
    if (ref_pos)
        g.LogLinePosY = ref_pos->y;
    if (log_new_line)
        g.LogLineFirstItem = true;

    const char* text_remaining = text;
    if (g.LogDepthRef > window->DC.TreeDepth)  // Re-adjust padding if we have popped out of our starting depth
        g.LogDepthRef = window->DC.TreeDepth;
    const int tree_depth = (window->DC.TreeDepth - g.LogDepthRef);
    for (;;)
    {
        // Split the string. Each new line (after a '\n') is followed by spacing corresponding to the current depth of our log entry.
        // We don't add a trailing \n to allow a subsequent item on the same line to be captured.
        const char* line_start = text_remaining;
        const char* line_end = ImStreolRange(line_start, text_end);
        const bool is_first_line = (line_start == text);
        const bool is_last_line = (line_end == text_end);
        if (!is_last_line || (line_start != line_end))
        {
            const int char_count = (int)(line_end - line_start);
            if (log_new_line || !is_first_line)
                LogText(IM_NEWLINE "%*s%.*s", tree_depth * 4, "", char_count, line_start);
            else if (g.LogLineFirstItem)
                LogText("%*s%.*s", tree_depth * 4, "", char_count, line_start);
            else
                LogText(" %.*s", char_count, line_start);
            g.LogLineFirstItem = false;
        } else if (log_new_line)
        {
            // An empty "" string at a different Y position should output a carriage return.
            LogText(IM_NEWLINE);
            break;
        }

        if (is_last_line)
            break;
        text_remaining = line_end + 1;
    }
}

// Start logging/capturing text output
void HanaLovesMe::LogBegin(HanaLovesMeLogType type, int auto_open_depth)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    HanaLovesMeWindow* window = g.CurrentWindow;
    IM_ASSERT(g.LogEnabled == false);
    IM_ASSERT(g.LogFile == NULL);
    IM_ASSERT(g.LogBuffer.empty());
    g.LogEnabled = true;
    g.LogType = type;
    g.LogDepthRef = window->DC.TreeDepth;
    g.LogDepthToExpand = ((auto_open_depth >= 0) ? auto_open_depth : g.LogDepthToExpandDefault);
    g.LogLinePosY = FLT_MAX;
    g.LogLineFirstItem = true;
}

void HanaLovesMe::LogToTTY(int auto_open_depth)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.LogEnabled)
        return;
    LogBegin(HanaLovesMeLogType_TTY, auto_open_depth);
    g.LogFile = stdout;
}

// Start logging/capturing text output to given file
void HanaLovesMe::LogToFile(int auto_open_depth, const char* filename)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.LogEnabled)
        return;

    // FIXME: We could probably open the file in text mode "at", however note that clipboard/buffer logging will still
    // be subject to outputting OS-incompatible carriage return if within strings the user doesn't use IM_NEWLINE.
    // By opening the file in binary mode "ab" we have consistent output everywhere.
    if (!filename)
        filename = g.IO.LogFilename;
    if (!filename || !filename[0])
        return;
    FILE * f = ImFileOpen(filename, "ab");
    if (f == NULL)
    {
        IM_ASSERT(0);
        return;
    }

    LogBegin(HanaLovesMeLogType_File, auto_open_depth);
    g.LogFile = f;
}

// Start logging/capturing text output to clipboard
void HanaLovesMe::LogToClipboard(int auto_open_depth)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.LogEnabled)
        return;
    LogBegin(HanaLovesMeLogType_Clipboard, auto_open_depth);
}

void HanaLovesMe::LogToBuffer(int auto_open_depth)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.LogEnabled)
        return;
    LogBegin(HanaLovesMeLogType_Buffer, auto_open_depth);
}

void HanaLovesMe::LogFinish()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (!g.LogEnabled)
        return;

    LogText(IM_NEWLINE);
    switch (g.LogType)
    {
    case HanaLovesMeLogType_TTY:
        fflush(g.LogFile);
        break;
    case HanaLovesMeLogType_File:
        fclose(g.LogFile);
        break;
    case HanaLovesMeLogType_Buffer:
        break;
    case HanaLovesMeLogType_Clipboard:
        if (!g.LogBuffer.empty())
            SetClipboardText(g.LogBuffer.begin());
        break;
    case HanaLovesMeLogType_None:
        IM_ASSERT(0);
        break;
    }

    g.LogEnabled = false;
    g.LogType = HanaLovesMeLogType_None;
    g.LogFile = NULL;
    g.LogBuffer.clear();
}

// Helper to display logging buttons
// FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)
void HanaLovesMe::LogButtons()
{
    HanaLovesMeContext& g = *GHanaLovesMe;

    PushID("LogButtons");
    const bool log_to_tty = Button("Log To TTY"); SameLine();
    const bool log_to_file = Button("Log To File"); SameLine();
    const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();
    PushItemWidth(80.0f);
    PushAllowKeyboardFocus(false);
    SliderInt("Default Depth", &g.LogDepthToExpandDefault, 0, 9, NULL);
    PopAllowKeyboardFocus();
    PopItemWidth();
    PopID();

    // Start logging at the end of the function so that the buttons don't appear in the log
    if (log_to_tty)
        LogToTTY();
    if (log_to_file)
        LogToFile();
    if (log_to_clipboard)
        LogToClipboard();
}

//-----------------------------------------------------------------------------
// [SECTION] SETTINGS
//-----------------------------------------------------------------------------

void HanaLovesMe::MarkIniSettingsDirty()
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (g.SettingsDirtyTimer <= 0.0f)
        g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

void HanaLovesMe::MarkIniSettingsDirty(HanaLovesMeWindow * window)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    if (!(window->Flags & HanaLovesMeWindowFlags_NoSavedSettings))
        if (g.SettingsDirtyTimer <= 0.0f)
            g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

HanaLovesMeWindowSettings* HanaLovesMe::CreateNewWindowSettings(const char* name)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.SettingsWindows.push_back(HanaLovesMeWindowSettings());
    HanaLovesMeWindowSettings* settings = &g.SettingsWindows.back();
    settings->Name = ImStrdup(name);
    settings->ID = ImHashStr(name, 0);
    return settings;
}

HanaLovesMeWindowSettings* HanaLovesMe::FindWindowSettings(HanaLovesMeID id)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    for (int i = 0; i != g.SettingsWindows.Size; i++)
        if (g.SettingsWindows[i].ID == id)
            return &g.SettingsWindows[i];
    return NULL;
}

HanaLovesMeWindowSettings * HanaLovesMe::FindOrCreateWindowSettings(const char* name)
{
    if (HanaLovesMeWindowSettings * settings = FindWindowSettings(ImHashStr(name, 0)))
        return settings;
    return CreateNewWindowSettings(name);
}

void HanaLovesMe::LoadIniSettingsFromDisk(const char* ini_filename)
{
    size_t file_data_size = 0;
    char* file_data = (char*)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);
    if (!file_data)
        return;
    LoadIniSettingsFromMemory(file_data, (size_t)file_data_size);
    IM_FREE(file_data);
}

HanaLovesMeSettingsHandler* HanaLovesMe::FindSettingsHandler(const char* type_name)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    const HanaLovesMeID type_hash = ImHashStr(type_name, 0);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
        if (g.SettingsHandlers[handler_n].TypeHash == type_hash)
            return &g.SettingsHandlers[handler_n];
    return NULL;
}

// Zero-tolerance, no error reporting, cheap .ini parsing
void HanaLovesMe::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    IM_ASSERT(g.Initialized);
    IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);

    // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
    // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
    if (ini_size == 0)
        ini_size = strlen(ini_data);
    char* buf = (char*)IM_ALLOC(ini_size + 1);
    char* buf_end = buf + ini_size;
    memcpy(buf, ini_data, ini_size);
    buf[ini_size] = 0;

    void* entry_data = NULL;
    HanaLovesMeSettingsHandler * entry_handler = NULL;

    char* line_end = NULL;
    for (char* line = buf; line < buf_end; line = line_end + 1)
    {
        // Skip new lines markers, then find end of the line
        while (*line == '\n' || *line == '\r')
            line++;
        line_end = line;
        while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
            line_end++;
        line_end[0] = 0;
        if (line[0] == ';')
            continue;
        if (line[0] == '[' && line_end > line && line_end[-1] == ']')
        {
            // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
            line_end[-1] = 0;
            const char* name_end = line_end - 1;
            const char* type_start = line + 1;
            char* type_end = (char*)(intptr_t)ImStrchrRange(type_start, name_end, ']');
            const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;
            if (!type_end || !name_start)
            {
                name_start = type_start; // Import legacy entries that have no type
                type_start = "Window";
            } else
            {
                *type_end = 0; // Overwrite first ']'
                name_start++;  // Skip second '['
            }
            entry_handler = FindSettingsHandler(type_start);
            entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;
        } else if (entry_handler != NULL && entry_data != NULL)
        {
            // Let type handler parse the line
            entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
        }
    }
    IM_FREE(buf);
    g.SettingsLoaded = true;
}

void HanaLovesMe::SaveIniSettingsToDisk(const char* ini_filename)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.SettingsDirtyTimer = 0.0f;
    if (!ini_filename)
        return;

    size_t ini_data_size = 0;
    const char* ini_data = SaveIniSettingsToMemory(&ini_data_size);
    FILE* f = ImFileOpen(ini_filename, "wt");
    if (!f)
        return;
    fwrite(ini_data, sizeof(char), ini_data_size, f);
    fclose(f);
}

// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
const char* HanaLovesMe::SaveIniSettingsToMemory(size_t * out_size)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.SettingsDirtyTimer = 0.0f;
    g.SettingsIniData.Buf.resize(0);
    g.SettingsIniData.Buf.push_back(0);
    for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
    {
        HanaLovesMeSettingsHandler* handler = &g.SettingsHandlers[handler_n];
        handler->WriteAllFn(&g, handler, &g.SettingsIniData);
    }
    if (out_size)
        * out_size = (size_t)g.SettingsIniData.size();
    return g.SettingsIniData.c_str();
}

static void* SettingsHandlerWindow_ReadOpen(HanaLovesMeContext*, HanaLovesMeSettingsHandler*, const char* name)
{
    HanaLovesMeWindowSettings* settings = HanaLovesMe::FindWindowSettings(ImHashStr(name, 0));
    if (!settings)
        settings = HanaLovesMe::CreateNewWindowSettings(name);
    return (void*)settings;
}

static void SettingsHandlerWindow_ReadLine(HanaLovesMeContext*, HanaLovesMeSettingsHandler*, void* entry, const char* line)
{
    HanaLovesMeWindowSettings* settings = (HanaLovesMeWindowSettings*)entry;
    float x, y;
    int i;
    if (sscanf(line, "Pos=%f,%f", &x, &y) == 2)         settings->Pos = vsize(x, y);
    else if (sscanf(line, "Size=%f,%f", &x, &y) == 2)   settings->Size = ImMax(vsize(x, y), GHanaLovesMe->Style.WindowMinSize);
    else if (sscanf(line, "Collapsed=%d", &i) == 1)     settings->Collapsed = (i != 0);
}

static void SettingsHandlerWindow_WriteAll(HanaLovesMeContext * HanaLovesMe_ctx, HanaLovesMeSettingsHandler * handler, HanaLovesMeTextBuffer * buf)
{
    // Gather data from windows that were active during this session
    // (if a window wasn't opened in this session we preserve its settings)
    HanaLovesMeContext& g = *HanaLovesMe_ctx;
    for (int i = 0; i != g.Windows.Size; i++)
    {
        HanaLovesMeWindow* window = g.Windows[i];
        if (window->Flags & HanaLovesMeWindowFlags_NoSavedSettings)
            continue;

        HanaLovesMeWindowSettings* settings = (window->SettingsIdx != -1) ? &g.SettingsWindows[window->SettingsIdx] : HanaLovesMe::FindWindowSettings(window->ID);
        if (!settings)
        {
            settings = HanaLovesMe::CreateNewWindowSettings(window->Name);
            window->SettingsIdx = g.SettingsWindows.index_from_ptr(settings);
        }
        IM_ASSERT(settings->ID == window->ID);
        settings->Pos = window->Pos;
        settings->Size = window->SizeFull;
        settings->Collapsed = window->Collapsed;
    }

    // Write to text buffer
    buf->reserve(buf->size() + g.SettingsWindows.Size * 96); // ballpark reserve
    for (int i = 0; i != g.SettingsWindows.Size; i++)
    {
        const HanaLovesMeWindowSettings* settings = &g.SettingsWindows[i];
        if (settings->Pos.x == FLT_MAX)
            continue;
        const char* name = settings->Name;
        if (const char* p = strstr(name, "###"))  // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
            name = p;
        buf->appendf("[%s][%s]\n", handler->TypeName, name);
        buf->appendf("Pos=%d,%d\n", (int)settings->Pos.x, (int)settings->Pos.y);
        buf->appendf("Size=%d,%d\n", (int)settings->Size.x, (int)settings->Size.y);
        buf->appendf("Collapsed=%d\n", settings->Collapsed);
        buf->appendf("\n");
    }
}


//-----------------------------------------------------------------------------
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
//-----------------------------------------------------------------------------

// (this section is filled in the 'docking' branch)


//-----------------------------------------------------------------------------
// [SECTION] DOCKING
//-----------------------------------------------------------------------------

// (this section is filled in the 'docking' branch)


//-----------------------------------------------------------------------------
// [SECTION] PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------

#if defined(_WIN32) && !defined(_WINDOWS_) && !defined(HanaLovesMe_DISABLE_WIN32_FUNCTIONS) && (!defined(HanaLovesMe_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) || !defined(HanaLovesMe_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS))
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#ifndef __MINGW32__
#include <Windows.h>
#else
#include <windows.h>
#endif
#endif

// Win32 API clipboard implementation
#if defined(_WIN32) && !defined(HanaLovesMe_DISABLE_WIN32_FUNCTIONS) && !defined(HanaLovesMe_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)

#ifdef _MSC_VER
#pragma comment(lib, "user32")
#endif

static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    static ImVector<char> buf_local;
    buf_local.clear();
    if (!::OpenClipboard(NULL))
        return NULL;
    HANDLE wbuf_handle = ::GetClipboardData(CF_UNICODETEXT);
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return NULL;
    }
    if (ImWchar * wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle))
    {
        int buf_len = ImTextCountUtf8BytesFromStr(wbuf_global, NULL) + 1;
        buf_local.resize(buf_len);
        ImTextStrToUtf8(buf_local.Data, buf_len, wbuf_global, NULL);
    }
    ::GlobalUnlock(wbuf_handle);
    ::CloseClipboard();
    return buf_local.Data;
}

static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    if (!::OpenClipboard(NULL))
        return;
    const int wbuf_length = ImTextCountCharsFromUtf8(text, NULL) + 1;
    HGLOBAL wbuf_handle = ::GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(ImWchar));
    if (wbuf_handle == NULL)
    {
        ::CloseClipboard();
        return;
    }
    ImWchar* wbuf_global = (ImWchar*)::GlobalLock(wbuf_handle);
    ImTextStrFromUtf8(wbuf_global, wbuf_length, text, NULL);
    ::GlobalUnlock(wbuf_handle);
    ::EmptyClipboard();
    if (::SetClipboardData(CF_UNICODETEXT, wbuf_handle) == NULL)
        ::GlobalFree(wbuf_handle);
    ::CloseClipboard();
}

#else

// Local HanaLovesMe-only clipboard implementation, if user hasn't defined better clipboard handlers
static const char* GetClipboardTextFn_DefaultImpl(void*)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    return g.PrivateClipboard.empty() ? NULL : g.PrivateClipboard.begin();
}

// Local HanaLovesMe-only clipboard implementation, if user hasn't defined better clipboard handlers
static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
    HanaLovesMeContext& g = *GHanaLovesMe;
    g.PrivateClipboard.clear();
    const char* text_end = text + strlen(text);
    g.PrivateClipboard.resize((int)(text_end - text) + 1);
    memcpy(&g.PrivateClipboard[0], text, (size_t)(text_end - text));
    g.PrivateClipboard[(int)(text_end - text)] = 0;
}

#endif

// Win32 API IME support (for Asian languages, etc.)
#if defined(_WIN32) && !defined(__GNUC__) && !defined(HanaLovesMe_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)

#include <imm.h>
#ifdef _MSC_VER
#pragma comment(lib, "imm32")
#endif

static void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)
{
    // Notify OS Input Method Editor of text input position
    if (HWND hwnd = (HWND)GHanaLovesMe->IO.ImeWindowHandle)
        if (HIMC himc = ::ImmGetContext(hwnd))
        {
            COMPOSITIONFORM cf;
            cf.ptCurrentPos.x = x;
            cf.ptCurrentPos.y = y;
            cf.dwStyle = CFS_FORCE_POSITION;
            ::ImmSetCompositionWindow(himc, &cf);
            ::ImmReleaseContext(hwnd, himc);
        }
}

#else

static void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}

#endif

//-----------------------------------------------------------------------------
// [SECTION] METRICS/DEBUG WINDOW
//-----------------------------------------------------------------------------

void HanaLovesMe::ShowMetricsWindow(bool* p_open)
{
    if (!HanaLovesMe::Begin("HanaLovesMe Metrics", p_open))
    {
        HanaLovesMe::End();
        return;
    }

    enum { RT_OuterRect, RT_OuterRectClipped, RT_InnerMainRect, RT_InnerClipRect, RT_ContentsRegionRect, RT_ContentsFullRect };
    static bool show_windows_begin_order = false;
    static bool show_windows_rects = false;
    static int  show_windows_rect_type = RT_ContentsRegionRect;
    static bool show_drawcmd_clip_rects = true;

    HanaLovesMeIO& io = HanaLovesMe::GetIO();
    HanaLovesMe::Text("Dear HanaLovesMe %s", HanaLovesMe::GetVersion());
    HanaLovesMe::Text("Application avehnly %.3f ms/frame (%.1f FPS)", 1000.0f / io.Framerate, io.Framerate);
    HanaLovesMe::Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);
    HanaLovesMe::Text("%d active windows (%d visible)", io.MetricsActiveWindows, io.MetricsRenderWindows);
    HanaLovesMe::Text("%d active allocations", io.MetricsActiveAllocations);
    HanaLovesMe::Separator();

    struct Funcs
    {
        static void NodeDrawList(HanaLovesMeWindow* window, ImDrawList* draw_list, const char* label)
        {
            bool node_open = HanaLovesMe::TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);
            if (draw_list == HanaLovesMe::GetWindowDrawList())
            {
                HanaLovesMe::SameLine();
                HanaLovesMe::TextColored(xuifloatcolor(1.0f, 0.4f, 0.4f, 1.0f), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
                if (node_open) HanaLovesMe::TreePop();
                return;
            }

            ImDrawList* fg_draw_list = GetForegroundDrawList(window); // Render additional visuals into the top-most draw list
            if (window && IsItemHovered())
                fg_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
            if (!node_open)
                return;

            int elem_offset = 0;
            for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)
            {
                if (pcmd->UserCallback == NULL && pcmd->ElemCount == 0)
                    continue;
                if (pcmd->UserCallback)
                {
                    HanaLovesMe::BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
                    continue;
                }
                ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
                bool pcmd_node_open = HanaLovesMe::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "Draw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0f)", pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? "indexed" : "non-indexed", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
                if (show_drawcmd_clip_rects && fg_draw_list && HanaLovesMe::IsItemHovered())
                {
                    vsrect clip_rect = pcmd->ClipRect;
                    vsrect vtxs_rect;
                    for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)
                        vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);
                    clip_rect.Floor(); fg_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255, 255, 0, 255));
                    vtxs_rect.Floor(); fg_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255, 0, 255, 255));
                }
                if (!pcmd_node_open)
                    continue;

                // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
                HanaLovesMeListClipper clipper(pcmd->ElemCount / 3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
                while (clipper.Step())
                    for (int prim = clipper.DisplayStart, idx_i = elem_offset + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; prim++)
                    {
                        char buf[300];
                        char* buf_p = buf, * buf_end = buf + IM_ARRAYSIZE(buf);
                        vsize triangles_pos[3];
                        for (int n = 0; n < 3; n++, idx_i++)
                        {
                            int vtx_i = idx_buffer ? idx_buffer[idx_i] : idx_i;
                            ImDrawVert& v = draw_list->VtxBuffer[vtx_i];
                            triangles_pos[n] = v.pos;
                            buf_p += ImFormatString(buf_p, buf_end - buf_p, "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n",
                                (n == 0) ? "idx" : "   ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
                        }
                        HanaLovesMe::Selectable(buf, false);
                        if (fg_draw_list && HanaLovesMe::IsItemHovered())
                        {
                            ImDrawListFlags backup_flags = fg_draw_list->Flags;
                            fg_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines at is more readable for very large and thin triangles.
                            fg_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255, 255, 0, 255), true, 1.0f);
                            fg_draw_list->Flags = backup_flags;
                        }
                    }
                HanaLovesMe::TreePop();
            }
            HanaLovesMe::TreePop();
        }

        static void NodeColumns(const HanaLovesMeColumns * columns)
        {
            if (!HanaLovesMe::TreeNode((void*)(uintptr_t)columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags))
                return;
            HanaLovesMe::BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns->MaxX - columns->MinX, columns->MinX, columns->MaxX);
            for (int column_n = 0; column_n < columns->Columns.Size; column_n++)
                HanaLovesMe::BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", column_n, columns->Columns[column_n].OffsetNorm, OffsetNormToPixels(columns, columns->Columns[column_n].OffsetNorm));
            HanaLovesMe::TreePop();
        }

        static void NodeWindows(ImVector<HanaLovesMeWindow*> & windows, const char* label)
        {
            if (!HanaLovesMe::TreeNode(label, "%s (%d)", label, windows.Size))
                return;
            for (int i = 0; i < windows.Size; i++)
                Funcs::NodeWindow(windows[i], "Window");
            HanaLovesMe::TreePop();
        }

        static void NodeWindow(HanaLovesMeWindow * window, const char* label)
        {
            if (!HanaLovesMe::TreeNode(window, "%s '%s', %d @ 0x%p", label, window->Name, window->Active || window->WasActive, window))
                return;
            HanaLovesMeWindowFlags flags = window->Flags;
            NodeDrawList(window, window->DrawList, "DrawList");
            HanaLovesMe::BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);
            HanaLovesMe::BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags,
                (flags & HanaLovesMeWindowFlags_ChildWindow) ? "Child " : "", (flags & HanaLovesMeWindowFlags_Tooltip) ? "Tooltip " : "", (flags & HanaLovesMeWindowFlags_Popup) ? "Popup " : "",
                (flags & HanaLovesMeWindowFlags_Modal) ? "Modal " : "", (flags & HanaLovesMeWindowFlags_ChildMenu) ? "ChildMenu " : "", (flags & HanaLovesMeWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "",
                (flags & HanaLovesMeWindowFlags_NoMouseInputs) ? "NoMouseInputs" : "", (flags & HanaLovesMeWindowFlags_NoNavInputs) ? "NoNavInputs" : "", (flags & HanaLovesMeWindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "");
            HanaLovesMe::BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f)", window->Scroll.x, GetWindowScrollMaxX(window), window->Scroll.y, GetWindowScrollMaxY(window));
            HanaLovesMe::BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window->Active, window->WasActive, window->WriteAccessed, (window->Active || window->WasActive) ? window->BeginOrderWithinContext : -1);
            HanaLovesMe::BulletText("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d", window->Appearing, window->Hidden, window->HiddenFramesCanSkipItems, window->HiddenFramesCannotSkipItems, window->SkipItems);
            HanaLovesMe::BulletText("NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X", window->NavLastIds[0], window->NavLastIds[1], window->DC.NavLayerActiveMask);
            HanaLovesMe::BulletText("NavLastChildNavWindow: %s", window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL");
            if (!window->NavRectRel[0].IsInverted())
                HanaLovesMe::BulletText("NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)", window->NavRectRel[0].Min.x, window->NavRectRel[0].Min.y, window->NavRectRel[0].Max.x, window->NavRectRel[0].Max.y);
            else
                HanaLovesMe::BulletText("NavRectRel[0]: <None>");
            if (window->RootWindow != window) NodeWindow(window->RootWindow, "RootWindow");
            if (window->ParentWindow != NULL) NodeWindow(window->ParentWindow, "ParentWindow");
            if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, "ChildWindows");
            if (window->ColumnsStohnly.Size > 0 && HanaLovesMe::TreeNode("Columns", "Columns sets (%d)", window->ColumnsStohnly.Size))
            {
                for (int n = 0; n < window->ColumnsStohnly.Size; n++)
                    NodeColumns(&window->ColumnsStohnly[n]);
                HanaLovesMe::TreePop();
            }
            HanaLovesMe::BulletText("Stohnly: %d bytes", window->StateStohnly.Data.Size * (int)sizeof(HanaLovesMeStohnly::Pair));
            HanaLovesMe::TreePop();
        }

        static void NodeTabBar(HanaLovesMeTabBar * tab_bar)
        {
            // Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
            char buf[256];
            char* p = buf;
            const char* buf_end = buf + IM_ARRAYSIZE(buf);
            ImFormatString(p, buf_end - p, "TabBar (%d tabs)%s", tab_bar->Tabs.Size, (tab_bar->PrevFrameVisible < HanaLovesMe::GetFrameCount() - 2) ? " *Inactive*" : "");
            if (HanaLovesMe::TreeNode(tab_bar, "%s", buf))
            {
                for (int tab_n = 0; tab_n < tab_bar->Tabs.Size; tab_n++)
                {
                    const HanaLovesMeTabItem* tab = &tab_bar->Tabs[tab_n];
                    HanaLovesMe::PushID(tab);
                    if (HanaLovesMe::SmallButton("<")) { TabBarQueueChangeTabOrder(tab_bar, tab, -1); } HanaLovesMe::SameLine(0, 2);
                    if (HanaLovesMe::SmallButton(">")) { TabBarQueueChangeTabOrder(tab_bar, tab, +1); } HanaLovesMe::SameLine();
                    HanaLovesMe::Text("%02d%c Tab 0x%08X", tab_n, (tab->ID == tab_bar->SelectedTabId) ? '*' : ' ', tab->ID);
                    HanaLovesMe::PopID();
                }
                HanaLovesMe::TreePop();
            }
        }
    };

    // Access private state, we are going to display the draw lists from last frame
    HanaLovesMeContext& g = *GHanaLovesMe;
    Funcs::NodeWindows(g.Windows, "Windows");
    if (HanaLovesMe::TreeNode("DrawList", "Active DrawLists (%d)", g.DrawDataBuilder.Layers[0].Size))
    {
        for (int i = 0; i < g.DrawDataBuilder.Layers[0].Size; i++)
            Funcs::NodeDrawList(NULL, g.DrawDataBuilder.Layers[0][i], "DrawList");
        HanaLovesMe::TreePop();
    }

    if (HanaLovesMe::TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size))
    {
        for (int i = 0; i < g.OpenPopupStack.Size; i++)
        {
            HanaLovesMeWindow* window = g.OpenPopupStack[i].Window;
            HanaLovesMe::BulletText("PopupID: %08x, Window: '%s'%s%s", g.OpenPopupStack[i].PopupId, window ? window->Name : "NULL", window && (window->Flags & HanaLovesMeWindowFlags_ChildWindow) ? " ChildWindow" : "", window && (window->Flags & HanaLovesMeWindowFlags_ChildMenu) ? " ChildMenu" : "");
        }
        HanaLovesMe::TreePop();
    }

    if (HanaLovesMe::TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.Data.Size))
    {
        for (int n = 0; n < g.TabBars.Data.Size; n++)
            Funcs::NodeTabBar(g.TabBars.GetByIndex(n));
        HanaLovesMe::TreePop();
    }

    if (HanaLovesMe::TreeNode("Internal state"))
    {
        const char* input_source_names[] = { "None", "Mouse", "Nav", "NavKeyboard", "NavGamepad" }; IM_ASSERT(IM_ARRAYSIZE(input_source_names) == HanaLovesMeInputSource_COUNT);
        HanaLovesMe::Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");
        HanaLovesMe::Text("HoveredRootWindow: '%s'", g.HoveredRootWindow ? g.HoveredRootWindow->Name : "NULL");
        HanaLovesMe::Text("HoveredId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Data is "in-flight" so depending on when the Metrics window is called we may see current frame information or not
        HanaLovesMe::Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, input_source_names[g.ActiveIdSource]);
        HanaLovesMe::Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");
        HanaLovesMe::Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");
        HanaLovesMe::Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");
        HanaLovesMe::Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
        HanaLovesMe::Text("NavInputSource: %s", input_source_names[g.NavInputSource]);
        HanaLovesMe::Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
        HanaLovesMe::Text("NavActivateId: 0x%08X, NavInputId: 0x%08X", g.NavActivateId, g.NavInputId);
        HanaLovesMe::Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);
        HanaLovesMe::Text("NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget->Name : "NULL");
        HanaLovesMe::Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
        HanaLovesMe::TreePop();
    }

    if (HanaLovesMe::TreeNode("Tools"))
    {
        HanaLovesMe::Checkbox("Show windows begin order", &show_windows_begin_order);
        HanaLovesMe::Checkbox("Show windows rectangles", &show_windows_rects);
        HanaLovesMe::SameLine();
        HanaLovesMe::PushItemWidth(HanaLovesMe::GetFontSize() * 12);
        show_windows_rects |= HanaLovesMe::Combo("##rects_type", &show_windows_rect_type, "OuterRect\0" "OuterRectClipped\0" "InnerMainRect\0" "InnerClipRect\0" "ContentsRegionRect\0");
        HanaLovesMe::PopItemWidth();
        HanaLovesMe::Checkbox("Show clipping rectangle when hovering ImDrawCmd node", &show_drawcmd_clip_rects);
        HanaLovesMe::TreePop();
    }

    if (show_windows_rects || show_windows_begin_order)
    {
        for (int n = 0; n < g.Windows.Size; n++)
        {
            HanaLovesMeWindow* window = g.Windows[n];
            if (!window->WasActive)
                continue;
            ImDrawList* draw_list = GetForegroundDrawList(window);
            if (show_windows_rects)
            {
                vsrect r;
                if (show_windows_rect_type == RT_OuterRect) { r = window->Rect(); } else if (show_windows_rect_type == RT_OuterRectClipped) { r = window->OuterRectClipped; } else if (show_windows_rect_type == RT_InnerMainRect) { r = window->InnerMainRect; } else if (show_windows_rect_type == RT_InnerClipRect) { r = window->InnerClipRect; } else if (show_windows_rect_type == RT_ContentsRegionRect) { r = window->ContentsRegionRect; }
                draw_list->AddRect(r.Min, r.Max, IM_COL32(255, 0, 128, 255));
            }
            if (show_windows_begin_order && !(window->Flags & HanaLovesMeWindowFlags_ChildWindow))
            {
                char buf[32];
                ImFormatString(buf, IM_ARRAYSIZE(buf), "%d", window->BeginOrderWithinContext);
                float font_size = HanaLovesMe::GetFontSize();
                draw_list->AddRectFilled(window->Pos, window->Pos + vsize(font_size, font_size), IM_COL32(200, 100, 100, 255));
                draw_list->AddText(window->Pos, IM_COL32(255, 255, 255, 255), buf);
            }
        }
    }
    HanaLovesMe::End();
}

//-----------------------------------------------------------------------------

// Include HanaLovesMe_user.inl at the end of HanaLovesMe.cpp to access private data/functions that aren't exposed.
// Prefer just including HanaLovesMe_internal.h from your code rather than using this define. If a declaration is missing from HanaLovesMe_internal.h add it or request it on the github.
#ifdef HanaLovesMe_INCLUDE_HanaLovesMe_USER_INL
#include "HanaLovesMe_user.inl"
#endif

//-----------------------------------------------------------------------------


















































































// Junk Code By Troll Face & Thaisen's Gen
void ucQHAErfcHmfMKrCkPZBcvMsHXHhjaxmtwNMgBYvPYmymwnYyIWzXyizPXAcwJvBKAmPxeVjqdmEINGKjjjbExOuONxIB68079908() {     long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi81943569 = 31715990;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi43272691 = -556656729;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi8994069 = -486053571;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi13487705 = -326420033;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi51900884 = -689681350;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi75256072 = -289911419;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi84055697 = -948259995;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi30434566 = -94398607;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi74986047 = -841628298;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi30475980 = -498111527;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi94861464 = -579359565;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi35172013 = -594939080;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44611323 = -761553033;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi23945041 = -139275280;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi27230571 = -225327191;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi89898295 = -961817563;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi78710537 = -603737929;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi84488150 = -952806712;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi95137664 = -331453684;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi89773979 = -777423594;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56871525 = -35047569;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi70794100 = -596805005;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi88404556 = -687713218;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi43074676 = -715832353;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi89674987 = -722584609;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi76338170 = -644015695;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi93910920 = -38885277;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi4028712 = -852733269;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi91262804 = -994224757;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi49949280 = -957760930;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi63051029 = -851889901;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi23312341 = -999323221;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi84854402 = -833798545;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi13715000 = -813448377;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi54630544 = -430500832;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi28439562 = -286826229;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi61727739 = -657332198;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi57574594 = -89545197;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi73331490 = -926622564;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi37978897 = 96769538;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi32980525 = -532641956;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi91289365 = -983513473;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi97884670 = 91927018;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi70360142 = -374315702;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi98832280 = -942348616;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44109973 = -595775221;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi71200257 = -184555158;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi16036900 = -389344068;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi60025551 = -699216273;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56381342 = -415211242;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi85689450 = -813773143;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi15860298 = -473899640;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi39486167 = -867219373;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi71190882 = -90289302;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi11208384 = -564837701;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi11149469 = -371479005;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi54868135 = -868943511;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi65919393 = -770221218;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi23812717 = -603835424;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi75562714 = 54334345;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi81345151 = -151026143;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi80026985 = 4473273;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi39171762 = -100173851;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi25036767 = -883867368;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi67424950 = -646221627;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi71549123 = -580036345;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi50317611 = -761140536;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi30896323 = -948104657;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi69314497 = -708774448;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi98791008 = -938500963;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi28170556 = -204485366;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi21135944 = -414192732;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi11156661 = 73815852;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi57158767 = -328223222;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56793454 = -144781639;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi65582159 = -51534096;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi72909429 = -588732024;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi18044415 = -213397517;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44242396 = -773483738;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi45565014 = -26809389;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi5137913 = -359460538;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi77874021 = -649541209;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44003161 = -53516996;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi34881463 = -479013515;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi64259829 = -43987787;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi47190732 = -277990261;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi83826174 = -32103848;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi13663520 = -643509244;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi2506616 = -148610676;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi43481075 = 40978172;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi73571427 = -417882718;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi95808346 = -887110980;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi33761878 = -485709773;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi97768776 = -880956910;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56633745 = -752204320;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi52953539 = -437115229;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi52117604 = -783339623;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi72847904 = -24205614;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi2935192 = -728094075;    long wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi27283158 = 31715990;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi81943569 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi43272691;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi43272691 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi8994069;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi8994069 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi13487705;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi13487705 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi51900884;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi51900884 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi75256072;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi75256072 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi84055697;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi84055697 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi30434566;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi30434566 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi74986047;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi74986047 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi30475980;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi30475980 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi94861464;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi94861464 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi35172013;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi35172013 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44611323;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44611323 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi23945041;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi23945041 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi27230571;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi27230571 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi89898295;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi89898295 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi78710537;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi78710537 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi84488150;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi84488150 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi95137664;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi95137664 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi89773979;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi89773979 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56871525;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56871525 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi70794100;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi70794100 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi88404556;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi88404556 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi43074676;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi43074676 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi89674987;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi89674987 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi76338170;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi76338170 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi93910920;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi93910920 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi4028712;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi4028712 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi91262804;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi91262804 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi49949280;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi49949280 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi63051029;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi63051029 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi23312341;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi23312341 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi84854402;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi84854402 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi13715000;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi13715000 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi54630544;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi54630544 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi28439562;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi28439562 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi61727739;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi61727739 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi57574594;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi57574594 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi73331490;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi73331490 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi37978897;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi37978897 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi32980525;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi32980525 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi91289365;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi91289365 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi97884670;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi97884670 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi70360142;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi70360142 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi98832280;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi98832280 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44109973;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44109973 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi71200257;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi71200257 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi16036900;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi16036900 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi60025551;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi60025551 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56381342;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56381342 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi85689450;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi85689450 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi15860298;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi15860298 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi39486167;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi39486167 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi71190882;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi71190882 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi11208384;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi11208384 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi11149469;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi11149469 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi54868135;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi54868135 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi65919393;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi65919393 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi23812717;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi23812717 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi75562714;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi75562714 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi81345151;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi81345151 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi80026985;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi80026985 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi39171762;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi39171762 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi25036767;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi25036767 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi67424950;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi67424950 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi71549123;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi71549123 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi50317611;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi50317611 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi30896323;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi30896323 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi69314497;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi69314497 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi98791008;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi98791008 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi28170556;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi28170556 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi21135944;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi21135944 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi11156661;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi11156661 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi57158767;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi57158767 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56793454;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56793454 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi65582159;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi65582159 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi72909429;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi72909429 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi18044415;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi18044415 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44242396;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44242396 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi45565014;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi45565014 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi5137913;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi5137913 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi77874021;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi77874021 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44003161;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi44003161 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi34881463;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi34881463 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi64259829;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi64259829 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi47190732;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi47190732 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi83826174;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi83826174 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi13663520;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi13663520 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi2506616;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi2506616 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi43481075;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi43481075 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi73571427;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi73571427 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi95808346;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi95808346 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi33761878;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi33761878 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi97768776;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi97768776 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56633745;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi56633745 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi52953539;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi52953539 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi52117604;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi52117604 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi72847904;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi72847904 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi2935192;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi2935192 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi27283158;     wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi27283158 = wyGckomKYbTmnJtMdqBRptNZUxNlsBjhNhuefcYZUALHQoQoUhlXvrLDlgHmbASXrmZFPPhBScwphFJfhYRKPMlVVrtyUlyUi81943569;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void PZfoMizeicwtLkNRVuxZAAxKeSSkDlIOExWenjJIjvzojRawtvWcpDDPbVKuPOaxTioNOiemkoqFAIaMsWrIPgZBtGDSY86623447() {     long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt10727007 = -283946248;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt51719477 = -19069228;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt45983141 = -951322799;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt89924875 = -334658288;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt92410639 = -192468923;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt94391508 = -739265048;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt2541648 = -90815103;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt84820956 = -385165721;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt28481501 = -849880348;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt77029160 = -324493241;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt85986712 = -103590937;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt49904376 = -131611600;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt30764698 = -771332444;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt64449722 = -660615110;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt3033070 = -374941394;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt61084468 = -352532975;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt28483418 = -803097697;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt20743544 = -433618743;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt76785475 = -662299273;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt33580629 = -473667892;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt58006948 = -966959823;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt9985096 = -931504551;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt92638829 = -599816836;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt20002974 = -969537455;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt63941019 = -236017769;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt47013449 = -429022555;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt11597319 = -512925053;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt25914862 = -423603280;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt124669 = -22555338;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt47437082 = -855284187;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt62853493 = -327867811;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt40151015 = -894843534;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt46189836 = -100097324;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt61500454 = -601611470;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt81211155 = -669616233;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt96330393 = 93379716;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt67578798 = -785408135;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt55093866 = 80650625;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt6870516 = -342253176;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt35360530 = -706947071;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt98525715 = -79584670;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt90800154 = -43681791;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt90734917 = -77755161;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt12502581 = -213783250;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt14810766 = 88752627;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt68810336 = -358641200;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt58439768 = -771082626;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt87663767 = 80825230;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt67188286 = -948852028;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt66917587 = 30762711;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt97092729 = -956014071;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt96526199 = -399238717;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt97318970 = -131105240;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt48702154 = -444736056;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt28616499 = -274314421;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt741911 = -352441698;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt59080648 = -419252392;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt25980168 = -981785344;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt25983856 = 1359481;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt45397191 = -763446369;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt82794190 = -126339995;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt76626785 = -667211823;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt84696287 = -262610383;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt81044419 = -994596162;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt14175667 = -996625431;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt45835697 = -208747404;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt3714541 = 68485724;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt69264243 = -69720975;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt83238567 = -990998878;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt6702676 = -368321110;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt93505670 = -567124840;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt73389551 = -783748322;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt13873028 = 8634433;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt41424945 = -955352203;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt35054913 = -294083222;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt67206794 = -823278033;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt19250178 = -753749391;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt80136248 = -286033587;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt5192208 = -958290083;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt95130683 = -877376569;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt88573680 = -657939929;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt23933552 = -493750283;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt58726576 = -474751253;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt33207082 = 46681950;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt50344353 = -899270117;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt66327293 = -928629094;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt42832045 = -663738294;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt97487681 = -655361269;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt32883956 = -227297049;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt80469244 = -217174535;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt37249746 = -487367893;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt41598630 = -803622791;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt29110011 = -920708857;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt61473325 = -578806808;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt52566340 = -480607076;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt21898931 = -412372847;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt6103868 = -781071408;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt9690499 = -83159000;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt98326913 = -217157820;    long PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt68975069 = -283946248;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt10727007 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt51719477;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt51719477 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt45983141;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt45983141 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt89924875;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt89924875 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt92410639;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt92410639 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt94391508;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt94391508 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt2541648;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt2541648 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt84820956;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt84820956 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt28481501;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt28481501 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt77029160;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt77029160 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt85986712;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt85986712 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt49904376;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt49904376 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt30764698;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt30764698 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt64449722;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt64449722 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt3033070;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt3033070 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt61084468;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt61084468 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt28483418;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt28483418 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt20743544;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt20743544 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt76785475;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt76785475 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt33580629;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt33580629 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt58006948;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt58006948 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt9985096;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt9985096 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt92638829;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt92638829 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt20002974;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt20002974 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt63941019;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt63941019 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt47013449;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt47013449 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt11597319;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt11597319 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt25914862;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt25914862 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt124669;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt124669 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt47437082;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt47437082 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt62853493;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt62853493 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt40151015;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt40151015 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt46189836;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt46189836 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt61500454;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt61500454 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt81211155;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt81211155 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt96330393;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt96330393 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt67578798;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt67578798 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt55093866;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt55093866 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt6870516;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt6870516 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt35360530;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt35360530 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt98525715;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt98525715 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt90800154;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt90800154 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt90734917;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt90734917 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt12502581;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt12502581 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt14810766;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt14810766 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt68810336;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt68810336 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt58439768;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt58439768 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt87663767;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt87663767 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt67188286;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt67188286 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt66917587;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt66917587 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt97092729;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt97092729 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt96526199;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt96526199 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt97318970;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt97318970 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt48702154;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt48702154 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt28616499;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt28616499 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt741911;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt741911 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt59080648;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt59080648 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt25980168;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt25980168 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt25983856;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt25983856 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt45397191;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt45397191 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt82794190;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt82794190 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt76626785;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt76626785 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt84696287;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt84696287 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt81044419;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt81044419 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt14175667;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt14175667 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt45835697;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt45835697 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt3714541;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt3714541 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt69264243;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt69264243 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt83238567;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt83238567 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt6702676;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt6702676 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt93505670;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt93505670 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt73389551;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt73389551 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt13873028;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt13873028 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt41424945;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt41424945 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt35054913;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt35054913 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt67206794;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt67206794 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt19250178;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt19250178 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt80136248;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt80136248 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt5192208;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt5192208 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt95130683;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt95130683 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt88573680;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt88573680 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt23933552;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt23933552 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt58726576;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt58726576 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt33207082;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt33207082 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt50344353;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt50344353 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt66327293;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt66327293 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt42832045;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt42832045 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt97487681;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt97487681 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt32883956;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt32883956 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt80469244;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt80469244 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt37249746;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt37249746 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt41598630;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt41598630 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt29110011;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt29110011 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt61473325;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt61473325 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt52566340;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt52566340 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt21898931;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt21898931 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt6103868;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt6103868 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt9690499;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt9690499 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt98326913;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt98326913 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt68975069;     PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt68975069 = PsUUCUBcMiKQkrAMyPSuyCtXShnImTHfLNVvWlxoZjgngreoYpvrkXaNzxBUhspsbeFWWEqMReVOWFqaCykxYPvomIwYjdHgt10727007;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void HleSVsHfFemEnAPUYfJSdYxbeRnSyWoGllhdYoJyVSthKdTpqlwaiAWioDoEFphiqgSBTmvjVKwLfPQAxycMaNXkPzpVA35483414() {     double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO7243163 = -896484866;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO97516144 = 49540033;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO51008846 = -170861258;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO9933793 = -343201663;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO56642978 = -613878258;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO14235665 = -920076218;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO92082632 = -953464845;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO85666101 = -645961247;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91365675 = -695475067;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO32713940 = -714815018;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO36042525 = -99090139;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO57774974 = -832605325;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO20108939 = -496288871;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO54602725 = -997560119;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO85346772 = -244911678;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO86759018 = -494756365;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO28247887 = -806137457;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO95378765 = -302608997;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO98494316 = -842435440;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO38269007 = -77180496;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO25851091 = -222276234;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO61738720 = -504526302;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO63696593 = -101257626;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO22002690 = -988194598;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO77994682 = -98096602;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO64750775 = -654214853;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO74383212 = -189707043;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO463463 = -874875885;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO75981416 = -114898164;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO59646655 = -382345343;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO55241233 = -436289347;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO83539269 = 69061327;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO20908063 = -439221984;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO74018704 = 66219397;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO49516975 = -754624796;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO18587553 = -693814120;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO92165080 = -796005404;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO93262001 = -842850005;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO37948025 = -876981219;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO28941483 = -888579110;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO36868877 = -17154891;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO42144676 = -454226712;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO98135173 = -294462606;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO45094740 = -576934782;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO38788455 = -756772010;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46277378 = -234946661;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO41502964 = -808962963;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO80461999 = -327888091;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO26468159 = -148474292;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO29695914 = -525264301;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO42251685 = -696115773;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO61661209 = -240331093;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO1738175 = -426986880;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO29084215 = -78977134;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO9632323 = -828586575;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO45504443 = -291958564;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO33819551 = -849202342;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO29006157 = -182666660;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO31939111 = -145105062;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91892203 = -959663405;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO39852452 = -630369175;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91619170 = 21411040;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO9684685 = -431063083;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO31719021 = -213129725;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO77472706 = -178525672;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO52503255 = -68151466;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO36866912 = -293383341;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46090234 = -462508268;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO5085751 = -142935324;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO66759219 = -551097559;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO94593937 = -698750962;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO34985886 = -963287453;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO57430741 = -425627779;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO69552834 = -953856331;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO1400130 = 39974394;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO83706415 = -768049523;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO63603546 = -110063697;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO18601854 = -524322844;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO83214235 = -131422589;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO31717304 = -863149941;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO23247811 = -845251891;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO93921212 = -861818953;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO73995303 = -626401593;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46285502 = -589633863;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO17394971 = -686229570;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO93580024 = -95958254;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO81801094 = -503951793;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91823848 = -260244850;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO64386382 = -105194029;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO4012532 = -362666232;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO84768001 = -844611778;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO63158924 = -513338744;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO61322890 = -597744943;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46055821 = -917317814;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO89089030 = -158209935;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO45249706 = 61434068;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO32459992 = 76836371;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO66416153 = 18667119;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO67622034 = -298409111;    double FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO86285199 = -896484866;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO7243163 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO97516144;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO97516144 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO51008846;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO51008846 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO9933793;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO9933793 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO56642978;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO56642978 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO14235665;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO14235665 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO92082632;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO92082632 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO85666101;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO85666101 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91365675;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91365675 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO32713940;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO32713940 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO36042525;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO36042525 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO57774974;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO57774974 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO20108939;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO20108939 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO54602725;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO54602725 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO85346772;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO85346772 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO86759018;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO86759018 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO28247887;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO28247887 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO95378765;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO95378765 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO98494316;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO98494316 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO38269007;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO38269007 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO25851091;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO25851091 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO61738720;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO61738720 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO63696593;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO63696593 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO22002690;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO22002690 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO77994682;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO77994682 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO64750775;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO64750775 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO74383212;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO74383212 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO463463;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO463463 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO75981416;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO75981416 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO59646655;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO59646655 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO55241233;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO55241233 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO83539269;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO83539269 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO20908063;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO20908063 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO74018704;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO74018704 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO49516975;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO49516975 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO18587553;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO18587553 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO92165080;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO92165080 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO93262001;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO93262001 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO37948025;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO37948025 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO28941483;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO28941483 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO36868877;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO36868877 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO42144676;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO42144676 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO98135173;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO98135173 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO45094740;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO45094740 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO38788455;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO38788455 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46277378;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46277378 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO41502964;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO41502964 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO80461999;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO80461999 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO26468159;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO26468159 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO29695914;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO29695914 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO42251685;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO42251685 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO61661209;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO61661209 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO1738175;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO1738175 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO29084215;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO29084215 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO9632323;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO9632323 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO45504443;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO45504443 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO33819551;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO33819551 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO29006157;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO29006157 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO31939111;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO31939111 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91892203;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91892203 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO39852452;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO39852452 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91619170;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91619170 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO9684685;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO9684685 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO31719021;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO31719021 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO77472706;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO77472706 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO52503255;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO52503255 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO36866912;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO36866912 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46090234;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46090234 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO5085751;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO5085751 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO66759219;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO66759219 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO94593937;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO94593937 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO34985886;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO34985886 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO57430741;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO57430741 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO69552834;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO69552834 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO1400130;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO1400130 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO83706415;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO83706415 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO63603546;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO63603546 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO18601854;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO18601854 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO83214235;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO83214235 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO31717304;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO31717304 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO23247811;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO23247811 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO93921212;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO93921212 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO73995303;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO73995303 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46285502;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46285502 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO17394971;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO17394971 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO93580024;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO93580024 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO81801094;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO81801094 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91823848;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO91823848 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO64386382;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO64386382 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO4012532;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO4012532 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO84768001;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO84768001 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO63158924;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO63158924 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO61322890;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO61322890 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46055821;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO46055821 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO89089030;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO89089030 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO45249706;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO45249706 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO32459992;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO32459992 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO66416153;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO66416153 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO67622034;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO67622034 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO86285199;     FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO86285199 = FtglKqeKSWDqMFXELCYmnHGNUIcIimUxZjPRPZVZmqecYWOIAfDwQjMxmTRCOVcfBGQdpFomgzzxceoyuTICjXgqWSfwITKQO7243163;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void EYIeJjBQdikSpQOOLmfWqhRTqsfnGrSvXizyntdMvVfOdBxwbSbOukXXHpoQENJmPovGRPbRJTaVBCpovjLnQEBnLbrxF54026952() {     double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk36026599 = -112147104;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk5962931 = -512872466;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87997918 = -636130486;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk86370963 = -351439918;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk97152733 = -116665831;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk33371101 = -269429847;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk10568583 = -96019952;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk40052491 = -936728361;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk44861130 = -703727117;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk79267120 = -541196732;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk27167773 = -723321511;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk72507337 = -369277845;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk6262314 = -506068282;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk95107406 = -418899950;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk61149271 = -394525880;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk57945191 = -985471777;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk78020768 = 94502775;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk31634158 = -883421028;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk80142127 = -73281030;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk82075657 = -873424794;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk26986515 = -54188488;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk929716 = -839225848;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk67930866 = -13361244;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk98930987 = -141899701;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk52260714 = -711529762;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk35426054 = -439221712;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk92069610 = -663746820;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk22349613 = -445745897;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk84843280 = -243228746;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk57134457 = -279868600;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk55043697 = 87732743;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk377944 = -926458986;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk82243496 = -805520763;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk21804160 = -821943696;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk76097586 = -993740196;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk86478384 = -313608175;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk98016139 = -924081341;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk90781273 = -672654183;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk71487050 = -292611831;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk26323116 = -592295719;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk2414069 = -664097605;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk41655465 = -614395029;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk90985420 = -464144785;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87237179 = -416402331;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk54766940 = -825670767;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk70977741 = 2187359;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk28742476 = -295490431;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk52088867 = -957718794;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk33630894 = -398110047;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk40232159 = -79290348;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk53654963 = -838356701;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk42327111 = -165670170;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk59570979 = -790872748;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk6595488 = -433423888;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk27040438 = -538063294;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk35096884 = -272921257;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk38032065 = -399511223;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk89066931 = -394230786;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk34110250 = -639910157;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk61726680 = -677444119;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk41301491 = -605683028;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk88218970 = -650274056;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk55209210 = -593499616;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87726673 = -323858518;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk24223423 = -528929476;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk26789830 = -796862525;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk90263841 = -563757082;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk84458154 = -684124586;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk19009821 = -425159754;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk74670887 = 19082294;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk59929052 = 38609564;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87239494 = -232843043;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk60147107 = -490809197;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk53819012 = -480985311;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk79661588 = -109327190;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk85331049 = -439793460;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk9944295 = -275081063;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk80693687 = -596958914;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk44164048 = -316228934;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk81282973 = -613717122;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk6683579 = -43731282;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk39980743 = -706028027;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk88718718 = 52364150;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk44611122 = -63938398;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk3479495 = -441511899;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk12716586 = -746597087;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk40806965 = -35586239;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk75648009 = -272096875;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk94763721 = -183880402;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk41000702 = -620818940;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk48446320 = -914096953;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk8949208 = -429850556;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk56671023 = 67255974;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk9760371 = -615167712;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk85021625 = -986612692;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk14195098 = 86176451;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk86446254 = 79104586;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk3258748 = -40286267;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk63013756 = -887472855;    double MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk27977111 = -112147104;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk36026599 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk5962931;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk5962931 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87997918;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87997918 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk86370963;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk86370963 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk97152733;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk97152733 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk33371101;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk33371101 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk10568583;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk10568583 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk40052491;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk40052491 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk44861130;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk44861130 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk79267120;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk79267120 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk27167773;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk27167773 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk72507337;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk72507337 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk6262314;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk6262314 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk95107406;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk95107406 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk61149271;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk61149271 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk57945191;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk57945191 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk78020768;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk78020768 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk31634158;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk31634158 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk80142127;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk80142127 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk82075657;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk82075657 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk26986515;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk26986515 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk929716;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk929716 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk67930866;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk67930866 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk98930987;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk98930987 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk52260714;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk52260714 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk35426054;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk35426054 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk92069610;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk92069610 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk22349613;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk22349613 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk84843280;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk84843280 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk57134457;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk57134457 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk55043697;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk55043697 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk377944;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk377944 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk82243496;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk82243496 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk21804160;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk21804160 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk76097586;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk76097586 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk86478384;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk86478384 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk98016139;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk98016139 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk90781273;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk90781273 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk71487050;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk71487050 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk26323116;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk26323116 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk2414069;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk2414069 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk41655465;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk41655465 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk90985420;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk90985420 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87237179;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87237179 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk54766940;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk54766940 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk70977741;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk70977741 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk28742476;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk28742476 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk52088867;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk52088867 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk33630894;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk33630894 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk40232159;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk40232159 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk53654963;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk53654963 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk42327111;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk42327111 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk59570979;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk59570979 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk6595488;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk6595488 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk27040438;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk27040438 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk35096884;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk35096884 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk38032065;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk38032065 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk89066931;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk89066931 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk34110250;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk34110250 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk61726680;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk61726680 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk41301491;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk41301491 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk88218970;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk88218970 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk55209210;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk55209210 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87726673;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87726673 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk24223423;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk24223423 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk26789830;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk26789830 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk90263841;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk90263841 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk84458154;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk84458154 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk19009821;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk19009821 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk74670887;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk74670887 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk59929052;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk59929052 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87239494;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk87239494 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk60147107;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk60147107 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk53819012;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk53819012 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk79661588;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk79661588 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk85331049;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk85331049 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk9944295;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk9944295 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk80693687;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk80693687 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk44164048;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk44164048 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk81282973;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk81282973 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk6683579;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk6683579 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk39980743;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk39980743 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk88718718;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk88718718 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk44611122;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk44611122 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk3479495;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk3479495 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk12716586;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk12716586 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk40806965;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk40806965 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk75648009;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk75648009 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk94763721;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk94763721 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk41000702;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk41000702 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk48446320;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk48446320 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk8949208;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk8949208 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk56671023;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk56671023 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk9760371;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk9760371 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk85021625;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk85021625 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk14195098;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk14195098 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk86446254;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk86446254 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk3258748;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk3258748 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk63013756;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk63013756 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk27977111;     MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk27977111 = MIhLtzpGrfMqJEaJCVEzzVVCVVLnIvpYdMwLsJICAiEDzxGzadJGmyFrnfpXnBxvpoMwIPQsNCyQQRCYOMMemjlfGFYNUkOyk36026599;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void ZBsMCKIrmWFsWWLUeqynxYHHeiOGznwpJHdPorHNdfnidDmGparRDOaAtkhTwCsyZQiPswgmikJSlZebvHRYvflvgdVEK2886919() {     float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX32542756 = -724685721;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX51759598 = -444263206;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX93023623 = -955668945;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX6379882 = -359983294;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX61385072 = -538075166;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX53215257 = -450241018;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX109569 = -958669694;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40897636 = -97523886;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX7745305 = -549321836;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX34951900 = -931518510;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX77223586 = -718820712;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX80377935 = 29728431;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX95606554 = -231024708;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX85260409 = -755844959;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX43462974 = -264496164;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX83619741 = -27695167;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX77785237 = 91463015;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX6269380 = -752411282;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX1850969 = -253417197;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX86764034 = -476937399;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX94830657 = -409504899;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX52683340 = -412247599;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX38988630 = -614802034;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX930704 = -160556844;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX66314376 = -573608595;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX53163380 = -664414011;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX54855504 = -340528810;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX96898212 = -897018501;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX60700028 = -335571571;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX69344029 = -906929755;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX47431437 = -20688793;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX43766198 = 37445874;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX56961723 = -44645423;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX34322409 = -154112830;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX44403406 = 21251240;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX8735544 = -802010;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX22602422 = -934678610;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX28949408 = -496154812;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX2564559 = -827339873;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX19904069 = -773927758;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40757229 = -601667826;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX92999986 = 75060050;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX98385676 = -680852230;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX19829338 = -779553863;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX78744629 = -571195404;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX48444783 = -974118101;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX11805672 = -333370768;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX44887100 = -266432115;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX92910767 = -697732311;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3010487 = -635317360;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX98813918 = -578458404;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX7462121 = -6762546;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX63990183 = 13245612;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX86977547 = -67664967;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX8056261 = 7664552;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX79859416 = -212438123;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX12770968 = -829461173;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX92092919 = -695112102;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40065506 = -786374700;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX8221693 = -873661156;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX98359752 = -9712208;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3211356 = 38348807;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX80197607 = -761952316;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX38401275 = -642392081;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX87520462 = -810829718;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX33457388 = -656266587;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX23416213 = -925626147;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX61284145 = 23088121;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40857004 = -677096200;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX34727431 = -163694154;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX61017319 = -93016557;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX48835829 = -412382173;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3704821 = -925071409;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX81946900 = -479489439;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX46006805 = -875269573;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX1830671 = -384564950;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX54297663 = -731395369;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX19159292 = -835248171;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX22186075 = -589361440;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX17869593 = -599490494;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX41357708 = -231043243;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX9968405 = 25903304;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3987445 = -99286191;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX57689542 = -700254211;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX70530111 = -228471352;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX39969317 = 86073753;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX79776015 = -975799738;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX69984176 = -976980457;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX26266148 = -61777382;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX64543989 = -766310637;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX95964575 = -171340838;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX30509502 = -139566509;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX88883902 = -709780113;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX94342865 = -953678718;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX21544316 = -664215551;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX37545874 = -540016634;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX12802380 = -162987635;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX59984401 = 61539851;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX32308876 = -968724146;    float nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX45287241 = -724685721;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX32542756 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX51759598;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX51759598 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX93023623;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX93023623 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX6379882;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX6379882 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX61385072;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX61385072 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX53215257;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX53215257 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX109569;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX109569 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40897636;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40897636 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX7745305;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX7745305 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX34951900;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX34951900 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX77223586;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX77223586 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX80377935;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX80377935 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX95606554;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX95606554 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX85260409;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX85260409 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX43462974;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX43462974 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX83619741;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX83619741 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX77785237;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX77785237 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX6269380;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX6269380 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX1850969;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX1850969 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX86764034;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX86764034 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX94830657;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX94830657 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX52683340;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX52683340 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX38988630;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX38988630 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX930704;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX930704 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX66314376;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX66314376 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX53163380;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX53163380 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX54855504;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX54855504 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX96898212;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX96898212 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX60700028;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX60700028 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX69344029;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX69344029 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX47431437;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX47431437 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX43766198;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX43766198 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX56961723;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX56961723 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX34322409;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX34322409 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX44403406;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX44403406 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX8735544;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX8735544 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX22602422;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX22602422 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX28949408;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX28949408 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX2564559;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX2564559 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX19904069;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX19904069 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40757229;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40757229 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX92999986;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX92999986 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX98385676;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX98385676 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX19829338;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX19829338 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX78744629;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX78744629 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX48444783;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX48444783 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX11805672;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX11805672 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX44887100;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX44887100 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX92910767;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX92910767 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3010487;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3010487 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX98813918;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX98813918 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX7462121;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX7462121 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX63990183;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX63990183 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX86977547;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX86977547 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX8056261;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX8056261 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX79859416;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX79859416 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX12770968;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX12770968 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX92092919;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX92092919 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40065506;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40065506 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX8221693;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX8221693 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX98359752;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX98359752 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3211356;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3211356 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX80197607;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX80197607 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX38401275;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX38401275 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX87520462;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX87520462 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX33457388;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX33457388 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX23416213;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX23416213 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX61284145;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX61284145 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40857004;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX40857004 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX34727431;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX34727431 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX61017319;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX61017319 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX48835829;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX48835829 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3704821;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3704821 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX81946900;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX81946900 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX46006805;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX46006805 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX1830671;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX1830671 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX54297663;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX54297663 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX19159292;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX19159292 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX22186075;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX22186075 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX17869593;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX17869593 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX41357708;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX41357708 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX9968405;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX9968405 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3987445;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX3987445 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX57689542;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX57689542 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX70530111;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX70530111 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX39969317;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX39969317 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX79776015;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX79776015 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX69984176;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX69984176 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX26266148;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX26266148 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX64543989;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX64543989 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX95964575;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX95964575 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX30509502;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX30509502 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX88883902;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX88883902 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX94342865;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX94342865 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX21544316;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX21544316 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX37545874;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX37545874 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX12802380;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX12802380 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX59984401;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX59984401 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX32308876;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX32308876 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX45287241;     nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX45287241 = nQbmoIMUXOsuEiTEIOUFGXolTDufmiPabcuUifxRSGYtYerwSrXOByDQbqTlNhipzSSbnzVdRCnAzvMpLyNuKAYdZessLLDlX32542756;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void mCTbjjnppSsjoWSzEohEiYHTFzyfIivsccnsaDIQNIAgtEPCVLNTWHJNuAVjkIgHXzGMiZYBfQqZXaZAkvKxUbWVSayah21430458() {     float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq61326192 = 59652041;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq60206384 = 93324295;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq30012697 = -320938173;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq82817052 = -368221549;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq1894828 = -40862739;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq72350693 = -899594646;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18595518 = -101224802;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq95284025 = -388291000;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq61240759 = -557573886;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq81505079 = -757900223;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq68348834 = -243052085;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq95110298 = -606944089;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq81759929 = -240804119;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq25765091 = -177184789;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq19265473 = -414110367;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq54805915 = -518410578;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq27558118 = -107896753;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq42524772 = -233223313;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq83498780 = -584262787;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq30570685 = -173181696;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq95966081 = -241417153;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq91874334 = -746947144;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq43222903 = -526905652;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq77859002 = -414261946;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq40580408 = -87041755;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq23838659 = -449420870;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq72541901 = -814568587;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18784363 = -467888513;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq69561892 = -463902153;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq66831832 = -804453012;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq47233901 = -596666702;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq60604872 = -958074439;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18297157 = -410944202;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq82107864 = 57724078;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq70984017 = -217864160;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq76626375 = -720596066;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq28453481 = 37245452;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq26468681 = -325958990;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq36103585 = -242970485;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq17285702 = -477644367;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq6302421 = -148610539;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq92510775 = -85108267;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq91235923 = -850534409;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq61971777 = -619021412;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq94723114 = -640094161;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq73145145 = -736984081;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99045182 = -919898236;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq16513967 = -896262817;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq73503 = -947368066;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq13546731 = -189343408;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq10217197 = -720699331;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq88128023 = 67898377;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq21822988 = -350640255;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq64488820 = -422111721;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq25464377 = -801812167;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq69451858 = -193400816;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq16983482 = -379770053;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq52153695 = -906676228;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq42236645 = -181179794;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq78056169 = -591441869;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99808791 = 14973940;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99811155 = -633336289;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq25722133 = -924388848;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq94408927 = -753120875;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq34271179 = -61233522;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq7743962 = -284977646;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq76813142 = -95999887;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99652064 = -198528197;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq54781074 = -959320630;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq42639098 = -693514302;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq26352434 = -455656031;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq1089438 = -781937764;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq6421187 = -990252828;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq66213078 = -6618420;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq24268264 = 75428843;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq3455306 = -56308886;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq638411 = -896412736;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq81251125 = -907884241;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq83135887 = -774167785;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq67435262 = -350057674;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq24793476 = -529522635;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56027935 = -918305770;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18710861 = -520520447;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56015161 = -174558746;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56614635 = 16246319;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq59105878 = -564565080;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq38781885 = -507434184;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq53808337 = -988832482;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56643488 = -140463756;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq1532160 = 75536655;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq59642894 = -240826013;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq76299786 = -56078320;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq84232035 = -44779196;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq58047415 = -651528616;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq17476911 = -392618308;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq6491266 = -515274251;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq66788642 = -160719420;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq96826996 = 2586465;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq27700599 = -457787891;    float YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq86979152 = 59652041;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq61326192 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq60206384;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq60206384 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq30012697;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq30012697 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq82817052;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq82817052 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq1894828;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq1894828 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq72350693;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq72350693 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18595518;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18595518 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq95284025;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq95284025 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq61240759;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq61240759 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq81505079;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq81505079 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq68348834;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq68348834 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq95110298;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq95110298 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq81759929;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq81759929 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq25765091;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq25765091 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq19265473;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq19265473 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq54805915;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq54805915 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq27558118;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq27558118 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq42524772;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq42524772 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq83498780;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq83498780 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq30570685;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq30570685 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq95966081;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq95966081 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq91874334;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq91874334 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq43222903;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq43222903 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq77859002;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq77859002 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq40580408;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq40580408 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq23838659;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq23838659 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq72541901;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq72541901 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18784363;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18784363 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq69561892;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq69561892 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq66831832;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq66831832 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq47233901;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq47233901 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq60604872;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq60604872 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18297157;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18297157 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq82107864;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq82107864 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq70984017;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq70984017 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq76626375;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq76626375 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq28453481;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq28453481 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq26468681;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq26468681 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq36103585;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq36103585 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq17285702;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq17285702 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq6302421;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq6302421 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq92510775;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq92510775 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq91235923;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq91235923 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq61971777;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq61971777 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq94723114;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq94723114 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq73145145;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq73145145 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99045182;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99045182 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq16513967;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq16513967 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq73503;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq73503 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq13546731;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq13546731 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq10217197;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq10217197 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq88128023;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq88128023 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq21822988;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq21822988 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq64488820;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq64488820 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq25464377;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq25464377 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq69451858;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq69451858 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq16983482;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq16983482 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq52153695;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq52153695 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq42236645;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq42236645 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq78056169;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq78056169 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99808791;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99808791 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99811155;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99811155 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq25722133;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq25722133 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq94408927;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq94408927 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq34271179;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq34271179 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq7743962;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq7743962 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq76813142;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq76813142 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99652064;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq99652064 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq54781074;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq54781074 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq42639098;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq42639098 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq26352434;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq26352434 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq1089438;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq1089438 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq6421187;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq6421187 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq66213078;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq66213078 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq24268264;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq24268264 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq3455306;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq3455306 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq638411;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq638411 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq81251125;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq81251125 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq83135887;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq83135887 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq67435262;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq67435262 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq24793476;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq24793476 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56027935;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56027935 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18710861;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq18710861 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56015161;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56015161 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56614635;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56614635 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq59105878;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq59105878 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq38781885;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq38781885 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq53808337;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq53808337 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56643488;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq56643488 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq1532160;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq1532160 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq59642894;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq59642894 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq76299786;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq76299786 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq84232035;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq84232035 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq58047415;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq58047415 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq17476911;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq17476911 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq6491266;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq6491266 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq66788642;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq66788642 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq96826996;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq96826996 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq27700599;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq27700599 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq86979152;     YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq86979152 = YgFbsJuxCUvnLnGQjpUaVzpxjmwcluIbyUHklxeRfChbOJJoQEikezMYqHrGNRMILUorgVflKCvSSNjadIMgMYwzHitdFYEOq61326192;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void RQXKIcNBionzfqSfdJihWoFUZCYKqioeNlIFuGjzHrEsHHbDJTkZNLmdLClFDCKzzIluhMkXaiaejMNRbVAXxPRByfurU39973996() {     int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH90109629 = -256010198;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH68653170 = -469088204;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH67001769 = -786207401;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH59254223 = -376459804;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42404583 = -643650312;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH91486128 = -248948275;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH37081468 = -343779910;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH49670415 = -679058114;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH14736214 = -565825937;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH28058260 = -584281937;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH59474082 = -867283457;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH9842662 = -143616609;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH67913304 = -250583530;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH66269772 = -698524620;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH95067971 = -563724569;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH25992088 = 90874010;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH77330998 = -307256522;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH78780164 = -814035344;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH65146591 = -915108376;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH74377334 = -969425994;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97101504 = -73329407;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH31065330 = 18353310;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH47457175 = -439009270;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH54787300 = -667967048;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH14846440 = -700474915;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH94513937 = -234427730;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH90228299 = -188608363;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH40670513 = -38758525;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH78423756 = -592232735;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH64319634 = -701976269;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH47036365 = -72644612;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH77443546 = -853594752;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH79632590 = -777242981;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH29893320 = -830439015;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97564629 = -456979560;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH44517207 = -340390121;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH34304539 = -90830485;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH23987953 = -155763168;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH69642610 = -758601097;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH14667335 = -181360976;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH71847611 = -795553253;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH92021564 = -245276584;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH84086170 = 79783412;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH4114217 = -458488960;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH10701601 = -708992918;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97845508 = -499850061;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH86284693 = -406425704;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH88140834 = -426093520;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH7236238 = -97003821;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH24082975 = -843369455;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH21620475 = -862940259;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH68793925 = -957440700;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH79655791 = -714526123;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42000092 = -776558475;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42872492 = -511288887;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH59044299 = -174363508;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH21195995 = 69921066;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH12214470 = -18240354;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH44407784 = -675984889;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH47890646 = -309222583;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH1257830 = 39660088;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH96410955 = -205021385;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH71246659 = 13174620;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH50416579 = -863849668;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH81021895 = -411637326;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH82030536 = 86311294;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH30210072 = -366373628;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH38019985 = -420144515;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH68705143 = -141545060;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH50550765 = -123334449;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH91687548 = -818295505;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH53343045 = -51493354;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH9137554 = 44565753;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH50479257 = -633747400;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH2529723 = -73872741;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH5079941 = -828052823;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH46979159 = 38569898;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH43342959 = -980520310;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH44085699 = -958974130;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH17000932 = -100624854;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH8229244 = -828002026;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH2087465 = -762514844;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH33434276 = -941754704;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH54340781 = -748863280;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42699159 = -839036011;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH78242440 = -115203913;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97787754 = -39068630;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH37632498 = 99315493;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH87020827 = -219150129;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH38520330 = -182616052;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH23321212 = -310311188;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH22090070 = 27409868;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH79580169 = -479778280;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH21751965 = -349378515;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH13409505 = -121021065;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH75436656 = -490531868;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH20774905 = -158451205;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH33669591 = -56366921;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH23092321 = 53148365;    int dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH28671065 = -256010198;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH90109629 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH68653170;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH68653170 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH67001769;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH67001769 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH59254223;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH59254223 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42404583;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42404583 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH91486128;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH91486128 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH37081468;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH37081468 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH49670415;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH49670415 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH14736214;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH14736214 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH28058260;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH28058260 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH59474082;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH59474082 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH9842662;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH9842662 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH67913304;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH67913304 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH66269772;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH66269772 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH95067971;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH95067971 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH25992088;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH25992088 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH77330998;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH77330998 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH78780164;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH78780164 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH65146591;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH65146591 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH74377334;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH74377334 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97101504;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97101504 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH31065330;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH31065330 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH47457175;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH47457175 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH54787300;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH54787300 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH14846440;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH14846440 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH94513937;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH94513937 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH90228299;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH90228299 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH40670513;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH40670513 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH78423756;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH78423756 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH64319634;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH64319634 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH47036365;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH47036365 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH77443546;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH77443546 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH79632590;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH79632590 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH29893320;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH29893320 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97564629;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97564629 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH44517207;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH44517207 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH34304539;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH34304539 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH23987953;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH23987953 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH69642610;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH69642610 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH14667335;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH14667335 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH71847611;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH71847611 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH92021564;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH92021564 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH84086170;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH84086170 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH4114217;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH4114217 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH10701601;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH10701601 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97845508;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97845508 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH86284693;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH86284693 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH88140834;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH88140834 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH7236238;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH7236238 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH24082975;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH24082975 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH21620475;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH21620475 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH68793925;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH68793925 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH79655791;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH79655791 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42000092;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42000092 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42872492;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42872492 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH59044299;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH59044299 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH21195995;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH21195995 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH12214470;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH12214470 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH44407784;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH44407784 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH47890646;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH47890646 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH1257830;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH1257830 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH96410955;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH96410955 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH71246659;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH71246659 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH50416579;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH50416579 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH81021895;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH81021895 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH82030536;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH82030536 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH30210072;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH30210072 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH38019985;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH38019985 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH68705143;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH68705143 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH50550765;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH50550765 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH91687548;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH91687548 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH53343045;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH53343045 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH9137554;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH9137554 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH50479257;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH50479257 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH2529723;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH2529723 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH5079941;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH5079941 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH46979159;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH46979159 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH43342959;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH43342959 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH44085699;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH44085699 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH17000932;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH17000932 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH8229244;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH8229244 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH2087465;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH2087465 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH33434276;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH33434276 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH54340781;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH54340781 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42699159;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH42699159 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH78242440;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH78242440 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97787754;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH97787754 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH37632498;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH37632498 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH87020827;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH87020827 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH38520330;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH38520330 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH23321212;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH23321212 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH22090070;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH22090070 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH79580169;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH79580169 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH21751965;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH21751965 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH13409505;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH13409505 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH75436656;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH75436656 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH20774905;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH20774905 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH33669591;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH33669591 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH23092321;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH23092321 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH28671065;     dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH28671065 = dwEgEsyWgVxiNzelHtypTehBnCkrjvBRsCwmVyeTOvuzDokQnQqmvCAzOCsCIHnkTfpKCrQJOfbYjhyzRUDSFPWqBxXSFcLGH90109629;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void uObgHrTyNsyOhBaxFMAlycvouWEZEcDpNoMGKbZNuKPauoXskMIaRpmSTnllntulpIAspTmdmnqoMUtGzMprTdXYCtmWq58517535() {     int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI18893066 = -571672436;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI77099956 = 68499298;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI3990842 = -151476629;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI35691394 = -384698059;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI82914338 = -146437885;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI10621565 = -698301904;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI55567418 = -586335017;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI4056805 = -969825228;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI68231667 = -574077987;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI74611440 = -410663651;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI50599330 = -391514830;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI24575025 = -780289129;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI54066679 = -260362941;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI6774454 = -119864450;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70870471 = -713338772;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI97178261 = -399841402;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI27103880 = -506616290;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI15035557 = -294847375;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46794402 = -145953966;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI18183985 = -665670291;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI98236928 = 94758339;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70256325 = -316346235;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI51691448 = -351112889;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI31715598 = -921672150;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI89112471 = -213908075;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI65189216 = -19434589;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI7914697 = -662648140;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI62556663 = -709628537;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI87285620 = -720563316;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI61807436 = -599499526;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46838829 = -648622522;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI94282220 = -749115065;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI40968024 = -43541760;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI77678774 = -618602108;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI24145241 = -696094961;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI12408039 = 39815823;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI40155598 = -218906423;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI21507226 = 14432653;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI3181637 = -174231710;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI12048968 = -985077585;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI37392803 = -342495966;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI91532352 = -405444901;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI76936417 = -89898767;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46256655 = -297956509;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI26680086 = -777891675;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI22545871 = -262716041;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI73524204 = -992953172;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI59767702 = 44075778;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI14398973 = -346639576;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI34619220 = -397395502;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI33023753 = 94818814;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI49459827 = -882779777;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI37488596 = 21588010;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI19511365 = -31005229;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI60280607 = -220765607;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI48636741 = -155326201;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI25408509 = -580387814;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI72275244 = -229804480;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46578923 = -70789984;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI17725123 = -27003297;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI2706868 = 64346236;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI93010755 = -876706481;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI16771185 = -149261912;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI6424232 = -974578461;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI27772612 = -762041130;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI56317110 = -642399765;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI83607001 = -636747369;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI76387905 = -641760833;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI82629213 = -423769490;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI58462432 = -653154596;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI57022664 = -80934979;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI5596654 = -421048944;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI11853920 = -20615665;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI34745435 = -160876381;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI80791181 = -223174325;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI6704576 = -499796760;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI93319907 = -126447469;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI5434793 = 46843620;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI5035512 = -43780475;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI66566600 = -951192035;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI91665011 = -26481417;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI48146995 = -606723918;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI48157691 = -262988961;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI52666401 = -223167815;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI28783683 = -594318340;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI97379001 = -765842745;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI56793625 = -670703076;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI21456659 = 87463468;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI17398168 = -297836502;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI75508499 = -440768760;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI86999530 = -379796363;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI67880353 = -989101944;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI74928302 = -914777363;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI85456514 = -47228413;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI9342100 = -949423822;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI44382048 = -465789486;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI74761168 = -156182989;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70512186 = -115320306;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI18484044 = -535915380;    int oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70362976 = -571672436;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI18893066 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI77099956;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI77099956 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI3990842;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI3990842 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI35691394;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI35691394 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI82914338;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI82914338 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI10621565;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI10621565 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI55567418;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI55567418 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI4056805;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI4056805 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI68231667;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI68231667 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI74611440;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI74611440 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI50599330;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI50599330 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI24575025;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI24575025 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI54066679;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI54066679 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI6774454;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI6774454 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70870471;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70870471 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI97178261;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI97178261 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI27103880;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI27103880 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI15035557;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI15035557 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46794402;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46794402 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI18183985;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI18183985 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI98236928;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI98236928 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70256325;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70256325 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI51691448;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI51691448 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI31715598;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI31715598 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI89112471;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI89112471 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI65189216;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI65189216 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI7914697;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI7914697 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI62556663;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI62556663 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI87285620;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI87285620 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI61807436;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI61807436 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46838829;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46838829 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI94282220;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI94282220 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI40968024;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI40968024 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI77678774;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI77678774 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI24145241;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI24145241 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI12408039;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI12408039 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI40155598;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI40155598 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI21507226;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI21507226 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI3181637;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI3181637 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI12048968;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI12048968 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI37392803;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI37392803 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI91532352;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI91532352 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI76936417;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI76936417 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46256655;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46256655 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI26680086;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI26680086 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI22545871;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI22545871 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI73524204;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI73524204 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI59767702;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI59767702 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI14398973;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI14398973 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI34619220;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI34619220 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI33023753;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI33023753 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI49459827;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI49459827 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI37488596;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI37488596 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI19511365;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI19511365 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI60280607;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI60280607 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI48636741;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI48636741 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI25408509;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI25408509 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI72275244;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI72275244 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46578923;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI46578923 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI17725123;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI17725123 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI2706868;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI2706868 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI93010755;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI93010755 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI16771185;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI16771185 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI6424232;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI6424232 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI27772612;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI27772612 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI56317110;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI56317110 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI83607001;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI83607001 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI76387905;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI76387905 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI82629213;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI82629213 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI58462432;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI58462432 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI57022664;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI57022664 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI5596654;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI5596654 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI11853920;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI11853920 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI34745435;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI34745435 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI80791181;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI80791181 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI6704576;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI6704576 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI93319907;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI93319907 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI5434793;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI5434793 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI5035512;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI5035512 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI66566600;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI66566600 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI91665011;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI91665011 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI48146995;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI48146995 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI48157691;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI48157691 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI52666401;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI52666401 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI28783683;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI28783683 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI97379001;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI97379001 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI56793625;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI56793625 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI21456659;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI21456659 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI17398168;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI17398168 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI75508499;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI75508499 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI86999530;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI86999530 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI67880353;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI67880353 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI74928302;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI74928302 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI85456514;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI85456514 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI9342100;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI9342100 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI44382048;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI44382048 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI74761168;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI74761168 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70512186;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70512186 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI18484044;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI18484044 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70362976;     oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI70362976 = oaBQellneDQZeneyxGzuemaECRMlcpvhPnyNpYhjHTUIYSpptaEmncLCzwNNZAKpHjKqoRJZYQmLRRfkbWrCkIumcwNsKUJHI18893066;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void MRtjhXRpZxhqFEOnjLbWbvxtqMrXJTncliaTBaXjNlEok27337061() {     int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr90879835 = 93472215;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr268305 = -327907692;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr66295783 = -886045719;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr39359601 = -761057021;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr94447135 = -860327826;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr66848841 = -528208759;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr57214199 = -641073934;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr50853711 = -179774848;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr86709105 = 96459854;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr73674269 = -809520002;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr79818818 = -986259361;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr34818993 = -47719264;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr83621706 = 41912922;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60613201 = -282852047;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr65205923 = -198376472;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr77382967 = -591744344;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr23932709 = 18103060;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr29967015 = -352798091;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr5936899 = -699893418;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48594932 = -96571557;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr11939994 = -435042136;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr67910191 = -701268369;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr87555017 = -640706600;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr79862197 = -18867671;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr16979438 = -825004565;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr16557704 = -206029729;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr26756437 = -291230504;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60291060 = -536683597;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr18139446 = -466566729;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr42654935 = -654899389;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60636341 = -813707534;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr80097074 = -784565338;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr74431014 = -144557126;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr33177869 = -963831924;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr47194499 = -364438379;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr31005267 = -516932088;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr45818719 = 18806515;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr40939640 = -90891513;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr32868387 = -327017172;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48767685 = -187301952;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr7072644 = 81062708;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr13859290 = -188243835;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr46189696 = -630923719;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr61412706 = -994891185;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr88147967 = -747267245;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr59794544 = -651068955;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr11543139 = -288676464;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr23778183 = -412993700;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr55922745 = -96855026;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr44261719 = -212827577;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr25883181 = -806458506;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr29728270 = -754606634;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr31735137 = -176615797;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr41200457 = -271305896;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr15397068 = -592269411;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr22969645 = -205259417;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr12713287 = -687201093;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr86433586 = -767178048;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr22380163 = -936052456;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr77889431 = -554298098;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr40092405 = -136978256;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr96923138 = -4390338;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr32714265 = -713208120;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr44054170 = -248640757;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr13037929 = -995812468;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr99721743 = -101694024;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60387979 = -903162138;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr50443838 = 5744845;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr13418703 = -918413669;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr34200656 = -681444384;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr31564248 = -510550860;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr82993068 = -891005428;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr97098627 = 74219080;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr57169214 = -412591467;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr41522288 = -77634266;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr98080703 = -146798301;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr21720496 = 29655350;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr26142311 = -645815416;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr91714230 = -271600427;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr57184894 = -73935610;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr5014566 = -917353266;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr2978255 = -878236804;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr4368316 = -339828571;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr73877727 = -153739153;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr16771754 = -848440884;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr30908071 = 40899100;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48361938 = -507949541;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr33230558 = -873251230;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr17780802 = -271562513;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr24224854 = -59178963;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr18291980 = -829730996;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr59385133 = -214015437;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr18559478 = -154839057;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr54978955 = -772719074;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr8675280 = 49676303;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr10149505 = -914546954;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr81145025 = -475035716;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr2135526 = -282282963;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48374777 = -999078717;    int afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr88426223 = 93472215;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr90879835 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr268305;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr268305 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr66295783;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr66295783 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr39359601;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr39359601 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr94447135;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr94447135 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr66848841;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr66848841 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr57214199;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr57214199 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr50853711;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr50853711 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr86709105;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr86709105 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr73674269;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr73674269 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr79818818;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr79818818 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr34818993;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr34818993 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr83621706;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr83621706 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60613201;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60613201 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr65205923;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr65205923 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr77382967;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr77382967 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr23932709;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr23932709 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr29967015;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr29967015 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr5936899;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr5936899 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48594932;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48594932 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr11939994;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr11939994 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr67910191;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr67910191 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr87555017;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr87555017 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr79862197;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr79862197 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr16979438;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr16979438 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr16557704;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr16557704 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr26756437;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr26756437 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60291060;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60291060 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr18139446;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr18139446 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr42654935;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr42654935 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60636341;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60636341 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr80097074;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr80097074 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr74431014;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr74431014 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr33177869;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr33177869 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr47194499;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr47194499 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr31005267;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr31005267 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr45818719;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr45818719 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr40939640;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr40939640 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr32868387;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr32868387 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48767685;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48767685 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr7072644;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr7072644 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr13859290;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr13859290 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr46189696;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr46189696 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr61412706;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr61412706 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr88147967;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr88147967 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr59794544;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr59794544 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr11543139;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr11543139 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr23778183;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr23778183 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr55922745;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr55922745 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr44261719;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr44261719 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr25883181;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr25883181 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr29728270;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr29728270 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr31735137;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr31735137 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr41200457;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr41200457 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr15397068;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr15397068 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr22969645;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr22969645 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr12713287;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr12713287 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr86433586;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr86433586 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr22380163;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr22380163 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr77889431;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr77889431 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr40092405;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr40092405 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr96923138;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr96923138 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr32714265;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr32714265 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr44054170;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr44054170 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr13037929;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr13037929 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr99721743;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr99721743 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60387979;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr60387979 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr50443838;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr50443838 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr13418703;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr13418703 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr34200656;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr34200656 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr31564248;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr31564248 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr82993068;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr82993068 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr97098627;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr97098627 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr57169214;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr57169214 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr41522288;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr41522288 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr98080703;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr98080703 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr21720496;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr21720496 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr26142311;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr26142311 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr91714230;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr91714230 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr57184894;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr57184894 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr5014566;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr5014566 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr2978255;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr2978255 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr4368316;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr4368316 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr73877727;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr73877727 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr16771754;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr16771754 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr30908071;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr30908071 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48361938;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48361938 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr33230558;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr33230558 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr17780802;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr17780802 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr24224854;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr24224854 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr18291980;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr18291980 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr59385133;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr59385133 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr18559478;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr18559478 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr54978955;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr54978955 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr8675280;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr8675280 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr10149505;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr10149505 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr81145025;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr81145025 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr2135526;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr2135526 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48374777;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr48374777 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr88426223;     afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr88426223 = afxIJgvtVWQUAtVgtfGKEEWdvlJosIprJIPhuPAmr90879835;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void ZqrBgizEoGzchNLemCElGvGEsNjxkbhKItVGhihZnnNXpEpJbsnLTteejnITyCUMYpUorFxDVfyThjOoXaWs96599707() {     float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi67353219 = -298532771;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi78019885 = -211368922;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi23412307 = -747212171;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi34709619 = -332214022;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi33453189 = -644191648;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi22444271 = -518619159;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi91609155 = -308552964;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi1498469 = -540612588;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi12377238 = -343011970;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi15909238 = -226943104;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi39506685 = -47109672;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi20911428 = -205064140;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi96354420 = -860490409;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi97468208 = -917608948;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi13273847 = -13696448;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi2403503 = -280668274;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi45139911 = -751128772;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi21589171 = 13380713;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi72008858 = -267831756;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83376011 = -139194985;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi43103379 = -590437176;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi72712891 = -643459583;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi51935451 = -462956297;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi40393242 = -68467615;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi50884066 = -772161916;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi5661544 = -491027006;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi86893755 = -523278683;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi66821649 = -713667184;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi12273260 = -286792680;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70952356 = -59587239;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi80213474 = -861854424;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi22341940 = -67861577;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi10132567 = 5349269;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi514298 = -808113227;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi3711887 = -861777203;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi9322864 = -269226538;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi19576148 = -481063891;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi92813581 = -543994631;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi61675280 = -287711762;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi71361172 = -657875396;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi11335725 = 40401343;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi59884950 = -580138040;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi64698958 = -794960979;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi98117913 = -155859241;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70056867 = -753103173;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi74548609 = -879313135;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi67533858 = -737381679;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi16737034 = -983522739;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi64658799 = -513583568;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi15173569 = -225414499;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi96088224 = -296840837;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi22772713 = -136123572;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi42410178 = -376153398;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi31766472 = -74161366;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi53496329 = -827749480;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi94640327 = -655073189;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi26084435 = -748412625;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83019064 = -578744557;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83825552 = -560052107;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi27791645 = -53164643;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi35550515 = -995340476;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi24787507 = -594885780;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi89225209 = -153819908;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi41424881 = -183424731;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi35695763 = -365088680;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi17164746 = -979248095;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi10778861 = -110413410;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi95840123 = 47622818;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi93756322 = 44168254;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi3950983 = -744469911;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi82827355 = -799604384;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi52326330 = -107134141;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi59913891 = -698907525;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi647687 = -609956361;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi72040287 = -79596328;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83218429 = 89700864;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi8013934 = -848498604;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi53817538 = -207097056;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70336374 = -315364442;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi76335457 = -892848781;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi38127686 = -753645327;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70156722 = -539755945;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi2162850 = -100083617;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi97099690 = 38621819;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi74864131 = -762746402;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi57440762 = -625730853;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi79931761 = -691708180;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi78366095 = -920489366;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi47017969 = -980363747;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi9071560 = -106704014;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83238429 = -520813913;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi36557083 = -902319335;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi8988029 = -983942524;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi33883635 = -134547120;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi35810657 = -662534920;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi86548217 = -364712877;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70659740 = -326318133;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi23274077 = -511536248;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi62422150 = -790770562;    float oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi52892122 = -298532771;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi67353219 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi78019885;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi78019885 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi23412307;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi23412307 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi34709619;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi34709619 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi33453189;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi33453189 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi22444271;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi22444271 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi91609155;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi91609155 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi1498469;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi1498469 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi12377238;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi12377238 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi15909238;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi15909238 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi39506685;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi39506685 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi20911428;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi20911428 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi96354420;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi96354420 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi97468208;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi97468208 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi13273847;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi13273847 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi2403503;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi2403503 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi45139911;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi45139911 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi21589171;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi21589171 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi72008858;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi72008858 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83376011;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83376011 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi43103379;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi43103379 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi72712891;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi72712891 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi51935451;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi51935451 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi40393242;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi40393242 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi50884066;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi50884066 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi5661544;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi5661544 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi86893755;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi86893755 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi66821649;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi66821649 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi12273260;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi12273260 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70952356;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70952356 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi80213474;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi80213474 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi22341940;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi22341940 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi10132567;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi10132567 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi514298;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi514298 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi3711887;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi3711887 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi9322864;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi9322864 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi19576148;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi19576148 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi92813581;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi92813581 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi61675280;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi61675280 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi71361172;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi71361172 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi11335725;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi11335725 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi59884950;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi59884950 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi64698958;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi64698958 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi98117913;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi98117913 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70056867;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70056867 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi74548609;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi74548609 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi67533858;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi67533858 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi16737034;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi16737034 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi64658799;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi64658799 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi15173569;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi15173569 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi96088224;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi96088224 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi22772713;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi22772713 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi42410178;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi42410178 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi31766472;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi31766472 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi53496329;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi53496329 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi94640327;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi94640327 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi26084435;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi26084435 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83019064;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83019064 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83825552;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83825552 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi27791645;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi27791645 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi35550515;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi35550515 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi24787507;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi24787507 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi89225209;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi89225209 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi41424881;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi41424881 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi35695763;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi35695763 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi17164746;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi17164746 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi10778861;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi10778861 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi95840123;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi95840123 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi93756322;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi93756322 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi3950983;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi3950983 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi82827355;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi82827355 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi52326330;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi52326330 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi59913891;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi59913891 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi647687;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi647687 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi72040287;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi72040287 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83218429;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83218429 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi8013934;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi8013934 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi53817538;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi53817538 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70336374;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70336374 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi76335457;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi76335457 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi38127686;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi38127686 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70156722;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70156722 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi2162850;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi2162850 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi97099690;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi97099690 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi74864131;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi74864131 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi57440762;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi57440762 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi79931761;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi79931761 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi78366095;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi78366095 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi47017969;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi47017969 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi9071560;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi9071560 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83238429;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi83238429 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi36557083;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi36557083 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi8988029;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi8988029 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi33883635;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi33883635 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi35810657;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi35810657 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi86548217;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi86548217 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70659740;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi70659740 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi23274077;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi23274077 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi62422150;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi62422150 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi52892122;     oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi52892122 = oVrPPrXuaOakTByAkBRWvjqnuLwAZUvYfbYCxFZAhCdGFNzgkOEWJAxEfEUDuWUGTBFrcwCfcQosGjhhLPPKPZPfeUXtkVGLi67353219;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void HwAcNoKAZanmcLGGXpxFcnsEOuYHHwfOKqNhvbuVBxEjqLkKrGh648188() {     long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj15039930 = -861137592;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj16610840 = -653715221;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj94196362 = -671673702;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj46162396 = -355403182;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj36369537 = -59445566;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj76306979 = 90607664;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj91791829 = -135745120;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj32363862 = -462771887;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj25919998 = -81054779;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj9910782 = -186387928;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj18229606 = -663464647;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj99417338 = -693475687;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj38860217 = -113943566;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj70740645 = -103602546;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj8125326 = -760758666;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43520139 = -195274618;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj44500613 = -130808120;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj38456201 = -888164266;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj16647142 = -913915637;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj10387323 = -791586341;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj12966053 = -769153155;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj27472730 = 44052807;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj30520812 = -52581297;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj45821043 = -904822717;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74744007 = -869233045;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82377143 = -945120383;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj14455468 = -431686943;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj69167849 = -524264261;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj3884432 = -851723191;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj89806910 = -504467518;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj16694484 = -527570022;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj40110059 = -751548382;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj27224898 = -129417662;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj20206690 = -252572303;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74827682 = -149657586;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj41163724 = -991609787;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43453201 = -352685049;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82127089 = -64924913;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74599945 = -639116436;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82509472 = -679448073;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43981448 = 52710742;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj99248651 = -908759949;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj70499653 = 31118815;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj72296630 = -355841971;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj77996308 = -376670044;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj84816295 = -700713653;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj50133962 = -840199737;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj25760809 = -678601752;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj25561313 = 87441739;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj85571886 = -477487822;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj61519675 = -534259744;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj42424881 = -333374303;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82976589 = -707832139;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj49946349 = -338530007;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj87682134 = -132202464;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj87567199 = -805190400;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj86090027 = -501133925;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj48375319 = -766850986;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj71418389 = -486170137;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj53992393 = -114325183;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj61851512 = -477705394;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj22623981 = -611480860;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj28479431 = -611048696;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj36113087 = -576587262;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj93216298 = -658817907;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj78119546 = -911916266;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj72192440 = -464058026;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj18653528 = -861371263;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj95912963 = -953944960;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj66961601 = -769148880;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj66938 = -842589570;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj62373524 = 34116793;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj63856256 = -149047831;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj34137670 = -134467565;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj66405874 = -744297083;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj13717401 = -860393206;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj56973077 = -987066008;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj58224181 = -696739326;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj67824734 = -428152674;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj89927711 = -68519393;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj32243181 = -4920647;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj88694659 = -753085191;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43606537 = -511706000;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj18312546 = -274235369;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj28287236 = -970207774;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74269602 = -94195720;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj57133469 = 56283757;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj77278549 = -790887655;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj32524555 = -20369840;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj87260482 = -344467187;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj55073696 = -390475862;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj95077881 = -585834064;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj10708701 = -578754777;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj20607552 = -424791253;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj20657960 = -101742680;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj21357467 = -335808399;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj70769221 = -197711254;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj34386566 = -392293924;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj79080332 = -697024065;    long VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj99876762 = -861137592;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj15039930 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj16610840;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj16610840 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj94196362;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj94196362 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj46162396;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj46162396 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj36369537;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj36369537 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj76306979;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj76306979 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj91791829;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj91791829 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj32363862;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj32363862 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj25919998;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj25919998 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj9910782;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj9910782 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj18229606;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj18229606 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj99417338;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj99417338 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj38860217;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj38860217 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj70740645;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj70740645 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj8125326;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj8125326 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43520139;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43520139 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj44500613;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj44500613 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj38456201;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj38456201 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj16647142;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj16647142 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj10387323;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj10387323 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj12966053;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj12966053 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj27472730;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj27472730 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj30520812;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj30520812 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj45821043;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj45821043 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74744007;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74744007 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82377143;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82377143 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj14455468;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj14455468 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj69167849;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj69167849 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj3884432;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj3884432 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj89806910;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj89806910 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj16694484;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj16694484 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj40110059;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj40110059 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj27224898;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj27224898 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj20206690;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj20206690 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74827682;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74827682 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj41163724;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj41163724 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43453201;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43453201 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82127089;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82127089 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74599945;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74599945 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82509472;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82509472 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43981448;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43981448 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj99248651;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj99248651 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj70499653;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj70499653 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj72296630;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj72296630 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj77996308;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj77996308 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj84816295;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj84816295 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj50133962;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj50133962 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj25760809;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj25760809 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj25561313;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj25561313 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj85571886;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj85571886 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj61519675;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj61519675 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj42424881;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj42424881 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82976589;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj82976589 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj49946349;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj49946349 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj87682134;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj87682134 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj87567199;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj87567199 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj86090027;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj86090027 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj48375319;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj48375319 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj71418389;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj71418389 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj53992393;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj53992393 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj61851512;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj61851512 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj22623981;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj22623981 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj28479431;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj28479431 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj36113087;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj36113087 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj93216298;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj93216298 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj78119546;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj78119546 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj72192440;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj72192440 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj18653528;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj18653528 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj95912963;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj95912963 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj66961601;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj66961601 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj66938;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj66938 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj62373524;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj62373524 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj63856256;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj63856256 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj34137670;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj34137670 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj66405874;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj66405874 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj13717401;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj13717401 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj56973077;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj56973077 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj58224181;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj58224181 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj67824734;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj67824734 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj89927711;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj89927711 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj32243181;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj32243181 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj88694659;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj88694659 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43606537;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj43606537 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj18312546;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj18312546 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj28287236;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj28287236 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74269602;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj74269602 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj57133469;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj57133469 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj77278549;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj77278549 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj32524555;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj32524555 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj87260482;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj87260482 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj55073696;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj55073696 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj95077881;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj95077881 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj10708701;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj10708701 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj20607552;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj20607552 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj20657960;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj20657960 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj21357467;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj21357467 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj70769221;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj70769221 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj34386566;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj34386566 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj79080332;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj79080332 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj99876762;     VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj99876762 = VSvoTEwNTPDtduZcmyYKvubDeiINCKOPAOKvPBtdyObGyEbpRj15039930;}
// Junk Finished

// Junk Code By Troll Face & Thaisen's Gen
void VycVBCqgmZDoGNlORBZwwjDwPkioquarYJxzyjKvRqdQoGqgQfntUpTmugGQTCqsyMPxPlQirdeGFmHJuBXKHgWiqK55956435() {     double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83652665 = -40641034;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ8530555 = -803920821;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ63111857 = -256058616;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ20712057 = 29781552;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ40806296 = -750453014;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ59108642 = -200570289;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ2605147 = -296718160;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ50974814 = -593177805;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ89072762 = -878702813;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ37918359 = -204198159;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ47915239 = -384494990;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ61194949 = -690780815;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ68019162 = -719348639;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7989534 = -460881647;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ12900701 = -361279831;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83513692 = -890509613;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ85717236 = -239918361;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ51092949 = -615225852;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ61850748 = -870648529;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ84980866 = -982069265;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ9415672 = -74335539;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ66205284 = -179217537;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4058936 = -818773362;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ34272099 = -161676374;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4086489 = -205907243;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ34771490 = -341109968;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ81351 = -676663843;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ8716494 = -463196944;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ22983975 = -932255429;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49615949 = -324072921;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ48576107 = -263380051;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ52619393 = 58599184;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ11937722 = -581946281;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ99042388 = -255566841;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ24612838 = -115596068;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ22591035 = -668416483;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ76227178 = -104131564;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ36474305 = -657088006;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ54163738 = -226421904;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ57359721 = -394756235;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ58710802 = -738447815;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ35220531 = -184232358;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4712905 = -300250147;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ27698152 = -118283966;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ30946102 = -436684986;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ36471679 = -9905615;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ86802154 = -759389738;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ51007730 = -220782258;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83926171 = -9301913;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ29972604 = -27833664;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ21918361 = 52961992;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ60863923 = -205247546;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ41474863 = -411534474;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ37297082 = -596015834;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ46540763 = -433511647;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ17447382 = -861423498;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4471619 = -985147459;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ28839758 = 5617758;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ16625569 = -764311206;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ6034806 = -309343046;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ59027292 = -523906447;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ93888653 = -833521216;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ27990839 = -660922377;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ39456814 = -454629893;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ89342251 = -940818109;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ95295845 = -343094175;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49257228 = -8834535;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ68976774 = -363781799;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83376695 = -245285580;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ90309666 = -692863349;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7286515 = -686378050;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49242932 = -582830355;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ96929210 = -288803948;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4491027 = -375892294;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ26270065 = -143621451;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ74195141 = -890103181;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ61492380 = -878967390;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ76360784 = -600489397;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ3325998 = -724991389;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ67614809 = -96001629;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ47969336 = -581720231;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49073620 = -355881586;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ24790323 = -353895032;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ93011371 = -804421765;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ27697589 = -277034914;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ87712184 = 41867494;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ11144531 = -529866342;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ74640640 = -985930447;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ52501625 = -822055195;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7165457 = -254172571;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ18119416 = -683269024;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ47387420 = -9749323;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ19848736 = -892776801;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ48128932 = -917078859;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ98332429 = -870849789;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ64822148 = -904926599;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7229692 = -523309981;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ65256091 = -845620254;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ38355900 = -177465858;    double FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ35650256 = -40641034;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83652665 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ8530555;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ8530555 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ63111857;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ63111857 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ20712057;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ20712057 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ40806296;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ40806296 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ59108642;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ59108642 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ2605147;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ2605147 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ50974814;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ50974814 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ89072762;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ89072762 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ37918359;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ37918359 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ47915239;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ47915239 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ61194949;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ61194949 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ68019162;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ68019162 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7989534;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7989534 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ12900701;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ12900701 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83513692;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83513692 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ85717236;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ85717236 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ51092949;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ51092949 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ61850748;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ61850748 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ84980866;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ84980866 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ9415672;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ9415672 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ66205284;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ66205284 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4058936;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4058936 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ34272099;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ34272099 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4086489;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4086489 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ34771490;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ34771490 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ81351;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ81351 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ8716494;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ8716494 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ22983975;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ22983975 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49615949;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49615949 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ48576107;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ48576107 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ52619393;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ52619393 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ11937722;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ11937722 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ99042388;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ99042388 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ24612838;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ24612838 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ22591035;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ22591035 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ76227178;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ76227178 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ36474305;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ36474305 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ54163738;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ54163738 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ57359721;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ57359721 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ58710802;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ58710802 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ35220531;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ35220531 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4712905;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4712905 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ27698152;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ27698152 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ30946102;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ30946102 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ36471679;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ36471679 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ86802154;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ86802154 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ51007730;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ51007730 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83926171;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83926171 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ29972604;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ29972604 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ21918361;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ21918361 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ60863923;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ60863923 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ41474863;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ41474863 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ37297082;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ37297082 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ46540763;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ46540763 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ17447382;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ17447382 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4471619;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4471619 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ28839758;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ28839758 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ16625569;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ16625569 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ6034806;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ6034806 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ59027292;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ59027292 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ93888653;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ93888653 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ27990839;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ27990839 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ39456814;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ39456814 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ89342251;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ89342251 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ95295845;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ95295845 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49257228;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49257228 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ68976774;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ68976774 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83376695;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83376695 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ90309666;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ90309666 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7286515;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7286515 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49242932;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49242932 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ96929210;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ96929210 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4491027;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ4491027 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ26270065;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ26270065 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ74195141;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ74195141 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ61492380;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ61492380 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ76360784;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ76360784 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ3325998;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ3325998 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ67614809;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ67614809 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ47969336;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ47969336 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49073620;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ49073620 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ24790323;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ24790323 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ93011371;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ93011371 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ27697589;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ27697589 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ87712184;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ87712184 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ11144531;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ11144531 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ74640640;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ74640640 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ52501625;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ52501625 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7165457;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7165457 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ18119416;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ18119416 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ47387420;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ47387420 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ19848736;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ19848736 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ48128932;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ48128932 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ98332429;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ98332429 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ64822148;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ64822148 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7229692;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ7229692 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ65256091;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ65256091 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ38355900;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ38355900 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ35650256;     FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ35650256 = FRdtbPAlScrsQePECrLMhHZxWRefkSpgHFgyFyBOGUUeSBktvCefXddxsgXKlVAzmKlLyQ83652665;}
// Junk Finished
